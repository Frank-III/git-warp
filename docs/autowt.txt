Directory Structure:

└── ./
    ├── src
    │   └── autowt
    │       ├── commands
    │       │   ├── __init__.py
    │       │   ├── agents.py
    │       │   ├── checkout.py
    │       │   ├── cleanup.py
    │       │   ├── config.py
    │       │   ├── hooks.py
    │       │   └── ls.py
    │       ├── mkdocs_plugins
    │       │   ├── __init__.py
    │       │   ├── changelog_insert.py
    │       │   └── help_output.py
    │       ├── services
    │       │   ├── __init__.py
    │       │   ├── agent.py
    │       │   ├── git.py
    │       │   ├── hooks.py
    │       │   ├── process.py
    │       │   ├── state.py
    │       │   └── terminal.py
    │       ├── tui
    │       │   ├── __init__.py
    │       │   ├── agents.py
    │       │   ├── cleanup.py
    │       │   └── hooks.py
    │       ├── __init__.py
    │       ├── cli_config.py
    │       ├── cli.py
    │       ├── config.py
    │       ├── console.py
    │       ├── global_config.py
    │       ├── models.py
    │       ├── prompts.py
    │       └── utils.py
    ├── tests
    │   ├── mocks
    │   │   ├── __init__.py
    │   │   └── services.py
    │   ├── unit
    │   │   ├── __init__.py
    │   │   ├── test_agent_switching.py
    │   │   ├── test_checkout_conflicts.py
    │   │   ├── test_cleanup_cli.py
    │   │   ├── test_cli_init_flag.py
    │   │   ├── test_cli.py
    │   │   ├── test_commands.py
    │   │   ├── test_config_tui.py
    │   │   ├── test_config.py
    │   │   ├── test_console.py
    │   │   ├── test_models.py
    │   │   ├── test_state_logic.py
    │   │   ├── test_terminal_init_scripts.py
    │   │   ├── test_terminal_modes.py
    │   │   └── test_utils.py
    │   ├── __init__.py
    │   └── conftest.py
    ├── CLAUDE.md
    └── requirements-docs.txt



---
File: /src/autowt/commands/__init__.py
---




---
File: /src/autowt/commands/agents.py
---

"""Live agent monitoring dashboard command."""

import logging

from autowt.console import print_error
from autowt.models import Services
from autowt.services.hooks import check_and_prompt_hooks_installation
from autowt.tui.agents import AgentDashboard

logger = logging.getLogger(__name__)


def show_agent_dashboard(services: Services) -> dict | None:
    """Show live agent monitoring dashboard."""
    logger.debug("Starting agent dashboard")

    # Find git repository
    repo_path = services.git.find_repo_root()
    if not repo_path:
        print_error("Error: Not in a git repository")
        return None

    # Check if we should prompt for hooks installation (first-run experience)
    check_and_prompt_hooks_installation(services)

    # Create and run dashboard
    app = AgentDashboard(services, repo_path)
    return app.run()



---
File: /src/autowt/commands/checkout.py
---

"""Checkout/create worktree command."""

import logging
from pathlib import Path

import click

from autowt.console import print_error, print_info, print_success
from autowt.global_config import options
from autowt.models import Services, SwitchCommand, TerminalMode
from autowt.prompts import confirm_default_yes
from autowt.utils import sanitize_branch_name

logger = logging.getLogger(__name__)


def _generate_alternative_worktree_path(base_path: Path, git_worktrees: list) -> Path:
    """Generate an alternative worktree path with suffix when base path conflicts."""
    # Extract the base name without any existing suffix
    base_name = base_path.name
    parent_dir = base_path.parent

    # Try suffixes -2, -3, -4, etc.
    suffix = 2
    while suffix <= 100:  # Reasonable upper limit
        alternative_name = f"{base_name}-{suffix}"
        alternative_path = parent_dir / alternative_name

        # Check if this alternative path conflicts with any existing worktree
        conflicts = False
        for worktree in git_worktrees:
            if worktree.path == alternative_path:
                conflicts = True
                break

        if not conflicts:
            return alternative_path

        suffix += 1

    # If we somehow can't find an alternative, return original (shouldn't happen)
    return base_path


def _prompt_for_alternative_worktree(
    original_path: Path, alternative_path: Path, conflicting_branch: str
) -> bool:
    """Prompt user to confirm using an alternative worktree path."""
    print_info(
        f"That branch's original worktree is now on a different branch ('{conflicting_branch}')"
    )
    return confirm_default_yes(f"Create a new worktree at {alternative_path}?")


def checkout_branch(switch_cmd: SwitchCommand, services: Services) -> None:
    """Switch to or create a worktree for the specified branch."""
    logger.debug(f"Checking out branch: {switch_cmd.branch}")

    # Find git repository
    repo_path = services.git.find_repo_root()
    if not repo_path:
        print_error("Error: Not in a git repository")
        return

    # Load configuration
    config = services.state.load_config()
    project_config = services.state.load_project_config(repo_path)

    # Use project config init as default if no init_script provided
    init_script = switch_cmd.init_script
    if init_script is None:
        init_script = project_config.init

    # Use provided terminal mode or fall back to config
    terminal_mode = switch_cmd.terminal_mode
    if terminal_mode is None:
        terminal_mode = config.terminal

    # Enable output suppression for echo mode
    original_suppress = options.suppress_rich_output
    if terminal_mode == TerminalMode.ECHO:
        options.suppress_rich_output = True

    # Get current worktrees
    git_worktrees = services.git.list_worktrees(repo_path)

    # Check if worktree already exists
    existing_worktree = None
    for worktree in git_worktrees:
        if worktree.branch == switch_cmd.branch:
            existing_worktree = worktree
            break

    if existing_worktree:
        # Check if we're already in this worktree
        current_path = Path.cwd()
        try:
            if current_path.is_relative_to(existing_worktree.path):
                print_info(f"Already in {switch_cmd.branch} worktree")
                return
        except ValueError:
            # is_relative_to raises ValueError if not relative
            pass

        # Switch to existing worktree - no init script needed (worktree already set up)
        session_id = services.state.get_session_id(repo_path, switch_cmd.branch)
        try:
            success = services.terminal.switch_to_worktree(
                existing_worktree.path,
                terminal_mode,
                session_id,
                None,  # No init script for existing worktrees
                branch_name=switch_cmd.branch,
                auto_confirm=options.auto_confirm,
                ignore_same_session=switch_cmd.ignore_same_session,
            )

            if not success:
                print_error(f"Failed to switch to {switch_cmd.branch} worktree")
                return

            # Session ID will be registered by the new tab itself
            return
        finally:
            # Restore original suppression setting
            options.suppress_rich_output = original_suppress

    # Create new worktree
    try:
        _create_new_worktree(
            services,
            switch_cmd,
            repo_path,
            terminal_mode,
            init_script,
        )
    finally:
        # Restore original suppression setting
        options.suppress_rich_output = original_suppress


def _create_new_worktree(
    services: Services,
    switch_cmd: SwitchCommand,
    repo_path: Path,
    terminal_mode,
    init_script: str | None = None,
) -> None:
    """Create a new worktree for the branch."""
    print_info("Fetching branches...")
    if not services.git.fetch_branches(repo_path):
        print_error("Warning: Failed to fetch latest branches")

    # Generate worktree path with sanitized branch name
    worktree_path = _generate_worktree_path(repo_path, switch_cmd.branch)

    # Check if the target path already exists with a different branch
    git_worktrees = services.git.list_worktrees(repo_path)
    conflicting_worktree = None
    for worktree in git_worktrees:
        if worktree.path == worktree_path and worktree.branch != switch_cmd.branch:
            conflicting_worktree = worktree
            break

    if conflicting_worktree:
        # Generate alternative path and prompt user
        alternative_path = _generate_alternative_worktree_path(
            worktree_path, git_worktrees
        )

        if alternative_path == worktree_path:
            # Fallback to original error if we can't find an alternative
            print_error(
                f"✗ Directory {worktree_path} already exists with branch '{conflicting_worktree.branch}'"
            )
            print_error(
                f"  Try 'autowt {conflicting_worktree.branch}' to switch to existing worktree"
            )
            print_error("  Or 'autowt cleanup' to remove unused worktrees")
            return

        # Prompt user to confirm using alternative path
        if not _prompt_for_alternative_worktree(
            worktree_path, alternative_path, conflicting_worktree.branch
        ):
            print_info("Worktree creation cancelled.")
            return

        # Use the alternative path
        worktree_path = alternative_path

    print_info(f"Creating worktree for {switch_cmd.branch}...")

    # Create the worktree
    if not services.git.create_worktree(repo_path, switch_cmd.branch, worktree_path):
        print_error(f"✗ Failed to create worktree for {switch_cmd.branch}")
        return

    print_success(f"✓ Worktree created at {worktree_path}")

    # Switch to the new worktree
    success = services.terminal.switch_to_worktree(
        worktree_path,
        terminal_mode,
        None,
        init_script,
        switch_cmd.after_init,
        branch_name=switch_cmd.branch,
        ignore_same_session=switch_cmd.ignore_same_session,
    )

    if not success:
        print_error("Worktree created but failed to switch terminals")
        return

    # Session ID will be registered by the new tab itself

    print_success(f"Switched to new {switch_cmd.branch} worktree")


def _generate_worktree_path(repo_path: Path, branch: str) -> Path:
    """Generate a path for the new worktree."""
    # Find the main repository path (not a worktree)
    from autowt.services.git import GitService  # noqa: PLC0415

    git_service = GitService()
    worktrees = git_service.list_worktrees(repo_path)

    # Find the primary (main) repository
    main_repo_path = None
    for worktree in worktrees:
        if worktree.is_primary:
            main_repo_path = worktree.path
            break

    # Fallback to current repo_path if no primary found
    if not main_repo_path:
        main_repo_path = repo_path

    repo_name = main_repo_path.name

    # Sanitize branch name for filesystem
    safe_branch = sanitize_branch_name(branch)

    # Create worktrees directory next to main repo
    worktrees_dir = main_repo_path.parent / f"{repo_name}-worktrees"
    worktrees_dir.mkdir(exist_ok=True)

    return worktrees_dir / safe_branch


def find_waiting_agent_branch(services: Services) -> str | None:
    """Find the branch of an agent waiting for input."""
    repo_path = services.git.find_repo_root()
    if not repo_path:
        print_error("Error: Not in a git repository")
        return None

    git_worktrees = services.git.list_worktrees(repo_path)
    enhanced_worktrees = services.agent.enhance_worktrees_with_agent_status(
        git_worktrees, services.state, repo_path
    )

    waiting_agents = services.agent.find_waiting_agents(enhanced_worktrees)

    if not waiting_agents:
        print_info("No agents are currently waiting for input")
        return None

    if len(waiting_agents) == 1:
        # Return the only waiting agent's branch
        return waiting_agents[0].branch
    else:
        # Show interactive choice
        print_info("Multiple agents waiting for input:")
        for i, agent in enumerate(waiting_agents, 1):
            print_info(
                f"{i}. {agent.branch} (waiting since {agent.agent_status.last_activity})"
            )

        choice = click.prompt(
            "Choose agent", type=click.IntRange(1, len(waiting_agents))
        )
        return waiting_agents[choice - 1].branch


def find_latest_agent_branch(services: Services) -> str | None:
    """Find the branch of the most recently active agent."""
    repo_path = services.git.find_repo_root()
    if not repo_path:
        print_error("Error: Not in a git repository")
        return None

    git_worktrees = services.git.list_worktrees(repo_path)
    enhanced_worktrees = services.agent.enhance_worktrees_with_agent_status(
        git_worktrees, services.state, repo_path
    )

    latest_agent = services.agent.find_latest_active_agent(enhanced_worktrees)

    if not latest_agent:
        print_info("No recently active agents found")
        return None

    print_info(f"Switching to most recent agent: {latest_agent.branch}")
    return latest_agent.branch



---
File: /src/autowt/commands/cleanup.py
---

"""Cleanup worktrees command."""

import logging
from pathlib import Path

try:
    from autowt.tui.cleanup import run_cleanup_tui

    HAS_CLEANUP_TUI = True
except ImportError:
    HAS_CLEANUP_TUI = False

from autowt.models import BranchStatus, CleanupCommand, CleanupMode, Services
from autowt.prompts import confirm_default_no, confirm_default_yes

logger = logging.getLogger(__name__)


def _format_path_for_display(path: Path) -> str:
    """Format a path for display, making it relative to current directory if possible."""
    try:
        # Try to make it relative to current working directory
        current_dir = Path.cwd()
        relative_path = path.relative_to(current_dir)
        return str(relative_path)
    except ValueError:
        # If not relative to cwd, try to make it relative to home directory
        try:
            home_dir = Path.home()
            relative_path = path.relative_to(home_dir)
            return f"~/{relative_path}"
        except ValueError:
            # Fall back to absolute path
            return str(path)


def cleanup_worktrees(cleanup_cmd: CleanupCommand, services: Services) -> None:
    """Clean up worktrees based on the specified mode."""
    logger.debug(f"Cleaning up worktrees with mode: {cleanup_cmd.mode}")

    # Load config (still needed for other settings)
    config = services.state.load_config()

    # Find git repository
    repo_path = services.git.find_repo_root()
    if not repo_path:
        print("Error: Not in a git repository")
        return

    print("Fetching branches...")
    if not services.git.fetch_branches(repo_path):
        print("Warning: Failed to fetch latest branches")

    print("Checking branch status...")

    # Get worktrees and analyze them
    worktrees = services.git.list_worktrees(repo_path)
    if not worktrees:
        print("No worktrees found.")
        return

    # Filter out primary clone and any primary worktrees
    worktrees = [wt for wt in worktrees if wt.path != repo_path and not wt.is_primary]
    if not worktrees:
        print("No secondary worktrees found.")
        return

    # Analyze branches
    branch_statuses = services.git.analyze_branches_for_cleanup(repo_path, worktrees)

    # Categorize branches
    remoteless_branches = [bs for bs in branch_statuses if not bs.has_remote]
    identical_branches = [bs for bs in branch_statuses if bs.is_identical]
    merged_branches = [bs for bs in branch_statuses if bs.is_merged]

    # Display status
    _display_branch_status(remoteless_branches, identical_branches, merged_branches)

    # Determine what to clean up based on mode
    to_cleanup = _select_branches_for_cleanup(
        cleanup_cmd.mode,
        branch_statuses,
        remoteless_branches,
        identical_branches,
        merged_branches,
    )
    if not to_cleanup:
        print("No worktrees selected for cleanup.")
        return

    # Show what will be cleaned up and confirm
    if not _confirm_cleanup(to_cleanup, cleanup_cmd.mode, cleanup_cmd.dry_run):
        print("Cleanup cancelled.")
        return

    # Check for running processes in all worktrees to be removed
    all_processes = []
    for branch_status in to_cleanup:
        processes = services.process.find_processes_in_directory(branch_status.path)
        all_processes.extend(processes)

    # Handle running processes if any are found
    if all_processes:
        # Determine auto_kill value based on CLI flags and config
        if cleanup_cmd.kill_processes is not None:
            # CLI flag specified: --kill (True) or --no-kill (False)
            auto_kill = cleanup_cmd.kill_processes
        else:
            # No CLI flag specified: use config default, but still prompt if config says kill
            # If config says don't kill processes, auto-decline (like --no-kill)
            # If config says kill processes, prompt user (None)
            auto_kill = None if config.cleanup.kill_processes else False

        if not _handle_running_processes(
            to_cleanup, services.process, cleanup_cmd.dry_run, auto_kill
        ):
            print("Cleanup cancelled.")
            return

    # Remove worktrees and update state
    _remove_worktrees_and_update_state(
        to_cleanup,
        repo_path,
        services,
        cleanup_cmd.auto_confirm,
        cleanup_cmd.force,
        cleanup_cmd.dry_run,
    )


def _display_branch_status(
    remoteless_branches: list[BranchStatus],
    identical_branches: list[BranchStatus],
    merged_branches: list[BranchStatus],
) -> None:
    """Display the status of branches for cleanup."""
    if remoteless_branches:
        print("Branches without remotes:")
        for branch_status in remoteless_branches:
            print(f"- {branch_status.branch}")
        print()

    if identical_branches:
        print("Branches identical to main:")
        for branch_status in identical_branches:
            print(f"- {branch_status.branch}")
        print()

    if merged_branches:
        print("Branches that were merged:")
        for branch_status in merged_branches:
            print(f"- {branch_status.branch}")
        print()


def _select_branches_for_cleanup(
    mode: CleanupMode,
    all_statuses: list[BranchStatus],
    remoteless_branches: list[BranchStatus],
    identical_branches: list[BranchStatus],
    merged_branches: list[BranchStatus],
) -> list[BranchStatus]:
    """Select which branches to clean up based on mode."""

    def _filter_clean_worktrees(branches: list[BranchStatus]) -> list[BranchStatus]:
        """Filter out worktrees with uncommitted changes."""
        clean_branches = [b for b in branches if not b.has_uncommitted_changes]
        dirty_count = len(branches) - len(clean_branches)
        if dirty_count > 0:
            print(f"Skipping {dirty_count} worktree(s) with uncommitted changes")
        return clean_branches

    if mode == CleanupMode.ALL:
        # Combine and deduplicate by branch name
        all_branches = remoteless_branches + identical_branches + merged_branches
        seen_branches = set()
        to_cleanup = []
        for branch_status in all_branches:
            if branch_status.branch not in seen_branches:
                to_cleanup.append(branch_status)
                seen_branches.add(branch_status.branch)
        return _filter_clean_worktrees(to_cleanup)
    elif mode == CleanupMode.REMOTELESS:
        return _filter_clean_worktrees(remoteless_branches)
    elif mode == CleanupMode.MERGED:
        # Include both identical and merged branches for "merged" mode
        # since both are safe to remove
        combined = identical_branches + merged_branches
        seen_branches = set()
        to_cleanup = []
        for branch_status in combined:
            if branch_status.branch not in seen_branches:
                to_cleanup.append(branch_status)
                seen_branches.add(branch_status.branch)
        return _filter_clean_worktrees(to_cleanup)
    elif mode == CleanupMode.INTERACTIVE:
        # Interactive mode shows all worktrees including those with uncommitted changes
        # Users can make informed decisions about what to clean up
        return _interactive_selection(all_statuses)
    else:
        print(f"Unknown cleanup mode: {mode}")
        return []


def _confirm_cleanup(
    to_cleanup: list[BranchStatus], mode: CleanupMode, dry_run: bool = False
) -> bool:
    """Show what will be cleaned up and get user confirmation."""
    dry_run_prefix = "[DRY RUN] " if dry_run else ""

    print(f"\n{dry_run_prefix}Worktrees to be removed:")
    for branch_status in to_cleanup:
        display_path = _format_path_for_display(branch_status.path)
        print(f"- {branch_status.branch} ({display_path})")
    print()

    # Interactive mode already confirmed during selection
    if mode == CleanupMode.INTERACTIVE:
        return True

    prompt = f"Proceed with {'dry run' if dry_run else 'cleanup'}?"
    return confirm_default_yes(prompt)


def _handle_running_processes(
    to_cleanup: list[BranchStatus],
    process_service,
    dry_run: bool = False,
    auto_kill: bool | None = None,
) -> bool:
    """Handle processes running in worktrees to be removed."""
    all_processes = []
    for branch_status in to_cleanup:
        processes = process_service.find_processes_in_directory(branch_status.path)
        all_processes.extend(processes)

    if not all_processes:
        return True

    dry_run_prefix = "[DRY RUN] " if dry_run else ""

    # Show list of processes that will be terminated
    print(
        f"\n{dry_run_prefix}Found {len(all_processes)} running processes in worktrees to be removed:"
    )
    for process in all_processes:
        # Truncate long command lines for display
        command = process.command
        if len(command) > 80:
            command = command[:77] + "..."
        print(f"  PID {process.pid}: {command}")
        print(f"    Working directory: {process.working_dir}")

    # Determine whether to terminate processes based on auto_kill parameter
    if auto_kill is True:
        # --kill flag: automatically proceed with termination
        proceed_with_termination = True
        print(f"\n{dry_run_prefix}Terminating processes (--kill flag specified)...")
    elif auto_kill is False:
        # --no-kill flag: automatically skip termination
        proceed_with_termination = False
        print(
            f"{dry_run_prefix}Skipping process termination (--no-kill flag specified)."
        )
    else:
        # No flag: ask user for confirmation before killing processes (even in dry-run)
        proceed_with_termination = confirm_default_yes(
            f"\nTerminate these {len(all_processes)} processes?"
        )
        if not proceed_with_termination:
            print(f"{dry_run_prefix}Process termination cancelled.")

    if not proceed_with_termination:
        # For --no-kill case or user declining termination, ask if they want to continue anyway
        if auto_kill is False:
            print("Warning: Processes are still running in worktrees to be removed")
            return confirm_default_no("Continue with cleanup anyway?")
        else:
            return False

    if dry_run:
        # In dry-run mode, simulate the termination
        print(f"{dry_run_prefix}Would terminate these {len(all_processes)} processes")
        return True
    else:
        # Real execution - actually terminate processes
        if process_service.terminate_processes(all_processes):
            return True

        print("Warning: Some processes could not be terminated")
        return confirm_default_no("Continue with cleanup anyway?")


def _remove_worktrees_and_update_state(
    to_cleanup: list[BranchStatus],
    repo_path: Path,
    services: Services,
    auto_confirm: bool = False,
    force: bool = False,
    dry_run: bool = False,
) -> None:
    """Remove worktrees and update application state."""
    dry_run_prefix = "[DRY RUN] " if dry_run else ""
    print(f"{dry_run_prefix}Removing worktrees...")
    removed_count = 0
    successfully_removed_branches = []

    for branch_status in to_cleanup:
        if dry_run:
            # Simulate successful removal in dry-run mode
            print(f"{dry_run_prefix}✓ Would remove {branch_status.branch}")
            removed_count += 1
            successfully_removed_branches.append(branch_status.branch)
        else:
            # Real execution
            if services.git.remove_worktree(
                repo_path, branch_status.path, force=force, interactive=not auto_confirm
            ):
                print(f"✓ Removed {branch_status.branch}")
                removed_count += 1
                successfully_removed_branches.append(branch_status.branch)
            else:
                print(f"✗ Failed to remove {branch_status.branch}")

    # Delete local branches for successfully removed worktrees
    deleted_branches = 0
    if successfully_removed_branches:
        should_delete_branches = auto_confirm

        if not auto_confirm:
            print(f"\n{dry_run_prefix}The following local branches will be deleted:")
            for branch in successfully_removed_branches:
                print(f"  - {branch}")

            prompt = (
                f"{'Simulate deleting' if dry_run else 'Delete'} these local branches?"
            )
            should_delete_branches = confirm_default_yes(prompt)

        if should_delete_branches:
            print(f"{dry_run_prefix}Deleting local branches...")
            for branch in successfully_removed_branches:
                if dry_run:
                    # Simulate successful branch deletion in dry-run mode
                    print(f"{dry_run_prefix}✓ Would delete branch {branch}")
                    deleted_branches += 1
                else:
                    # Real execution
                    if services.git.delete_branch(repo_path, branch, force=True):
                        print(f"✓ Deleted branch {branch}")
                        deleted_branches += 1
                    else:
                        print(f"✗ Failed to delete branch {branch}")
        else:
            print(f"{dry_run_prefix}Skipped branch deletion.")

    # Update state if we removed any worktrees
    if removed_count == 0:
        print(f"\n{dry_run_prefix}Cleanup complete. No worktrees were removed.")
        return

    if dry_run:
        # In dry-run mode, simulate state updates but don't actually modify files
        print(
            f"\n{dry_run_prefix}Would update state.toml to remove {removed_count} worktrees"
        )
        removed_branches = {bs.branch for bs in to_cleanup}
        if any(
            bs.branch == "current_worktree_name" for bs in to_cleanup
        ):  # This is just for simulation
            print(f"{dry_run_prefix}Would clear current worktree setting")
        print(f"{dry_run_prefix}Would update session IDs for removed branches")
    else:
        # Real execution - update session IDs
        removed_branches = {bs.branch for bs in to_cleanup}
        for branch in removed_branches:
            services.state.remove_session_id(repo_path, branch)

        print("Session IDs updated")

    summary = f"\n{dry_run_prefix}Cleanup complete. {'Would remove' if dry_run else 'Removed'} {removed_count} worktrees"
    if deleted_branches > 0:
        summary += f" and {'would delete' if dry_run else 'deleted'} {deleted_branches} local branches"
    summary += "."
    print(summary)


def _interactive_selection(branch_statuses: list[BranchStatus]) -> list[BranchStatus]:
    """Let user interactively select which worktrees to clean up."""
    if not branch_statuses:
        return []

    # Try to use Textual TUI if available
    if HAS_CLEANUP_TUI:
        return run_cleanup_tui(branch_statuses)
    else:
        # Fall back to simple text interface
        return _simple_interactive_selection(branch_statuses)


def _simple_interactive_selection(
    branch_statuses: list[BranchStatus],
) -> list[BranchStatus]:
    """Simple text-based interactive selection."""
    print("\nInteractive cleanup mode")
    print("Select worktrees to remove:")
    print()

    selected = []

    for i, branch_status in enumerate(branch_statuses, 1):
        status_info = []
        if not branch_status.has_remote:
            status_info.append("no remote")
        if branch_status.is_merged:
            status_info.append("merged")

        status_str = f" ({', '.join(status_info)})" if status_info else ""

        if confirm_default_no(f"{i}. Remove {branch_status.branch}{status_str}?"):
            selected.append(branch_status)

    if selected:
        print(f"\nSelected {len(selected)} worktrees for removal.")

    return selected



---
File: /src/autowt/commands/config.py
---

"""Configuration command."""

import logging

from textual.app import App, ComposeResult
from textual.binding import Binding
from textual.containers import Horizontal, Vertical
from textual.widgets import Button, Label, RadioButton, RadioSet, Switch

from autowt.config import (
    CleanupConfig,
    Config,
    ConfigLoader,
    TerminalConfig,
    WorktreeConfig,
)
from autowt.models import Services, TerminalMode

logger = logging.getLogger(__name__)


class ConfigApp(App):
    """Simple configuration interface."""

    BINDINGS = [
        Binding("ctrl+s", "save", "Save & Exit"),
        Binding("escape", "cancel", "Cancel & Exit"),
        Binding("q", "cancel", "Quit"),
    ]

    def __init__(self, services: Services):
        super().__init__()
        self.services = services
        self.config = services.state.load_config()

    def compose(self) -> ComposeResult:
        """Create the UI layout."""
        with Vertical():
            yield Label("Autowt Configuration")
            yield Label("")

            yield Label("Terminal Mode:")
            with RadioSet(id="terminal-mode"):
                yield RadioButton(
                    "tab - Open/switch to terminal tab",
                    value=self.config.terminal.mode == TerminalMode.TAB,
                    id="mode-tab",
                )
                yield RadioButton(
                    "window - Open/switch to terminal window",
                    value=self.config.terminal.mode == TerminalMode.WINDOW,
                    id="mode-window",
                )
                yield RadioButton(
                    "inplace - Change directory in current terminal",
                    value=self.config.terminal.mode == TerminalMode.INPLACE,
                    id="mode-inplace",
                )
                yield RadioButton(
                    "echo - Output shell commands (for manual navigation)",
                    value=self.config.terminal.mode == TerminalMode.ECHO,
                    id="mode-echo",
                )

            yield Label("")

            with Horizontal():
                yield Switch(value=self.config.terminal.always_new, id="always-new")
                yield Label("Always create new terminal")

            yield Label("")

            with Horizontal():
                yield Switch(value=self.config.worktree.auto_fetch, id="auto-fetch")
                yield Label("Automatically fetch from remote before creating worktrees")

            yield Label("")

            with Horizontal():
                yield Switch(
                    value=self.config.cleanup.kill_processes, id="kill-processes"
                )
                yield Label("Kill processes during cleanup")

            yield Label("")

            with Horizontal():
                yield Button("Save", id="save")
                yield Button("Cancel", id="cancel")

            yield Label("")
            yield Label("For all settings, edit the config file directly:")

            # Get the actual global config path for this platform
            config_loader = ConfigLoader(app_dir=self.services.state.app_dir)
            global_config_path = config_loader.global_config_file
            yield Label(f"• Global: {global_config_path}")
            yield Label("• Project: autowt.toml or .autowt.toml in repository root")
            yield Label("")
            yield Label(
                "Navigation: Tab to move around • Ctrl+S to save • Esc/Q to cancel"
            )

    def on_button_pressed(self, event: Button.Pressed) -> None:
        """Handle button presses."""
        if event.button.id == "save":
            self._save_config()
        elif event.button.id == "cancel":
            self.exit()

    def action_save(self) -> None:
        """Save configuration via keyboard shortcut."""
        self._save_config()

    def action_cancel(self) -> None:
        """Cancel configuration via keyboard shortcut."""
        self.exit()

    def _save_config(self) -> None:
        """Save configuration and exit."""

        # Get terminal mode from radio buttons
        radio_set = self.query_one("#terminal-mode", RadioSet)
        pressed_button = radio_set.pressed_button

        terminal_mode = self.config.terminal.mode
        if pressed_button:
            if pressed_button.id == "mode-tab":
                terminal_mode = TerminalMode.TAB
            elif pressed_button.id == "mode-window":
                terminal_mode = TerminalMode.WINDOW
            elif pressed_button.id == "mode-inplace":
                terminal_mode = TerminalMode.INPLACE
            elif pressed_button.id == "mode-echo":
                terminal_mode = TerminalMode.ECHO

        # Get always new setting
        always_new_switch = self.query_one("#always-new", Switch)
        always_new = always_new_switch.value

        # Get auto fetch setting
        auto_fetch_switch = self.query_one("#auto-fetch", Switch)
        auto_fetch = auto_fetch_switch.value

        # Get kill processes setting
        kill_processes_switch = self.query_one("#kill-processes", Switch)
        kill_processes = kill_processes_switch.value

        # Create new config with updated values (immutable dataclasses)

        new_config = Config(
            terminal=TerminalConfig(
                mode=terminal_mode,
                always_new=always_new,
                program=self.config.terminal.program,
            ),
            worktree=WorktreeConfig(
                directory_pattern=self.config.worktree.directory_pattern,
                max_worktrees=self.config.worktree.max_worktrees,
                auto_fetch=auto_fetch,
                default_remote=self.config.worktree.default_remote,
                branch_sanitization=self.config.worktree.branch_sanitization,
            ),
            cleanup=CleanupConfig(
                kill_processes=kill_processes,
                kill_process_timeout=self.config.cleanup.kill_process_timeout,
                default_mode=self.config.cleanup.default_mode,
            ),
            scripts=self.config.scripts,
            confirmations=self.config.confirmations,
        )

        # Save configuration
        try:
            self.services.state.save_config(new_config)
            self.exit()
        except Exception as e:
            logger.error(f"Failed to save configuration: {e}")
            self.exit()


def show_config(services: Services) -> None:
    """Show current configuration values."""
    config = services.state.load_config()
    config_loader = ConfigLoader(app_dir=services.state.app_dir)

    print("Current Configuration:")
    print("=" * 50)
    print()

    print("Terminal:")
    print(f"  mode: {config.terminal.mode.value}")
    print(f"  always_new: {config.terminal.always_new}")
    print(f"  program: {config.terminal.program}")
    print()

    print("Worktree:")
    print(f"  directory_pattern: {config.worktree.directory_pattern}")
    print(f"  max_worktrees: {config.worktree.max_worktrees}")
    print(f"  auto_fetch: {config.worktree.auto_fetch}")
    print(f"  default_remote: {config.worktree.default_remote}")
    print(f"  branch_sanitization: {config.worktree.branch_sanitization}")
    print()

    print("Cleanup:")
    print(f"  kill_processes: {config.cleanup.kill_processes}")
    print(f"  kill_process_timeout: {config.cleanup.kill_process_timeout}")
    print(f"  default_mode: {config.cleanup.default_mode.value}")
    print()

    print("Scripts:")
    print(f"  init: {config.scripts.init}")
    if config.scripts.custom:
        print("  custom:")
        for name, script in config.scripts.custom.items():
            print(f"    {name}: {script}")
    else:
        print("  custom: {}")
    print()

    print("Confirmations:")
    print(f"  cleanup_multiple: {config.confirmations.cleanup_multiple}")
    print(f"  kill_process: {config.confirmations.kill_process}")
    print(f"  force_operations: {config.confirmations.force_operations}")
    print()

    print("Config Files:")
    print(f"  Global: {config_loader.global_config_file}")
    print("  Project: autowt.toml or .autowt.toml in repository root")


def configure_settings(services: Services) -> None:
    """Configure autowt settings interactively."""
    logger.debug("Configuring settings")

    app = ConfigApp(services)
    app.run()



---
File: /src/autowt/commands/hooks.py
---

"""Claude Code hooks installation command."""

import json
import logging
import sys
from pathlib import Path

import click

from autowt.console import print_error, print_info, print_success
from autowt.models import Services

logger = logging.getLogger(__name__)


def _is_interactive_terminal() -> bool:
    """Check if running in an interactive terminal (same as cli.py pattern)."""
    return sys.stdin.isatty()


HOOKS_CONFIG = {
    "hooks": {
        "UserPromptSubmit": [
            {
                "hooks": [
                    {
                        "type": "command",
                        "command": 'ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd) && mkdir -p "$ROOT/.claude/autowt" && echo "{\\"status\\":\\"processing\\",\\"last_activity\\":\\"$(date -Iseconds)\\"}" > "$ROOT/.claude/autowt/status"',
                    }
                ],
                "autowt_hook_id": "agent_status_userpromptsubmit",
            }
        ],
        "Stop": [
            {
                "hooks": [
                    {
                        "type": "command",
                        "command": 'ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd) && mkdir -p "$ROOT/.claude/autowt" && echo "{\\"status\\":\\"waiting\\",\\"last_activity\\":\\"$(date -Iseconds)\\"}" > "$ROOT/.claude/autowt/status"',
                    }
                ],
                "autowt_hook_id": "agent_status_stop",
            }
        ],
        "PreToolUse": [
            {
                "hooks": [
                    {
                        "type": "command",
                        "command": 'ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd) && mkdir -p "$ROOT/.claude/autowt" && echo "{\\"status\\":\\"working\\",\\"last_activity\\":\\"$(date -Iseconds)\\"}" > "$ROOT/.claude/autowt/status"',
                    }
                ],
                "autowt_hook_id": "agent_status_pretooluse",
            }
        ],
        "PostToolUse": [
            {
                "hooks": [
                    {
                        "type": "command",
                        "command": 'ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd) && mkdir -p "$ROOT/.claude/autowt" && echo "{\\"status\\":\\"processing\\",\\"last_activity\\":\\"$(date -Iseconds)\\"}" > "$ROOT/.claude/autowt/status"',
                    }
                ],
                "autowt_hook_id": "agent_status_posttooluse",
            }
        ],
        "SubagentStop": [
            {
                "hooks": [
                    {
                        "type": "command",
                        "command": 'ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd) && mkdir -p "$ROOT/.claude/autowt" && echo "{\\"status\\":\\"subagent_complete\\",\\"last_activity\\":\\"$(date -Iseconds)\\"}" > "$ROOT/.claude/autowt/status"',
                    }
                ],
                "autowt_hook_id": "agent_status_subagent_stop",
            }
        ],
    }
}


def install_hooks_command(
    level: str | None, services: Services, dry_run: bool = False
) -> None:
    """Install Claude Code hooks for agent monitoring."""

    if level is None:
        # Check if we're in a TTY before launching TUI
        if not _is_interactive_terminal():
            print_error(
                "Interactive TUI requires a terminal. Use --user or --project flags."
            )
            return

        # Launch TUI for interactive installation
        from autowt.tui.hooks import HooksApp  # noqa: PLC0415

        app = HooksApp(services)
        result = app.run()

        if not result:
            # User cancelled
            return

        if result == "console":
            # Print configuration to console
            print_info("Add this to your Claude Code settings:")
            print(json.dumps(HOOKS_CONFIG, indent=2))
            return

        # Handle installation plan
        if isinstance(result, dict) and result.get("action") == "install":
            settings_path = result["path"]
            description = result["description"]

            # Show what will be installed
            click.echo("\nReady to install hooks:")
            click.echo(f"  Location: {settings_path}")
            click.echo(f"  Level: {description}")
            click.echo(
                "  Hooks: UserPromptSubmit, PreToolUse, PostToolUse, Stop, SubagentStop"
            )

            # Final confirmation
            if click.confirm("Install hooks to this location?", default=True):
                try:
                    _install_hooks_to_path(settings_path)
                    print_success(f"Hooks installed successfully to {settings_path}")
                except Exception as e:
                    print_error(f"Error installing hooks: {e}")
            else:
                click.echo("Installation cancelled.")
        return

    if level == "console":
        print_info("Add this to your Claude Code settings:")
        print(json.dumps(HOOKS_CONFIG, indent=2))
        return

    if level == "user":
        settings_path = Path.home() / ".claude" / "settings.json"
        if dry_run:
            print_info(f"Would install hooks to user settings: {settings_path}")
        else:
            print_info(f"Installing hooks to user settings: {settings_path}")
    else:  # project
        # Ask user whether to use settings.json (tracked by git) or settings.local.json (local only)
        click.echo("\nChoose project settings file:")
        click.echo("1. settings.json (shared with team, tracked by git)")
        click.echo("2. settings.local.json (local only, not tracked by git)")

        file_choice = click.prompt("Enter choice", type=click.Choice(["1", "2"]))
        filename = "settings.json" if file_choice == "1" else "settings.local.json"

        settings_path = Path.cwd() / ".claude" / filename
        if dry_run:
            print_info(f"Would install hooks to project settings: {settings_path}")
        else:
            print_info(f"Installing hooks to project settings: {settings_path}")

    # Ensure directory exists (unless dry-run)
    if not dry_run:
        settings_path.parent.mkdir(parents=True, exist_ok=True)

    # Load existing settings
    existing_settings = {}
    if settings_path.exists():
        try:
            existing_settings = json.loads(settings_path.read_text())
        except json.JSONDecodeError:
            print_error(f"Error: Invalid JSON in {settings_path}")
            return

    # Merge hooks
    if "hooks" not in existing_settings:
        existing_settings["hooks"] = {}

    # Check if autowt hooks need updating
    hooks_need_update = False
    hooks_added = 0
    hooks_removed = 0

    # Check for hook types that should be removed (exist in settings but not in HOOKS_CONFIG)
    for hook_type in existing_settings["hooks"]:
        if hook_type not in HOOKS_CONFIG["hooks"]:
            # Check if this hook type has autowt hooks that should be removed
            existing_autowt_hooks = [
                hook
                for hook in existing_settings["hooks"][hook_type]
                if hook.get("autowt_hook_id", "").startswith("agent_status_")
            ]
            if existing_autowt_hooks:
                hooks_need_update = True
                break

    # Check if current autowt hooks match what we want to install
    for hook_type, hook_configs in HOOKS_CONFIG["hooks"].items():
        if hook_type not in existing_settings["hooks"]:
            hooks_need_update = True
            break

        # Get existing autowt hooks for this type
        existing_autowt_hooks = [
            hook
            for hook in existing_settings["hooks"][hook_type]
            if hook.get("autowt_hook_id", "").startswith("agent_status_")
        ]

        # Compare with desired hooks
        desired_hook_ids = {hook["autowt_hook_id"] for hook in hook_configs}
        existing_hook_ids = {
            hook.get("autowt_hook_id") for hook in existing_autowt_hooks
        }

        if desired_hook_ids != existing_hook_ids:
            hooks_need_update = True
            break

        # Also check if hook content changed
        for desired_hook in hook_configs:
            matching_hook = next(
                (
                    h
                    for h in existing_autowt_hooks
                    if h.get("autowt_hook_id") == desired_hook["autowt_hook_id"]
                ),
                None,
            )
            if not matching_hook:
                hooks_need_update = True
                break

            # Compare the nested hooks content
            desired_commands = [h.get("command") for h in desired_hook.get("hooks", [])]
            existing_commands = [
                h.get("command") for h in matching_hook.get("hooks", [])
            ]

            if desired_commands != existing_commands:
                hooks_need_update = True
                break

        if hooks_need_update:
            break

    # Only update if needed
    if hooks_need_update:
        # Remove existing autowt hooks
        for hook_type in existing_settings["hooks"]:
            original_count = len(existing_settings["hooks"][hook_type])
            existing_settings["hooks"][hook_type] = [
                hook
                for hook in existing_settings["hooks"][hook_type]
                if not hook.get("autowt_hook_id", "").startswith("agent_status_")
            ]
            hooks_removed += original_count - len(existing_settings["hooks"][hook_type])

        # Add current autowt hooks
        for hook_type, hook_configs in HOOKS_CONFIG["hooks"].items():
            if hook_type not in existing_settings["hooks"]:
                existing_settings["hooks"][hook_type] = []

            for new_hook in hook_configs:
                existing_settings["hooks"][hook_type].append(new_hook)
                hooks_added += 1

    # Write updated settings (unless dry-run)
    if dry_run:
        if hooks_need_update:
            if hooks_removed > 0 and hooks_added > 0:
                print_info(
                    f"Would update autowt hooks: remove {hooks_removed}, add {hooks_added}"
                )
            elif hooks_added > 0:
                print_info(f"Would add {hooks_added} new hooks")
        else:
            print_info("All autowt hooks are already up to date")
        print_info(f"[DRY RUN] No changes made to {settings_path}")
    else:
        if hooks_need_update:
            if hooks_removed > 0 and hooks_added > 0:
                try:
                    settings_path.write_text(json.dumps(existing_settings, indent=2))
                    print_success(
                        f"Updated autowt hooks in {settings_path} (removed {hooks_removed}, added {hooks_added})"
                    )
                except Exception as e:
                    print_error(f"Error writing settings: {e}")
            elif hooks_added > 0:
                try:
                    settings_path.write_text(json.dumps(existing_settings, indent=2))
                    print_success(
                        f"Added {hooks_added} autowt hooks to {settings_path}"
                    )
                except Exception as e:
                    print_error(f"Error writing settings: {e}")
        else:
            print_info(f"All autowt hooks are already up to date in {settings_path}")


def show_installed_hooks(services: Services) -> None:
    """Show currently installed autowt hooks at user and project levels."""

    user_settings_path = Path.home() / ".claude" / "settings.json"
    project_settings_path = Path.cwd() / ".claude" / "settings.json"
    project_local_settings_path = Path.cwd() / ".claude" / "settings.local.json"

    click.echo("Autowt Hooks Status:")
    click.echo("=" * 40)

    # Check user level
    click.echo("\nUser Level (~/.claude/settings.json):")
    _show_hooks_for_level(user_settings_path)

    # Check project level
    click.echo("\nProject Level (./.claude/settings.json):")
    _show_hooks_for_level(project_settings_path)

    # Check project local level
    click.echo("\nProject Local Level (./.claude/settings.local.json):")
    _show_hooks_for_level(project_local_settings_path)


def _show_hooks_for_level(settings_path: Path) -> None:
    """Show hook status for a specific settings file."""
    if settings_path.exists():
        try:
            existing_settings = json.loads(settings_path.read_text())
            installed_hooks = _extract_autowt_hooks(existing_settings)

            if installed_hooks:
                click.echo("  ✓ Hooks installed:")
                for hook_type, hooks in installed_hooks.items():
                    click.echo(f"    {hook_type}: {len(hooks)} autowt hook(s)")
            else:
                click.echo("  No autowt hooks installed")
        except json.JSONDecodeError:
            print_error(f"  Error: Invalid JSON in {settings_path}")
        except Exception as e:
            print_error(f"  Error reading file: {e}")
    else:
        click.echo("  No settings file found")


def _extract_autowt_hooks(settings: dict) -> dict:
    """Extract autowt hooks from settings, grouped by hook type."""
    autowt_hooks = {}

    if "hooks" not in settings:
        return autowt_hooks

    for hook_type, hooks in settings["hooks"].items():
        autowt_hooks_for_type = [
            hook
            for hook in hooks
            if hook.get("autowt_hook_id", "").startswith("agent_status_")
        ]
        if autowt_hooks_for_type:
            autowt_hooks[hook_type] = autowt_hooks_for_type

    return autowt_hooks


def _install_hooks_to_path(settings_path: Path) -> None:
    """Install hooks to a specific settings file."""
    # Ensure directory exists
    settings_path.parent.mkdir(parents=True, exist_ok=True)

    # Load existing settings
    existing_settings = {}
    if settings_path.exists():
        try:
            existing_settings = json.loads(settings_path.read_text())
        except json.JSONDecodeError:
            pass

    # Initialize hooks section
    if "hooks" not in existing_settings:
        existing_settings["hooks"] = {}

    # Remove existing autowt hooks
    for hook_type in existing_settings["hooks"]:
        existing_settings["hooks"][hook_type] = [
            hook
            for hook in existing_settings["hooks"][hook_type]
            if not hook.get("autowt_hook_id", "").startswith("agent_status_")
        ]

    # Add current autowt hooks
    for hook_type, hook_configs in HOOKS_CONFIG["hooks"].items():
        if hook_type not in existing_settings["hooks"]:
            existing_settings["hooks"][hook_type] = []

        for new_hook in hook_configs:
            existing_settings["hooks"][hook_type].append(new_hook)

    # Write updated settings
    settings_path.write_text(json.dumps(existing_settings, indent=2))


def remove_hooks_command(level: str, services: Services, dry_run: bool = False) -> None:
    """Remove autowt hooks from Claude Code settings."""
    if level == "user":
        settings_path = Path.home() / ".claude" / "settings.json"
        if dry_run:
            print_info(f"Would remove hooks from user settings: {settings_path}")
        else:
            print_info(f"Removing hooks from user settings: {settings_path}")
    else:  # project
        settings_path = Path.cwd() / ".claude" / "settings.json"
        project_local_path = Path.cwd() / ".claude" / "settings.local.json"

        # Check both project files and prompt user which to clean
        project_has_hooks = _has_autowt_hooks_in_file(settings_path)
        local_has_hooks = _has_autowt_hooks_in_file(project_local_path)

        if project_has_hooks and local_has_hooks:
            click.echo("Found autowt hooks in both project settings files:")
            click.echo("1. settings.json (shared)")
            click.echo("2. settings.local.json (local)")
            click.echo("3. Both")

            choice = click.prompt(
                "Remove hooks from which file?", type=click.Choice(["1", "2", "3"])
            )
            if choice == "1":
                settings_path = settings_path
            elif choice == "2":
                settings_path = project_local_path
            else:  # choice == "3"
                # Remove from both files
                _remove_hooks_from_file(settings_path, dry_run)
                _remove_hooks_from_file(project_local_path, dry_run)
                return
        elif project_has_hooks:
            settings_path = settings_path
        elif local_has_hooks:
            settings_path = project_local_path
        else:
            print_info("No autowt hooks found in project settings files")
            return

        if dry_run:
            print_info(f"Would remove hooks from project settings: {settings_path}")
        else:
            print_info(f"Removing hooks from project settings: {settings_path}")

    _remove_hooks_from_file(settings_path, dry_run)


def _remove_hooks_from_file(settings_path: Path, dry_run: bool = False) -> None:
    """Remove autowt hooks from a specific settings file."""
    if not settings_path.exists():
        print_info(f"Settings file not found: {settings_path}")
        return

    try:
        existing_settings = json.loads(settings_path.read_text())
    except json.JSONDecodeError:
        print_error(f"Error: Invalid JSON in {settings_path}")
        return

    if "hooks" not in existing_settings:
        print_info(f"No hooks section found in {settings_path}")
        return

    # Count autowt hooks before removal
    hooks_removed = 0
    for hook_type in existing_settings["hooks"]:
        original_count = len(existing_settings["hooks"][hook_type])
        existing_settings["hooks"][hook_type] = [
            hook
            for hook in existing_settings["hooks"][hook_type]
            if not hook.get("autowt_hook_id", "").startswith("agent_status_")
        ]
        hooks_removed += original_count - len(existing_settings["hooks"][hook_type])

    if hooks_removed == 0:
        print_info(f"No autowt hooks found in {settings_path}")
        return

    if dry_run:
        print_info(f"Would remove {hooks_removed} autowt hooks from {settings_path}")
    else:
        try:
            settings_path.write_text(json.dumps(existing_settings, indent=2))
            print_success(f"Removed {hooks_removed} autowt hooks from {settings_path}")
        except Exception as e:
            print_error(f"Error writing settings: {e}")


def _has_autowt_hooks_in_file(settings_path: Path) -> bool:
    """Check if a specific settings file contains autowt hooks."""
    if not settings_path.exists():
        return False

    try:
        with open(settings_path) as f:
            settings = json.load(f)

        autowt_hooks = _extract_autowt_hooks(settings)
        return len(autowt_hooks) > 0

    except (json.JSONDecodeError, Exception) as e:
        logger.debug(f"Error reading {settings_path}: {e}")
        return False


def _extract_autowt_hooks(settings: dict) -> dict:
    """Extract autowt hooks from settings, grouped by hook type."""
    autowt_hooks = {}

    if "hooks" not in settings:
        return autowt_hooks

    for hook_type, hooks in settings["hooks"].items():
        autowt_hooks_for_type = [
            hook
            for hook in hooks
            if hook.get("autowt_hook_id", "").startswith("agent_status_")
        ]
        if autowt_hooks_for_type:
            autowt_hooks[hook_type] = autowt_hooks_for_type

    return autowt_hooks



---
File: /src/autowt/commands/ls.py
---

"""List worktrees command."""

import logging
import shutil
from dataclasses import dataclass
from pathlib import Path

from autowt.console import console, print_error, print_plain, print_section
from autowt.models import Services
from autowt.services.hooks import check_and_prompt_hooks_installation

logger = logging.getLogger(__name__)


@dataclass
class WorktreeSegments:
    """Segments for formatting a worktree display line."""

    left: str  # Current indicator + path
    middle: str  # Session and agent indicators
    main_indicator: str  # "(main worktree)" with styling
    right: str  # Branch + current indicator


def _format_worktree_line(worktree, current_worktree_path, terminal_width: int) -> str:
    """Format a single worktree line with proper spacing and alignment."""
    # Build display path
    try:
        relative_path = worktree.path.relative_to(Path.home())
        display_path = f"~/{relative_path}"
    except ValueError:
        display_path = str(worktree.path)

    # Build segments
    segments = _build_worktree_segments(worktree, display_path, current_worktree_path)

    # Combine segments with intelligent spacing
    return _combine_segments(segments, terminal_width)


def _build_worktree_segments(
    worktree, display_path: str, current_worktree_path
) -> WorktreeSegments:
    """Build the individual segments for a worktree line."""
    # Left segment: current indicator + path
    current_indicator = "→ " if current_worktree_path == worktree.path else "  "
    left = f"{current_indicator}{display_path}"

    # Middle segment: session and agent indicators with proper spacing
    indicators = []
    if worktree.has_active_session:
        indicators.append("@")
    if worktree.agent_status:
        indicators.append(worktree.agent_status.status_indicator)

    middle = " " + "".join(indicators) if indicators else ""

    # Main worktree indicator (styled)
    main_indicator = (
        "[dim grey50] (main worktree)[/dim grey50]" if worktree.is_primary else ""
    )

    # Right segment: branch + current indicator + padding for alignment
    branch_indicator = " ←" if current_worktree_path == worktree.path else ""
    padding = "" if current_worktree_path == worktree.path else "  "
    right = f"{worktree.branch}{branch_indicator}{padding}"

    return WorktreeSegments(
        left=left, middle=middle, main_indicator=main_indicator, right=right
    )


def _combine_segments(segments: WorktreeSegments, terminal_width: int) -> str:
    """Combine worktree segments with intelligent spacing."""
    # Calculate content length (without styling tags for main indicator)
    main_indicator_text = (
        " (main worktree)" if "main worktree" in segments.main_indicator else ""
    )
    content_length = (
        len(segments.left)
        + len(segments.middle)
        + len(main_indicator_text)
        + len(segments.right)
    )

    # Determine spacing
    min_spacing = 2  # Minimum space between left content and right branch

    if content_length + min_spacing <= terminal_width:
        # We have room - distribute remaining space
        padding = terminal_width - content_length
        return f"{segments.left}{segments.middle}{segments.main_indicator}{' ' * padding}{segments.right}"
    else:
        # Tight fit - use minimal spacing
        return f"{segments.left}{segments.middle}{segments.main_indicator}  {segments.right}"


def list_worktrees(services: Services, debug: bool = False) -> None:
    """List all worktrees and their status."""
    logger.debug("Listing worktrees")

    # Find git repository
    repo_path = services.git.find_repo_root()
    if not repo_path:
        print_error("Error: Not in a git repository")
        return

    # Check if we should prompt for hooks installation (first-run experience)
    check_and_prompt_hooks_installation(services)

    # Get current directory to determine which worktree we're in
    current_path = Path.cwd()

    # Get worktrees from git
    git_worktrees = services.git.list_worktrees(repo_path)

    # Show debug information about paths if requested
    if debug:
        print_section("  Debug Information:")
        print_plain(f"    State directory: {services.state.app_dir}")
        print_plain(f"    State file: {services.state.state_file}")
        print_plain(f"    Config file: {services.state.config_file}")
        print_plain(f"    Session file: {services.state.session_file}")
        print_plain(f"    Git repository root: {repo_path}")

        # Check for project config files
        current_dir = Path.cwd()
        project_config_files = [
            current_dir / "autowt.toml",
            current_dir / ".autowt.toml",
        ]
        for config_file in project_config_files:
            if config_file.exists():
                print_plain(f"    Project config: {config_file}")

        print_plain("")

    # Enhance worktrees with agent status
    enhanced_worktrees = services.agent.enhance_worktrees_with_agent_status(
        git_worktrees, services.state, repo_path
    )

    # Determine which worktree we're currently in
    current_worktree_path = None
    for worktree in git_worktrees:
        try:
            if current_path.is_relative_to(worktree.path):
                current_worktree_path = worktree.path
                break
        except ValueError:
            # is_relative_to raises ValueError if not relative
            continue

    if not enhanced_worktrees:
        print_plain("  No worktrees found.")
        return

    print_section("  Worktrees:")

    # Sort worktrees: primary first, then by branch name
    sorted_worktrees = sorted(
        enhanced_worktrees, key=lambda w: (not w.is_primary, w.branch)
    )

    # Calculate the maximum terminal width to align branch names
    terminal_width = 80  # Default fallback
    try:
        terminal_width = shutil.get_terminal_size().columns
    except OSError:
        pass

    for worktree in sorted_worktrees:
        line = _format_worktree_line(worktree, current_worktree_path, terminal_width)
        if worktree.is_primary and "[dim grey50]" in line:
            console.print(line)
        else:
            print_plain(line)

    print_plain("")
    print_plain("Use 'autowt <branch>' to switch to a worktree or create a new one.")



---
File: /src/autowt/mkdocs_plugins/__init__.py
---




---
File: /src/autowt/mkdocs_plugins/changelog_insert.py
---

"""
MkDocs plugin to automatically insert the contents of CHANGELOG.md into documentation.

This plugin processes markdown files looking for comments in the format:
<!-- CHANGELOG_INSERT -->

And replaces the entire file content with the contents of CHANGELOG.md from the repo root.
"""

import logging
from pathlib import Path
from typing import Any

from mkdocs.config import config_options
from mkdocs.plugins import BasePlugin
from mkdocs.structure.pages import Page

logger = logging.getLogger(__name__)


class ChangelogInsertConfig(config_options.Config):
    """Configuration for the changelog insert plugin."""

    changelog_path = config_options.Type(str, default="CHANGELOG.md")
    """Path to the changelog file relative to the project root"""

    insert_marker = config_options.Type(str, default="<!-- CHANGELOG_INSERT -->")
    """Marker to look for in markdown files to insert changelog content"""


class ChangelogInsertPlugin(BasePlugin[ChangelogInsertConfig]):
    """Plugin to insert changelog content into markdown files."""

    def __init__(self):
        super().__init__()
        self._changelog_content = None

    def _get_changelog_content(self, config_file_path: str) -> str:
        """
        Read and cache the changelog content.

        Args:
            config_file_path: Path to the mkdocs config file to determine project root

        Returns:
            The changelog content
        """
        if self._changelog_content is not None:
            return self._changelog_content

        # Determine project root from config file location
        config_path = Path(config_file_path)
        project_root = config_path.parent

        # Build path to changelog
        changelog_path = project_root / self.config.changelog_path

        logger.info(f"Looking for changelog at: {changelog_path}")

        if not changelog_path.exists():
            logger.warning(f"Changelog file not found at: {changelog_path}")
            self._changelog_content = (
                f"<!-- Changelog file not found at {changelog_path} -->"
            )
            return self._changelog_content

        try:
            with open(changelog_path, encoding="utf-8") as f:
                self._changelog_content = f.read().strip()
                logger.info(f"Successfully loaded changelog from: {changelog_path}")
                return self._changelog_content
        except Exception as e:
            logger.error(f"Error reading changelog file: {e}")
            self._changelog_content = f"<!-- Error reading changelog: {e} -->"
            return self._changelog_content

    def on_page_markdown(
        self, markdown: str, page: Page, config: dict[str, Any], files
    ) -> str:
        """
        Process markdown content to replace changelog insert markers with actual content.

        Args:
            markdown: The markdown content
            page: The page object
            config: MkDocs configuration
            files: All site files

        Returns:
            The processed markdown content
        """
        # Check if this markdown contains the insert marker
        if self.config.insert_marker not in markdown:
            return markdown

        logger.debug(f"Processing changelog insert for page: {page.file.src_path}")

        # Get changelog content
        changelog_content = self._get_changelog_content(
            config.get("config_file_path", "mkdocs.yml")
        )

        # Replace the marker with the changelog content
        processed_markdown = markdown.replace(
            self.config.insert_marker, changelog_content
        )

        return processed_markdown



---
File: /src/autowt/mkdocs_plugins/help_output.py
---

"""
MkDocs plugin to automatically insert program --help output as code blocks.

This plugin processes markdown files looking for comments in the format:
<!-- program subcommand --help -->

And replaces the following code block with the actual help output,
including the original command string.
"""

import logging
import re
import subprocess
from pathlib import Path
from typing import Any

from mkdocs.config import config_options
from mkdocs.plugins import BasePlugin
from mkdocs.structure.pages import Page

logger = logging.getLogger(__name__)


class HelpOutputConfig(config_options.Config):
    """Configuration for the help output plugin."""

    command_prefix = config_options.Type(str, default="uv run")
    """Command prefix to use when executing help commands (e.g., 'uv run', 'python -m')"""

    path_replacements = config_options.Type(dict, default={})
    """Dictionary of path replacements to make output more generic"""

    filter_patterns = config_options.Type(
        list,
        default=[
            r"Installing dependencies\.\.\.",
            r"^\[deps:sync\]",
            r"^\s*\+\s+\w+==",  # + package==version
            r"^\s*\$\s+uv\s+sync",  # $ uv sync commands
            r"mise WARN",  # mise warnings
        ],
    )
    """Regex patterns to filter out from command output"""


class HelpOutputPlugin(BasePlugin[HelpOutputConfig]):
    """Plugin to insert command help output into markdown files."""

    def __init__(self):
        super().__init__()
        self.processed_commands = {}  # Cache for command outputs

    def _get_help_text(self, command: str) -> str:
        """
        Execute a command with --help and return the output.

        Args:
            command: The command to execute (without --help)

        Returns:
            The filtered help output
        """
        if command in self.processed_commands:
            return self.processed_commands[command]

        logger.info(f"Fetching help for: {command}")

        # Build command array
        if self.config.command_prefix:
            cmd_array = (
                self.config.command_prefix.split() + command.split() + ["--help"]
            )
        else:
            cmd_array = command.split() + ["--help"]

        try:
            result = subprocess.run(
                cmd_array,
                capture_output=True,
                text=True,
                check=True,
                timeout=30,  # 30 second timeout
            )

            # Filter stdout
            filtered_lines = self._filter_output_lines(result.stdout.splitlines())
            output = "\n".join(filtered_lines)

            # Filter stderr if present
            if result.stderr:
                stderr_filtered = self._filter_output_lines(result.stderr.splitlines())
                if stderr_filtered:
                    output += "\n" + "\n".join(stderr_filtered)

            # Apply path replacements
            output = self._apply_path_replacements(output)

            # Cache the result
            self.processed_commands[command] = output.strip()
            return self.processed_commands[command]

        except subprocess.CalledProcessError as e:
            error_msg = f"Error: Could not get help for command '{command}'"
            logger.error(f"Command failed: {' '.join(cmd_array)}, error: {e}")
            self.processed_commands[command] = error_msg
            return error_msg
        except subprocess.TimeoutExpired:
            error_msg = f"Error: Timeout getting help for command '{command}'"
            logger.error(f"Command timed out: {' '.join(cmd_array)}")
            self.processed_commands[command] = error_msg
            return error_msg

    def _filter_output_lines(self, lines: list) -> list:
        """Filter out unwanted lines from command output."""
        filtered_lines = []
        for line in lines:
            should_filter = False
            for pattern in self.config.filter_patterns:
                if re.search(pattern, line):
                    should_filter = True
                    break
            if not should_filter:
                filtered_lines.append(line)
        return filtered_lines

    def _apply_path_replacements(self, text: str) -> str:
        """Apply path replacements to make output more generic."""
        # Get user's home directory for smart replacement
        home = str(Path.home())

        # Smart replacements that work for any user
        replacements = {
            home: "~",  # Replace full home path with ~
        }

        # Add user-configured replacements
        replacements.update(self.config.path_replacements)

        # Apply replacements (order matters - longest paths first)
        for old_path, new_path in sorted(
            replacements.items(), key=lambda x: len(x[0]), reverse=True
        ):
            text = text.replace(old_path, new_path)

        # Additional smart replacements for common patterns
        # Replace any remaining user-specific paths in common locations

        # Replace /Users/username/ patterns with ~/
        text = re.sub(r"/Users/[^/]+/", "~/", text)

        # Replace /home/username/ patterns with ~/
        text = re.sub(r"/home/[^/]+/", "~/", text)

        return text

    def on_page_markdown(
        self, markdown: str, page: Page, config: dict[str, Any], files
    ) -> str:
        """
        Process markdown content to replace help output comments with actual output.

        Args:
            markdown: The markdown content
            page: The page object
            config: MkDocs configuration
            files: All site files

        Returns:
            The processed markdown content
        """
        # Pattern to match help output comments
        # Examples: <!-- autowt --help --> or <!-- autowt init --help -->
        help_comment_pattern = r"<!--\s*([^-]+?)\s*--help\s*-->"

        def replace_help_block(match):
            command = match.group(1).strip()
            logger.debug(f"Processing help comment for command: {command}")

            # Get the help text
            help_output = self._get_help_text(command)

            # Format the output with command line and help text
            full_command = f"{command} --help"
            formatted_output = f"> {full_command}\n\n{help_output}"

            return f"<!-- {command} --help -->\n```\n{formatted_output}\n```"

        # Find and process all help comments followed by code blocks
        lines = markdown.split("\n")
        processed_lines = []
        i = 0

        while i < len(lines):
            line = lines[i]

            # Check if this line has a help comment
            help_match = re.search(help_comment_pattern, line)
            if help_match:
                command = help_match.group(1).strip()

                # Add the comment line
                processed_lines.append(line)
                i += 1

                # Look for the opening code fence
                if i < len(lines) and lines[i].strip() == "```":
                    # Process the help block
                    help_output = self._get_help_text(command)
                    full_command = f"{command} --help"
                    formatted_output = f"> {full_command}\n\n{help_output}"

                    # Add opening fence and new content
                    processed_lines.append("```")
                    processed_lines.extend(formatted_output.split("\n"))

                    # Skip existing content until closing fence
                    i += 1
                    while i < len(lines) and lines[i].strip() != "```":
                        i += 1

                    # Add closing fence if found
                    if i < len(lines):
                        processed_lines.append(lines[i])
                    else:
                        processed_lines.append("```")
                else:
                    # No immediate code block, just continue
                    continue
            else:
                processed_lines.append(line)

            i += 1

        return "\n".join(processed_lines)



---
File: /src/autowt/services/__init__.py
---




---
File: /src/autowt/services/agent.py
---

"""Agent monitoring service for Claude Code integration."""

import logging
import subprocess
from pathlib import Path

from autowt.models import AgentStatus, WorktreeInfo, WorktreeWithAgent

logger = logging.getLogger(__name__)


class AgentService:
    """Service for detecting and monitoring Claude Code agents."""

    def _is_claude_process_running(self, directory: Path) -> bool:
        """Check if Claude Code process is running in directory using lsof."""
        try:
            result = subprocess.run(
                ["lsof", "+D", str(directory)],
                capture_output=True,
                text=True,
                timeout=5,
            )

            # lsof can return exit code 1 but still produce valid output
            # Check output regardless of return code if stdout is not empty
            if not result.stdout.strip():
                return False

            # Look for node processes and verify they're actually Claude
            for line in result.stdout.splitlines():
                if "node" in line.lower():
                    # Extract PID from lsof output
                    parts = line.split()
                    if len(parts) >= 2:
                        try:
                            pid = int(parts[1])
                            # Check if this PID is actually a Claude process
                            ps_result = subprocess.run(
                                ["ps", "-p", str(pid), "-o", "command="],
                                capture_output=True,
                                text=True,
                                timeout=2,
                            )
                            if (
                                ps_result.returncode == 0
                                and "claude" in ps_result.stdout.strip()
                            ):
                                return True
                        except (ValueError, subprocess.TimeoutExpired):
                            continue

            return False

        except (subprocess.TimeoutExpired, FileNotFoundError, OSError):
            # lsof unavailable or failed - can't determine process status
            return False

    def _cleanup_stale_status_file(self, status_file: Path) -> None:
        """Remove a stale status file."""
        try:
            status_file.unlink()
            logger.debug(f"Removed stale status file: {status_file}")
        except OSError:
            # File already gone or permission issue - ignore
            pass

    def detect_agent_status(self, worktree_path: Path) -> AgentStatus | None:
        """Detect Claude Code agent status in a worktree."""
        status_file = worktree_path / ".claude" / "autowt" / "status"
        agent_status = AgentStatus.from_file(status_file)

        if not agent_status:
            return None

        # Verify Claude is actually running
        if self._is_claude_process_running(worktree_path):
            return agent_status

        # Status file exists but no Claude process - clean up stale file
        self._cleanup_stale_status_file(status_file)
        return None

    def enhance_worktrees_with_agent_status(
        self, worktrees: list[WorktreeInfo], state_service, repo_path: Path
    ) -> list[WorktreeWithAgent]:
        """Add agent status to worktree information."""
        enhanced = []

        for worktree in worktrees:
            agent_status = self.detect_agent_status(worktree.path)
            session_id = state_service.get_session_id(repo_path, worktree.branch)
            has_session = session_id is not None

            enhanced.append(
                WorktreeWithAgent(
                    branch=worktree.branch,
                    path=worktree.path,
                    is_current=worktree.is_current,
                    is_primary=worktree.is_primary,
                    agent_status=agent_status,
                    has_active_session=has_session,
                )
            )

        return enhanced

    def find_waiting_agents(
        self, enhanced_worktrees: list[WorktreeWithAgent]
    ) -> list[WorktreeWithAgent]:
        """Find worktrees with agents waiting for input."""
        waiting = []
        for wt in enhanced_worktrees:
            if wt.agent_status and wt.agent_status.status == "waiting":
                waiting.append(wt)

        # Sort by last activity (oldest first)
        return sorted(waiting, key=lambda w: w.agent_status.last_activity)

    def find_latest_active_agent(
        self, enhanced_worktrees: list[WorktreeWithAgent]
    ) -> WorktreeWithAgent | None:
        """Find the most recently active agent."""
        active_agents = [
            wt
            for wt in enhanced_worktrees
            if wt.agent_status
            and wt.agent_status.status in ["working", "idle", "waiting"]
        ]

        if not active_agents:
            return None

        # Sort by last activity (newest first)
        return sorted(
            active_agents, key=lambda w: w.agent_status.last_activity, reverse=True
        )[0]



---
File: /src/autowt/services/git.py
---

"""Git operations service for autowt."""

import logging
from pathlib import Path

from autowt.models import BranchStatus, WorktreeInfo
from autowt.prompts import confirm_default_no
from autowt.utils import run_command, run_command_quiet_on_failure, run_command_visible

logger = logging.getLogger(__name__)


class GitService:
    """Handles all git operations for worktree management."""

    def __init__(self):
        """Initialize git service."""
        logger.debug("Git service initialized")

    def find_repo_root(self, start_path: Path | None = None) -> Path | None:
        """Find the root of the git repository."""
        if start_path is None:
            start_path = Path.cwd()

        current = start_path.resolve()
        while current != current.parent:
            if (current / ".git").exists():
                logger.debug(f"Found repo root: {current}")
                return current
            current = current.parent

        logger.debug("No git repository found")
        return None

    def is_git_repo(self, path: Path) -> bool:
        """Check if the given path is a git repository."""
        try:
            result = run_command(
                ["git", "rev-parse", "--git-dir"],
                cwd=path,
                timeout=10,
                description="Check if directory is git repo",
            )
            is_repo = result.returncode == 0
            logger.debug(f"Path {path} is git repo: {is_repo}")
            return is_repo
        except Exception as e:
            logger.debug(f"Error checking if {path} is git repo: {e}")
            return False

    def get_current_branch(self, repo_path: Path) -> str | None:
        """Get the current branch name."""
        try:
            result = run_command(
                ["git", "branch", "--show-current"],
                cwd=repo_path,
                timeout=10,
                description="Get current branch",
            )
            if result.returncode == 0:
                branch = result.stdout.strip()
                logger.debug(f"Current branch: {branch}")
                return branch
        except Exception as e:
            logger.error(f"Failed to get current branch: {e}")

        return None

    def list_worktrees(self, repo_path: Path) -> list[WorktreeInfo]:
        """List all git worktrees."""
        try:
            result = run_command(
                ["git", "worktree", "list", "--porcelain"],
                cwd=repo_path,
                timeout=30,
                description="List git worktrees",
            )

            if result.returncode != 0:
                logger.error(f"Git worktree list failed: {result.stderr}")
                return []

            worktrees = []
            current_worktree = None
            current_path = None
            current_branch = None
            is_first_worktree = True

            for line in result.stdout.strip().split("\n"):
                if not line:
                    # End of worktree entry
                    if current_path and current_branch:
                        worktrees.append(
                            WorktreeInfo(
                                branch=current_branch,
                                path=Path(current_path),
                                is_current=current_worktree is not None,
                                is_primary=is_first_worktree,
                            )
                        )
                    current_worktree = None
                    current_path = None
                    current_branch = None
                    is_first_worktree = False
                elif line.startswith("worktree "):
                    current_path = line[9:]  # Remove 'worktree ' prefix
                elif line.startswith("branch refs/heads/"):
                    current_branch = line[18:]  # Remove 'branch refs/heads/' prefix
                elif line.startswith("HEAD "):
                    # This is just the commit hash, ignore for branch name
                    continue
                elif line == "bare":
                    # Skip bare repositories
                    continue
                elif line == "detached":
                    # Skip detached HEAD
                    continue

            # Handle last entry
            if current_path and current_branch:
                worktrees.append(
                    WorktreeInfo(
                        branch=current_branch,
                        path=Path(current_path),
                        is_current=current_worktree is not None,
                        is_primary=is_first_worktree,
                    )
                )

            logger.debug(f"Found {len(worktrees)} worktrees")
            return worktrees

        except Exception as e:
            logger.error(f"Failed to list worktrees: {e}")
            return []

    def fetch_branches(self, repo_path: Path) -> bool:
        """Fetch latest branches from remote."""
        logger.debug("Fetching branches from remote")
        try:
            result = run_command_visible(
                ["git", "fetch", "--prune"],
                cwd=repo_path,
                timeout=60,
            )

            success = result.returncode == 0
            if success:
                logger.debug("Fetch completed successfully")
            else:
                logger.error(f"Fetch failed: {result.stderr}")

            return success

        except Exception as e:
            logger.error(f"Failed to fetch branches: {e}")
            return False

    def create_worktree(
        self, repo_path: Path, branch: str, worktree_path: Path
    ) -> bool:
        """Create a new worktree for the given branch."""
        logger.debug(f"Creating worktree for {branch} at {worktree_path}")

        try:
            # Check if branch exists locally
            result = run_command_quiet_on_failure(
                ["git", "show-ref", "--verify", f"refs/heads/{branch}"],
                cwd=repo_path,
                timeout=10,
                description=f"Check if branch {branch} exists locally",
            )

            if result.returncode == 0:
                # Branch exists locally
                cmd = ["git", "worktree", "add", str(worktree_path), branch]
            else:
                # Check if remote branch exists
                result = run_command_quiet_on_failure(
                    ["git", "show-ref", "--verify", f"refs/remotes/origin/{branch}"],
                    cwd=repo_path,
                    timeout=10,
                    description=f"Check if remote branch origin/{branch} exists",
                )

                if result.returncode == 0:
                    # Remote branch exists, create from it
                    cmd = [
                        "git",
                        "worktree",
                        "add",
                        str(worktree_path),
                        "-b",
                        branch,
                        f"origin/{branch}",
                    ]
                else:
                    # Neither local nor remote exists, create new branch from main branch
                    default_branch = self._get_default_branch(repo_path)
                    cmd = [
                        "git",
                        "worktree",
                        "add",
                        str(worktree_path),
                        "-b",
                        branch,
                        f"origin/{default_branch}",
                    ]
            result = run_command_visible(cmd, cwd=repo_path, timeout=30)

            success = result.returncode == 0
            if success:
                logger.debug(f"Worktree created successfully at {worktree_path}")
            else:
                logger.error(f"Failed to create worktree: {result.stderr}")

            return success

        except Exception as e:
            logger.error(f"Failed to create worktree: {e}")
            return False

    def remove_worktree(
        self,
        repo_path: Path,
        worktree_path: Path,
        force: bool = False,
        interactive: bool = True,
    ) -> bool:
        """Remove a worktree."""
        logger.debug(f"Removing worktree at {worktree_path}")

        try:
            cmd = ["git", "worktree", "remove"]
            if force:
                cmd.append("--force")
            cmd.append(str(worktree_path))

            result = run_command_visible(cmd, cwd=repo_path, timeout=30)

            success = result.returncode == 0
            if success:
                logger.debug("Worktree removed successfully")
                return True

            # If removal failed and we haven't tried force yet
            if (
                not force
                and interactive
                and result.stderr
                and "modified or untracked files" in result.stderr
            ):
                logger.error(f"Failed to remove worktree: {result.stderr}")
                print(f"Git error: {result.stderr.strip()}")

                if confirm_default_no(
                    "Retry with --force to remove worktree with modified files?"
                ):
                    return self.remove_worktree(
                        repo_path, worktree_path, force=True, interactive=False
                    )
            else:
                logger.error(f"Failed to remove worktree: {result.stderr}")

            return False

        except Exception as e:
            logger.error(f"Failed to remove worktree: {e}")
            return False

    def analyze_branches_for_cleanup(
        self, repo_path: Path, worktrees: list[WorktreeInfo]
    ) -> list[BranchStatus]:
        """Analyze branches to determine cleanup candidates."""
        logger.debug("Analyzing branches for cleanup")

        # Get default branch once and cache it - use remote tracking branch for comparison
        default_branch = self._get_default_branch(repo_path)
        if not default_branch:
            logger.warning(
                "Could not determine default branch, skipping merge analysis"
            )
        else:
            # Use remote tracking branch for comparison after fetch
            default_branch = f"origin/{default_branch}"

        branch_statuses = []

        for worktree in worktrees:
            branch = worktree.branch

            # Check if branch has remote
            has_remote = self._branch_has_remote(repo_path, branch)

            # Check if branch is identical to default branch
            is_identical = self._branches_are_identical_cached(
                repo_path, branch, default_branch
            )

            # Check if branch is merged (only if it had unique commits)
            is_merged = self._branch_is_merged_cached(repo_path, branch, default_branch)

            # Check for uncommitted changes
            has_uncommitted = self.has_uncommitted_changes(worktree.path)

            branch_statuses.append(
                BranchStatus(
                    branch=branch,
                    has_remote=has_remote,
                    is_merged=is_merged,
                    is_identical=is_identical,
                    path=worktree.path,
                    has_uncommitted_changes=has_uncommitted,
                )
            )

        logger.debug(f"Analyzed {len(branch_statuses)} branches")
        return branch_statuses

    def _get_default_branch(self, repo_path: Path) -> str | None:
        """Get the default branch name (main, master, etc.)."""
        try:
            # Try to get the default branch from origin (this often fails, that's expected)
            result = run_command_quiet_on_failure(
                ["git", "symbolic-ref", "refs/remotes/origin/HEAD"],
                cwd=repo_path,
                timeout=10,
                description="Get default branch from origin",
            )
            if result.returncode == 0:
                # Extract branch name from refs/remotes/origin/main
                branch_ref = result.stdout.strip()
                if branch_ref.startswith("refs/remotes/origin/"):
                    return branch_ref[len("refs/remotes/origin/") :]

            # Fall back to checking common default branches
            for branch in ["main", "master"]:
                result = run_command_quiet_on_failure(
                    ["git", "show-ref", "--verify", f"refs/heads/{branch}"],
                    cwd=repo_path,
                    timeout=10,
                    description=f"Check if {branch} exists",
                )
                if result.returncode == 0:
                    return branch

            # If neither main nor master exist, try to get current branch as fallback
            result = run_command(
                ["git", "branch", "--show-current"],
                cwd=repo_path,
                timeout=10,
                description="Get current branch as fallback",
            )
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip()

            return None
        except Exception:
            return None

    def _branch_has_remote(self, repo_path: Path, branch: str) -> bool:
        """Check if branch has a remote tracking branch."""
        try:
            result = run_command(
                ["git", "config", f"branch.{branch}.remote"],
                cwd=repo_path,
                timeout=10,
                description=f"Check if branch {branch} has remote",
            )
            return result.returncode == 0
        except Exception:
            return False

    def _branches_are_identical_cached(
        self, repo_path: Path, branch: str, default_branch: str | None
    ) -> bool:
        """Check if branch points to the same commit as default branch (with cached default branch)."""
        try:
            if not default_branch:
                return False

            # Get commit hashes for both branches
            branch_result = run_command(
                ["git", "rev-parse", branch],
                cwd=repo_path,
                timeout=10,
                description=f"Get commit hash for {branch}",
            )
            base_result = run_command(
                ["git", "rev-parse", default_branch],
                cwd=repo_path,
                timeout=10,
                description=f"Get commit hash for {default_branch}",
            )

            if branch_result.returncode == 0 and base_result.returncode == 0:
                # Branches are identical if they point to the same commit
                return branch_result.stdout.strip() == base_result.stdout.strip()

            return False
        except Exception:
            return False

    def _branch_is_merged_cached(
        self, repo_path: Path, branch: str, default_branch: str | None
    ) -> bool:
        """Check if branch is merged into default branch (but not identical) with cached default branch."""
        try:
            if not default_branch:
                return False

            # Don't consider identical branches as "merged"
            if self._branches_are_identical_cached(repo_path, branch, default_branch):
                return False

            # Check if branch is ancestor (was merged)
            result = run_command(
                ["git", "merge-base", "--is-ancestor", branch, default_branch],
                cwd=repo_path,
                timeout=10,
                description=f"Check if {branch} is merged into {default_branch}",
            )
            return result.returncode == 0

        except Exception:
            return False

    def has_uncommitted_changes(self, worktree_path: Path) -> bool:
        """Check if a worktree has uncommitted changes (staged or unstaged)."""
        try:
            # Check for staged and unstaged changes
            result = run_command(
                ["git", "status", "--porcelain"],
                cwd=worktree_path,
                timeout=10,
                description=f"Check uncommitted changes in {worktree_path}",
            )

            # If status command succeeds and has output, there are uncommitted changes
            if result.returncode == 0:
                has_changes = bool(result.stdout.strip())
                logger.debug(
                    f"Worktree {worktree_path} has uncommitted changes: {has_changes}"
                )
                return has_changes

            logger.debug(f"Failed to check status in {worktree_path}")
            return False

        except Exception as e:
            logger.debug(f"Error checking uncommitted changes in {worktree_path}: {e}")
            return False

    def delete_branch(self, repo_path: Path, branch: str, force: bool = False) -> bool:
        """Delete a local branch."""
        try:
            flag = "-D" if force else "-d"
            result = run_command(
                ["git", "branch", flag, branch],
                cwd=repo_path,
                timeout=10,
                description=f"Delete branch {branch}",
            )
            return result.returncode == 0
        except Exception:
            return False



---
File: /src/autowt/services/hooks.py
---

"""Hook detection and management utilities."""

import json
import logging
import shutil
import subprocess
from pathlib import Path

import click

from autowt.commands.hooks import install_hooks_command
from autowt.console import print_info
from autowt.models import Services

logger = logging.getLogger(__name__)


def has_autowt_hooks_installed() -> bool:
    """Check if autowt hooks are installed at user or project level."""
    user_settings_path = Path.home() / ".claude" / "settings.json"
    project_settings_path = Path.cwd() / ".claude" / "settings.json"
    project_local_settings_path = Path.cwd() / ".claude" / "settings.local.json"

    settings_paths = [
        user_settings_path,
        project_settings_path,
        project_local_settings_path,
    ]

    for settings_path in settings_paths:
        if _has_autowt_hooks_in_file(settings_path):
            logger.debug(f"Found autowt hooks in {settings_path}")
            return True

    logger.debug("No autowt hooks found in any settings file")
    return False


def _has_autowt_hooks_in_file(settings_path: Path) -> bool:
    """Check if a specific settings file contains autowt hooks."""
    if not settings_path.exists():
        return False

    try:
        with open(settings_path) as f:
            settings = json.load(f)

        autowt_hooks = _extract_autowt_hooks(settings)
        return len(autowt_hooks) > 0

    except (json.JSONDecodeError, Exception) as e:
        logger.debug(f"Error reading {settings_path}: {e}")
        return False


def _extract_autowt_hooks(settings: dict) -> dict:
    """Extract autowt hooks from settings, grouped by hook type."""
    autowt_hooks = {}

    if "hooks" not in settings:
        return autowt_hooks

    for hook_type, hooks in settings["hooks"].items():
        autowt_hooks_for_type = [
            hook
            for hook in hooks
            if hook.get("autowt_hook_id", "").startswith("agent_status_")
        ]
        if autowt_hooks_for_type:
            autowt_hooks[hook_type] = autowt_hooks_for_type

    return autowt_hooks


def _is_claude_cli_available() -> bool:
    """Check if Claude CLI is available in PATH or at common installation locations."""
    # First try direct executable lookup
    if shutil.which("claude") is not None:
        return True

    # Check common Claude CLI installation locations
    common_locations = [
        Path.home() / ".claude" / "local" / "claude",
        Path.home() / ".local" / "bin" / "claude",
        Path("/usr/local/bin/claude"),
        Path("/opt/homebrew/bin/claude"),
    ]

    for claude_path in common_locations:
        if claude_path.exists() and claude_path.is_file():
            try:
                # Test if the file is executable
                result = subprocess.run(
                    [str(claude_path), "--version"],
                    capture_output=True,
                    text=True,
                    timeout=5,
                )
                logger.debug(
                    f"Found claude at {claude_path}, version test: returncode={result.returncode}"
                )
                # If it runs without error (even if it shows usage), Claude CLI is available
                return result.returncode in [
                    0,
                    1,
                    2,
                ]  # 0=success, 1/2=usage error is fine
            except (
                subprocess.TimeoutExpired,
                subprocess.SubprocessError,
                PermissionError,
            ):
                continue

    logger.debug("Claude CLI not found in PATH or common locations")
    return False


def check_and_prompt_hooks_installation(services: Services) -> None:
    """Check if we should prompt for hooks installation and show prompt if needed."""
    logger.debug("check_and_prompt_hooks_installation() called")

    # Only check in git repositories
    repo_path = services.git.find_repo_root()
    if not repo_path:
        logger.debug("Not in git repository, skipping hooks prompt")
        return

    # Only offer hooks if Claude CLI is available
    if not _is_claude_cli_available():
        logger.debug("Claude CLI not found in PATH, skipping hooks prompt")
        return

    # Don't prompt if we've already asked
    if services.state.has_shown_hooks_prompt():
        logger.debug("Already shown hooks prompt, skipping")
        return

    # Don't prompt if hooks are already installed
    if has_autowt_hooks_installed():
        logger.debug("Hooks already installed, skipping prompt")
        return

    # Show the first-run hooks prompt
    _show_hooks_prompt(services)


def _show_hooks_prompt(services: Services) -> None:
    """Show the first-run hooks installation prompt."""

    # Show Y/n prompt with Y as default
    if click.confirm(
        "Would you like to install Claude Code hooks for enhanced monitoring?\nYou'll be able to choose how and confirm before changes are made.",
        default=True,
    ):
        # Launch the interactive hooks installation TUI
        click.echo("\nLaunching hooks installation...")
        try:
            install_hooks_command(level=None, services=services, dry_run=False)
        except Exception as e:
            click.echo(f"Error during installation: {e}")
            _show_manual_instructions()
    else:
        # User declined - show manual instructions
        _show_manual_instructions()

    # Mark that we've shown the prompt regardless of user choice
    services.state.mark_hooks_prompt_shown()


def _show_manual_instructions() -> None:
    """Show instructions for manual hook installation."""
    click.echo("")
    print_info("To install hooks later, run:")
    click.echo("  autowt hooks-install")
    click.echo("")
    click.echo("For more information about agent monitoring, see:")
    click.echo("  https://github.com/sswam/autowt/blob/main/docs/agents.md")
    click.echo("")



---
File: /src/autowt/services/process.py
---

"""Process management service for autowt."""

import logging
import platform
import time
from pathlib import Path

from autowt.console import print_output, print_plain, print_success
from autowt.models import ProcessInfo
from autowt.utils import run_command, run_command_visible

logger = logging.getLogger(__name__)


class ProcessService:
    """Handles process discovery and termination for cleanup operations."""

    def __init__(self):
        """Initialize process service."""
        logger.debug("Process service initialized")

    def find_processes_in_directory(self, directory: Path) -> list[ProcessInfo]:
        """Find all processes running in the specified directory."""
        logger.debug(f"Finding processes in directory: {directory}")

        if platform.system() == "Windows":
            logger.info("Windows process discovery not yet supported - skipping")
            return []

        processes = []

        try:
            # Use lsof to find processes with open files in the directory
            result = run_command(
                ["lsof", "+D", str(directory)],
                timeout=30,
                description=f"Find processes in directory {directory}",
            )

            # lsof can return 1 even when it finds results, so check output content
            if result.returncode != 0 and not result.stdout.strip():
                logger.debug("No processes found in directory (no output)")
                return processes
            elif result.returncode not in [0, 1]:
                logger.warning(
                    f"lsof command failed with exit code {result.returncode}: {result.stderr}"
                )
                return processes

            # Parse lsof output
            lines = result.stdout.strip().split("\n")
            if len(lines) < 2:  # Header line + at least one process
                return processes

            # Skip header line
            for line in lines[1:]:
                try:
                    parts = line.split()
                    if len(parts) >= 2:
                        command = parts[0]
                        pid = int(parts[1])

                        # Get more detailed process info
                        process_info = self._get_process_details(
                            pid, command, directory
                        )
                        if process_info:
                            processes.append(process_info)

                except (ValueError, IndexError) as e:
                    logger.debug(f"Failed to parse lsof line: {line}, error: {e}")
                    continue

            logger.debug(f"Found {len(processes)} processes in directory")

        except Exception as e:
            logger.error(f"Failed to find processes: {e}")

        return processes

    def _get_process_details(
        self, pid: int, command: str, working_dir: Path
    ) -> ProcessInfo:
        """Get detailed information about a process."""
        try:
            # Get the full command line
            result = run_command(
                ["ps", "-p", str(pid), "-o", "command="],
                timeout=10,
                description=f"Get command details for PID {pid}",
            )

            if result.returncode == 0:
                full_command = result.stdout.strip()
            else:
                full_command = command

            return ProcessInfo(
                pid=pid,
                command=full_command,
                working_dir=working_dir,
            )

        except Exception as e:
            logger.debug(f"Failed to get process details for PID {pid}: {e}")
            return ProcessInfo(
                pid=pid,
                command=command,
                working_dir=working_dir,
            )

    def terminate_processes(self, processes: list[ProcessInfo]) -> bool:
        """Terminate the given processes with SIGINT then SIGKILL if needed."""
        if not processes:
            logger.debug("No processes to terminate")
            return True

        if platform.system() == "Windows":
            logger.info("Windows process termination not yet supported - skipping")
            return True

        logger.info(f"Terminating {len(processes)} processes")

        # Send SIGINT to all processes
        for process in processes:
            # Truncate long command lines for display
            command = process.command
            if len(command) > 60:
                command = command[:57] + "..."
            print_output(f"  Sending SIGINT to {command} (PID {process.pid})")
            logger.debug(f"Sending SIGINT to PID {process.pid} ({process.command})")
            try:
                run_command_visible(
                    ["kill", "-INT", str(process.pid)],
                    timeout=5,
                )
            except Exception as e:
                logger.warning(f"Failed to send SIGINT to PID {process.pid}: {e}")

        # Poll for up to 10 seconds to see if processes exit
        logger.debug("Polling for processes to exit (max 10 seconds)")
        max_wait_time = 10
        poll_interval = 0.5
        elapsed = 0

        while elapsed < max_wait_time:
            time.sleep(poll_interval)
            elapsed += poll_interval

            # Check which processes are still running
            still_running = []
            for process in processes:
                if self._is_process_running(process.pid):
                    still_running.append(process)

            # If all processes have exited, we're done
            if not still_running:
                print_success(f"  All processes exited after {elapsed:.1f} seconds")
                logger.info("All processes terminated successfully")
                return True

        # Check which processes are still running and SIGKILL them
        still_running = []
        for process in processes:
            if self._is_process_running(process.pid):
                still_running.append(process)

        if still_running:
            print_output(
                f"  {len(still_running)} processes still running, sending SIGKILL..."
            )
            logger.info(
                f"{len(still_running)} processes still running, sending SIGKILL"
            )

            for process in still_running:
                # Truncate long command lines for display
                command = process.command
                if len(command) > 60:
                    command = command[:57] + "..."
                print_output(f"  Sending SIGKILL to {command} (PID {process.pid})")
                logger.debug(
                    f"Sending SIGKILL to PID {process.pid} ({process.command})"
                )
                try:
                    run_command_visible(
                        ["kill", "-KILL", str(process.pid)],
                        timeout=5,
                    )
                except Exception as e:
                    logger.warning(f"Failed to send SIGKILL to PID {process.pid}: {e}")

        # Give a moment for processes to die
        time.sleep(1)

        # Check if any processes are still running
        final_survivors = []
        for process in processes:
            if self._is_process_running(process.pid):
                final_survivors.append(process)

        if final_survivors:
            logger.error(f"{len(final_survivors)} processes could not be terminated:")
            for process in final_survivors:
                logger.error(f"  PID {process.pid}: {process.command}")
            return False

        logger.info("All processes terminated successfully")
        return True

    def _is_process_running(self, pid: int) -> bool:
        """Check if a process is still running."""
        if platform.system() == "Windows":
            # On Windows, we skip process discovery so we won't have PIDs to check
            return False

        try:
            result = run_command(
                ["ps", "-p", str(pid)],
                timeout=10,
                description=f"Check if PID {pid} is running",
            )
            return result.returncode == 0
        except Exception:
            return False

    def print_process_summary(self, processes: list[ProcessInfo]) -> None:
        """Print a summary of processes that will be terminated."""
        if not processes:
            print_plain("No processes found running in worktrees to be deleted.")
            return

        print_output("Shutting down processes operating in worktrees to be deleted...")
        for process in processes:
            # Truncate long command lines for display
            command = process.command
            if len(command) > 60:
                command = command[:57] + "..."

            print_output(f"  {command} {process.pid}")
        print_output("  ...done")



---
File: /src/autowt/services/state.py
---

"""State management service for autowt."""

import logging
import os
import platform
from pathlib import Path
from typing import Any

import toml

from autowt.config import Config, ConfigLoader
from autowt.models import ProjectConfig

logger = logging.getLogger(__name__)


class StateService:
    """Manages application state and configuration files."""

    def __init__(self, app_dir: Path | None = None):
        """Initialize state service with optional custom app directory."""
        if app_dir is None:
            app_dir = self._get_default_app_dir()

        self.app_dir = app_dir
        self.config_file = app_dir / "config.toml"
        self.session_file = app_dir / "sessionids.toml"
        self.state_file = app_dir / "state.toml"

        # Ensure app directory exists
        self.app_dir.mkdir(parents=True, exist_ok=True)
        logger.debug(f"State service initialized with app dir: {self.app_dir}")

    def _get_default_app_dir(self) -> Path:
        """Get the default application directory based on platform."""
        system = platform.system()
        if system == "Darwin":  # macOS
            return Path.home() / "Library" / "Application Support" / "autowt"
        elif system == "Linux":
            # Follow XDG Base Directory Specification
            xdg_data = Path(
                os.getenv("XDG_DATA_HOME", Path.home() / ".local" / "share")
            )
            return xdg_data / "autowt"
        else:
            # Windows or other
            return Path.home() / ".autowt"

    def load_config(self) -> Config:
        """Load application configuration using new config system."""
        logger.debug("Loading configuration via ConfigLoader")

        # Use the new configuration system
        config_loader = ConfigLoader(app_dir=self.app_dir)
        return config_loader.load_config()

    def load_project_config(self, cwd: Path) -> ProjectConfig:
        """Load project configuration from autowt.toml or .autowt.toml in current directory."""
        logger.debug(f"Loading project configuration from {cwd}")

        # Check for autowt.toml first, then .autowt.toml
        config_files = [cwd / "autowt.toml", cwd / ".autowt.toml"]

        for config_file in config_files:
            if config_file.exists():
                logger.debug(f"Found project config file: {config_file}")
                try:
                    data = toml.load(config_file)
                    config = ProjectConfig.from_dict(data)
                    logger.debug("Project configuration loaded successfully")
                    return config
                except Exception as e:
                    logger.error(
                        f"Failed to load project configuration from {config_file}: {e}"
                    )
                    continue

        logger.debug("No project config file found, using defaults")
        return ProjectConfig()

    def save_config(self, config: Config) -> None:
        """Save application configuration using new config system."""
        logger.debug("Saving configuration via ConfigLoader")

        # Use the new configuration system
        config_loader = ConfigLoader(app_dir=self.app_dir)
        config_loader.save_config(config)

    def load_session_ids(self) -> dict[str, str]:
        """Load session ID mappings for branches."""
        logger.debug("Loading session IDs")

        if not self.session_file.exists():
            logger.debug("No session file found")
            return {}

        try:
            data = toml.load(self.session_file)
            logger.debug(f"Loaded {len(data)} session mappings")
            return data
        except Exception as e:
            logger.error(f"Failed to load session IDs: {e}")
            return {}

    def save_session_ids(self, session_ids: dict[str, str]) -> None:
        """Save session ID mappings for branches."""
        logger.debug(f"Saving {len(session_ids)} session mappings")

        try:
            with open(self.session_file, "w") as f:
                toml.dump(session_ids, f)
            logger.debug("Session IDs saved successfully")
        except Exception as e:
            logger.error(f"Failed to save session IDs: {e}")
            raise

    def _make_session_key(self, repo_path: Path, branch_name: str) -> str:
        """Create a composite key for session storage."""
        return f"{repo_path.resolve()}:{branch_name}"

    def get_session_id(self, repo_path: Path, branch_name: str) -> str | None:
        """Get session ID for specific repo/branch combination."""
        session_ids = self.load_session_ids()
        key = self._make_session_key(repo_path, branch_name)
        return session_ids.get(key)

    def set_session_id(
        self, repo_path: Path, branch_name: str, session_id: str
    ) -> None:
        """Set session ID for specific repo/branch combination."""
        session_ids = self.load_session_ids()
        key = self._make_session_key(repo_path, branch_name)
        session_ids[key] = session_id
        self.save_session_ids(session_ids)

    def remove_session_id(self, repo_path: Path, branch_name: str) -> None:
        """Remove session ID for specific repo/branch combination."""
        session_ids = self.load_session_ids()
        key = self._make_session_key(repo_path, branch_name)
        if key in session_ids:
            session_ids.pop(key)
            self.save_session_ids(session_ids)

    def get_session_ids_for_repo(self, repo_path: Path) -> dict[str, str]:
        """Get all session IDs for a repo, with branch names as keys."""
        session_ids = self.load_session_ids()
        repo_key_prefix = f"{repo_path.resolve()}:"

        result = {}
        for key, session_id in session_ids.items():
            if key.startswith(repo_key_prefix):
                branch_name = key[len(repo_key_prefix) :]
                result[branch_name] = session_id

        return result

    def load_app_state(self) -> dict[str, Any]:
        """Load application state including UI preferences and prompt tracking."""
        logger.debug("Loading application state")

        if not self.state_file.exists():
            logger.debug("No state file found")
            return {}

        try:
            data = toml.load(self.state_file)
            logger.debug("Application state loaded successfully")
            return data
        except Exception as e:
            logger.error(f"Failed to load application state: {e}")
            return {}

    def save_app_state(self, state: dict[str, Any]) -> None:
        """Save application state including UI preferences and prompt tracking."""
        logger.debug("Saving application state")

        try:
            with open(self.state_file, "w") as f:
                toml.dump(state, f)
            logger.debug("Application state saved successfully")
        except Exception as e:
            logger.error(f"Failed to save application state: {e}")
            raise

    def has_shown_hooks_prompt(self) -> bool:
        """Check if we have already shown the hooks installation prompt."""
        state = self.load_app_state()
        return state.get("hooks_prompt_shown", False)

    def mark_hooks_prompt_shown(self) -> None:
        """Mark that we have shown the hooks installation prompt."""
        state = self.load_app_state()
        state["hooks_prompt_shown"] = True
        self.save_app_state(state)

    def has_shown_experimental_terminal_warning(self) -> bool:
        """Check if we have already shown the experimental terminal warning."""
        state = self.load_app_state()
        return state.get("experimental_terminal_warning_shown", False)

    def mark_experimental_terminal_warning_shown(self) -> None:
        """Mark that we have shown the experimental terminal warning."""
        state = self.load_app_state()
        state["experimental_terminal_warning_shown"] = True
        self.save_app_state(state)



---
File: /src/autowt/services/terminal.py
---

"""Terminal management service for autowt."""

import logging
import os
import platform
import shlex
import sys
from abc import ABC, abstractmethod
from pathlib import Path

from autowt.models import TerminalMode
from autowt.prompts import confirm_default_yes
from autowt.services.state import StateService
from autowt.utils import run_command, sanitize_branch_name

logger = logging.getLogger(__name__)


class Terminal(ABC):
    """Base class for terminal implementations."""

    def __init__(self):
        """Initialize terminal implementation."""
        self.is_macos = platform.system() == "Darwin"

    @abstractmethod
    def get_current_session_id(self) -> str | None:
        """Get current session ID if supported."""
        pass

    @abstractmethod
    def switch_to_session(
        self, session_id: str, init_script: str | None = None
    ) -> bool:
        """Switch to existing session if supported."""
        pass

    @abstractmethod
    def open_new_tab(self, worktree_path: Path, init_script: str | None = None) -> bool:
        """Open new tab in current window."""
        pass

    @abstractmethod
    def open_new_window(
        self, worktree_path: Path, init_script: str | None = None
    ) -> bool:
        """Open new window."""
        pass

    def supports_session_management(self) -> bool:
        """Whether this terminal supports session management."""
        return False

    def session_exists(self, session_id: str) -> bool:
        """Check if a session exists in the terminal."""
        return False

    def session_in_directory(self, session_id: str, directory: Path) -> bool:
        """Check if a session exists and is currently in the specified directory."""
        return False

    def _escape_for_applescript(self, text: str) -> str:
        """Escape text for use in AppleScript strings."""
        return text.replace("\\", "\\\\").replace('"', '\\"')

    def _escape_path_for_command(self, path: Path) -> str:
        """Escape a path for use inside AppleScript command strings."""
        return str(path).replace("\\", "\\\\").replace('"', '\\"')

    def _run_applescript(self, script: str) -> bool:
        """Execute AppleScript and return success status."""
        if not self.is_macos:
            logger.warning("AppleScript not available on this platform")
            return False

        try:
            result = run_command(
                ["osascript", "-e", script],
                timeout=30,
                description="Execute AppleScript for terminal switching",
            )

            success = result.returncode == 0
            if success:
                logger.debug("AppleScript executed successfully")
            else:
                logger.error(f"AppleScript failed: {result.stderr}")

            return success

        except Exception as e:
            logger.error(f"Failed to run AppleScript: {e}")
            return False

    def _run_applescript_with_result(self, script: str) -> str | None:
        """Execute AppleScript and return the output string."""
        if not self.is_macos:
            logger.warning("AppleScript not available on this platform")
            return None

        try:
            result = run_command(
                ["osascript", "-e", script],
                timeout=30,
                description="Execute AppleScript for terminal switching",
            )

            if result.returncode != 0:
                logger.error(f"AppleScript failed: {result.stderr}")
                return None

            return result.stdout.strip()

        except Exception as e:
            logger.error(f"Failed to run AppleScript: {e}")
            return None


class ITerm2Terminal(Terminal):
    """iTerm2 terminal implementation."""

    def get_current_session_id(self) -> str | None:
        """Get current iTerm2 session ID."""
        session_id = os.getenv("ITERM_SESSION_ID")
        logger.debug(f"Current iTerm2 session ID: {session_id}")
        return session_id

    def supports_session_management(self) -> bool:
        """iTerm2 supports session management."""
        return True

    def session_exists(self, session_id: str) -> bool:
        """Check if a session exists in iTerm2."""
        if not session_id:
            return False

        # Extract UUID part from session ID (format: w0t0p2:UUID)
        session_uuid = session_id.split(":")[-1] if ":" in session_id else session_id
        logger.debug(f"Checking if session exists: {session_uuid}")

        applescript = f'''
        tell application "iTerm2"
            repeat with theWindow in windows
                repeat with theTab in tabs of theWindow
                    repeat with theSession in sessions of theTab
                        if id of theSession is "{session_uuid}" then
                            return true
                        end if
                    end repeat
                end repeat
            end repeat
            return false
        end tell
        '''

        result = self._run_applescript_with_result(applescript)
        return result == "true" if result else False

    def session_in_directory(self, session_id: str, directory: Path) -> bool:
        """Check if iTerm2 session exists and is in the specified directory."""
        if not session_id:
            return False

        # Extract UUID part from session ID (format: w0t0p2:UUID)
        session_uuid = session_id.split(":")[-1] if ":" in session_id else session_id
        logger.debug(f"Checking if session {session_uuid} is in directory {directory}")

        applescript = f'''
        tell application "iTerm2"
            repeat with theWindow in windows
                repeat with theTab in tabs of theWindow
                    repeat with theSession in sessions of theTab
                        if id of theSession is "{session_uuid}" then
                            set currentDirectory to get variable named "PWD" of theSession
                            if currentDirectory starts with "{self._escape_for_applescript(str(directory))}" then
                                return true
                            else
                                return false
                            end if
                        end if
                    end repeat
                end repeat
            end repeat
            return false
        end tell
        '''

        result = self._run_applescript_with_result(applescript)
        return result == "true" if result else False

    def switch_to_session(
        self, session_id: str, init_script: str | None = None
    ) -> bool:
        """Switch to an existing iTerm2 session."""
        logger.debug(f"Switching to iTerm2 session: {session_id}")

        # Extract UUID part from session ID (format: w0t0p2:UUID)
        session_uuid = session_id.split(":")[-1] if ":" in session_id else session_id
        logger.debug(f"Using session UUID: {session_uuid}")

        applescript = f'''
        tell application "iTerm2"
            repeat with theWindow in windows
                repeat with theTab in tabs of theWindow
                    repeat with theSession in sessions of theTab
                        if id of theSession is "{session_uuid}" then
                            select theTab
                            select theWindow'''

        if init_script:
            applescript += f'''
                            tell theSession
                                write text "{self._escape_for_applescript(init_script)}"
                            end tell'''

        applescript += """
                            return
                        end if
                    end repeat
                end repeat
            end repeat
        end tell
        """

        return self._run_applescript(applescript)

    def open_new_tab(self, worktree_path: Path, init_script: str | None = None) -> bool:
        """Open a new iTerm2 tab."""
        logger.debug(f"Opening new iTerm2 tab for {worktree_path}")

        # Get the path to the current autowt executable
        autowt_path = sys.argv[0]
        if not autowt_path.startswith("/"):
            # If relative path, make it absolute
            autowt_path = os.path.abspath(autowt_path)

        # Escape the autowt_path for shell execution
        escaped_autowt_path = shlex.quote(autowt_path)

        commands = [f"cd {self._escape_path_for_command(worktree_path)}"]

        # Add session registration command (uses current working directory)
        commands.append(f"{escaped_autowt_path} register-session-for-path")

        if init_script:
            commands.append(init_script)

        applescript = f"""
        tell application "iTerm2"
            tell current window
                create tab with default profile
                tell current session of current tab
                    write text "{"; ".join(commands)}"
                end tell
            end tell
        end tell
        """

        return self._run_applescript(applescript)

    def open_new_window(
        self, worktree_path: Path, init_script: str | None = None
    ) -> bool:
        """Open a new iTerm2 window."""
        logger.debug(f"Opening new iTerm2 window for {worktree_path}")

        commands = [f"cd {self._escape_path_for_command(worktree_path)}"]
        if init_script:
            commands.append(init_script)

        applescript = f"""
        tell application "iTerm2"
            create window with default profile
            tell current session of current window
                write text "{"; ".join(commands)}"
            end tell
        end tell
        """

        return self._run_applescript(applescript)

    def _run_applescript_for_output(self, script: str) -> str | None:
        """Execute AppleScript and return the output string."""
        if not self.is_macos:
            logger.warning("AppleScript not available on this platform")
            return None

        try:
            result = run_command(
                ["osascript", "-e", script],
                timeout=30,
                description="Execute AppleScript for output",
            )

            if result.returncode != 0:
                logger.error(f"AppleScript failed: {result.stderr}")
                return None

            return result.stdout.strip()

        except Exception as e:
            logger.error(f"Failed to run AppleScript: {e}")
            return None

    def list_sessions_with_directories(self) -> list[dict[str, str]]:
        """List all iTerm2 sessions with their working directories."""
        applescript = """
        tell application "iTerm2"
            set sessionData to ""
            repeat with theWindow in windows
                repeat with theTab in tabs of theWindow
                    repeat with theSession in sessions of theTab
                        try
                            set sessionId to id of theSession
                            set sessionPath to (variable named "session.path") of theSession
                            if sessionData is not "" then
                                set sessionData to sessionData & return
                            end if
                            set sessionData to sessionData & sessionId & "|" & sessionPath
                        on error
                            if sessionData is not "" then
                                set sessionData to sessionData & return
                            end if
                            set sessionData to sessionData & sessionId & "|unknown"
                        end try
                    end repeat
                end repeat
            end repeat
            return sessionData
        end tell
        """

        output = self._run_applescript_for_output(applescript)
        if not output:
            return []

        sessions = []
        # Output format: "session1|/path1\nsession2|/path2\n..."
        for line in output.split("\n"):
            line = line.strip()
            if line and "|" in line:
                session_id, path = line.split("|", 1)
                sessions.append(
                    {
                        "session_id": session_id.strip(),
                        "working_directory": path.strip(),
                    }
                )

        return sessions

    def find_session_by_working_directory(self, target_path: str) -> str | None:
        """Find a session ID that matches the given working directory or is within it."""
        sessions = self.list_sessions_with_directories()
        target_path = str(Path(target_path).resolve())  # Normalize path

        for session in sessions:
            session_path = str(Path(session["working_directory"]).resolve())
            # Check if the session is in the target directory or any subdirectory
            if session_path.startswith(target_path):
                return session["session_id"]

        return None

    def execute_in_current_session(self, command: str) -> bool:
        """Execute a command in the current iTerm2 session."""
        logger.debug(f"Executing command in current iTerm2 session: {command}")

        applescript = f'''
        tell application "iTerm2"
            tell current session of current window
                write text "{self._escape_for_applescript(command)}"
            end tell
        end tell
        '''

        return self._run_applescript(applescript)


class TerminalAppTerminal(Terminal):
    """Terminal.app implementation."""

    def get_current_session_id(self) -> str | None:
        """Get Terminal.app working directory as session identifier."""
        try:
            applescript = """
            tell application "Terminal"
                set tabTTY to tty of selected tab of front window
                return tabTTY
            end tell
            """

            result = run_command(
                ["osascript", "-e", applescript],
                timeout=5,
                description="Get Terminal.app current tab TTY",
            )

            if result.returncode == 0 and result.stdout.strip():
                tty = result.stdout.strip()
                # Get working directory from shell process
                working_dir = self._get_working_directory_from_tty(tty)
                return working_dir

            return None

        except Exception:
            return None

    def supports_session_management(self) -> bool:
        """Terminal.app supports session management via working directory detection."""
        return True

    def session_exists(self, session_id: str) -> bool:
        """Check if a session exists in Terminal.app by working directory."""
        if not session_id:
            return False

        applescript = f'''
        tell application "Terminal"
            repeat with theWindow in windows
                repeat with theTab in tabs of theWindow
                    try
                        set tabTTY to tty of theTab
                        set applescriptShellCmd to "lsof " & tabTTY & " | grep -E '(zsh|bash|sh)' | head -1 | awk '{{print $2}}'"
                        set shellPid to do shell script applescriptShellCmd
                        if shellPid is not "" then
                            set cwdCmd to "lsof -p " & shellPid & " | grep cwd | awk '{{print $9}}'"
                            set workingDir to do shell script cwdCmd
                            if workingDir is "{self._escape_for_applescript(session_id)}" then
                                return true
                            end if
                        end if
                    end try
                end repeat
            end repeat
            return false
        end tell
        '''

        result = self._run_applescript_with_result(applescript)
        return result == "true" if result else False

    def _get_working_directory_from_tty(self, tty: str) -> str | None:
        """Get working directory of shell process using the given TTY."""
        try:
            # Find shell process for this TTY
            shell_cmd = f"lsof {shlex.quote(tty)} | grep -E '(zsh|bash|sh)' | head -1 | awk '{{print $2}}'"
            shell_result = run_command(
                ["bash", "-c", shell_cmd],
                timeout=5,
                description=f"Find shell process for TTY {tty}",
            )

            if shell_result.returncode != 0 or not shell_result.stdout.strip():
                return None

            pid = shell_result.stdout.strip()

            # Get working directory of that process
            cwd_cmd = f"lsof -p {shlex.quote(pid)} | grep cwd | awk '{{print $9}}'"
            cwd_result = run_command(
                ["bash", "-c", cwd_cmd],
                timeout=5,
                description=f"Get working directory for PID {pid}",
            )

            if cwd_result.returncode == 0 and cwd_result.stdout.strip():
                return cwd_result.stdout.strip()

            return None

        except Exception as e:
            logger.debug(f"Failed to get working directory from TTY {tty}: {e}")
            return None

    def switch_to_session(
        self, session_id: str, init_script: str | None = None
    ) -> bool:
        """Switch to existing Terminal.app session by working directory."""
        # Find the window title that contains our target directory
        find_window_script = f'''
        tell application "Terminal"
            repeat with theWindow in windows
                repeat with theTab in tabs of theWindow
                    try
                        set tabTTY to tty of theTab
                        set shellCmd to "lsof " & tabTTY & " | grep -E '(zsh|bash|sh)' | head -1 | awk '{{print $2}}'"
                        set shellPid to do shell script shellCmd
                        if shellPid is not "" then
                            set cwdCmd to "lsof -p " & shellPid & " | grep cwd | awk '{{print $9}}'"
                            set workingDir to do shell script cwdCmd
                            if workingDir is "{self._escape_for_applescript(session_id)}" then
                                -- Return the window name for menu matching
                                return name of theWindow
                            end if
                        end if
                    end try
                end repeat
            end repeat
            return ""
        end tell
        '''

        window_name = self._run_applescript_with_result(find_window_script)
        if not window_name:
            return False

        # Use System Events to click the exact menu item
        switch_script = f'''
        tell application "System Events"
            tell process "Terminal"
                try
                    -- Click the menu item with the exact window name
                    click menu item "{self._escape_for_applescript(window_name)}" of menu "Window" of menu bar 1
                    return "success"
                on error errMsg
                    -- Try with localized menu name
                    try
                        click menu item "{self._escape_for_applescript(window_name)}" of menu "窗口" of menu bar 1
                        return "success"
                    on error
                        return "error: " & errMsg
                    end try
                end try
            end tell
        end tell
        '''

        # Run init script if provided
        if init_script:
            init_result = self._run_applescript(f'''
            tell application "Terminal"
                do script "{self._escape_for_applescript(init_script)}" in front window
            end tell
            ''')
            if not init_result:
                logger.warning("Failed to run init script")

        switch_result = self._run_applescript_with_result(switch_script)
        return switch_result and switch_result.startswith("success")

    def session_in_directory(self, session_id: str, directory: Path) -> bool:
        """Check if Terminal.app session exists and is in the specified directory or subdirectory."""

        applescript = f'''
        tell application "Terminal"
            repeat with theWindow in windows
                repeat with theTab in tabs of theWindow
                    try
                        set tabTTY to tty of theTab
                        set applescriptShellCmd to "lsof " & tabTTY & " | grep -E '(zsh|bash|sh)' | head -1 | awk '{{print $2}}'"
                        set shellPid to do shell script applescriptShellCmd
                        if shellPid is not "" then
                            set cwdCmd to "lsof -p " & shellPid & " | grep cwd | awk '{{print $9}}'"
                            set workingDir to do shell script cwdCmd
                            if workingDir starts with "{self._escape_for_applescript(str(directory))}" then
                                return true
                            end if
                        end if
                    end try
                end repeat
            end repeat
            return false
        end tell
        '''

        result = self._run_applescript_with_result(applescript)
        return result == "true" if result else False

    def open_new_tab(self, worktree_path: Path, init_script: str | None = None) -> bool:
        """Open a new Terminal.app tab.

        Terminal.app requires System Events (accessibility permissions) to create
        actual tabs via Cmd+T keyboard simulation.
        """
        logger.debug(f"Opening new Terminal.app tab for {worktree_path}")

        commands = [f"cd {shlex.quote(str(worktree_path))}"]
        if init_script:
            commands.append(init_script)

        command_string = self._escape_for_applescript("; ".join(commands))

        # First check if we have any Terminal windows open
        check_windows_script = """
        tell application "Terminal"
            return count of windows
        end tell
        """

        try:
            result = run_command(
                ["osascript", "-e", check_windows_script],
                timeout=5,
                description="Check Terminal windows",
            )
            window_count = int(result.stdout.strip()) if result.returncode == 0 else 0
        except Exception:
            window_count = 0

        if window_count == 0:
            # No windows open, create first window
            applescript = f"""
            tell application "Terminal"
                do script "{command_string}"
            end tell
            """
        else:
            # Windows exist, try to create a tab using System Events
            applescript = f"""
            tell application "Terminal"
                activate
                tell application "System Events"
                    tell process "Terminal"
                        keystroke "t" using command down
                    end tell
                end tell
                delay 0.3
                do script "{command_string}" in selected tab of front window
            end tell
            """

        success = self._run_applescript(applescript)

        if not success and window_count > 0:
            # System Events failed, fall back to window creation
            logger.warning(
                "Failed to create tab (missing accessibility permissions). "
                "Creating new window instead. To fix: Enable Terminal in "
                "System Settings -> Privacy & Security -> Accessibility"
            )
            fallback_script = f"""
            tell application "Terminal"
                do script "{command_string}"
            end tell
            """
            return self._run_applescript(fallback_script)

        return success

    def open_new_window(
        self, worktree_path: Path, init_script: str | None = None
    ) -> bool:
        """Open a new Terminal.app window."""
        logger.debug(f"Opening new Terminal.app window for {worktree_path}")

        commands = [f"cd {shlex.quote(str(worktree_path))}"]
        if init_script:
            commands.append(init_script)

        command_string = self._escape_for_applescript("; ".join(commands))

        applescript = f"""
        tell application "Terminal"
            do script "{command_string}"
        end tell
        """

        return self._run_applescript(applescript)

    def execute_in_current_session(self, command: str) -> bool:
        """Execute a command in the current Terminal.app session."""
        logger.debug(f"Executing command in current Terminal.app session: {command}")

        applescript = f'''
        tell application "Terminal"
            do script "{self._escape_for_applescript(command)}" in selected tab of front window
        end tell
        '''

        return self._run_applescript(applescript)


class TmuxTerminal(Terminal):
    """tmux terminal implementation for users already using tmux."""

    def __init__(self):
        """Initialize tmux terminal implementation."""
        super().__init__()
        self.is_in_tmux = bool(os.getenv("TMUX"))

    def get_current_session_id(self) -> str | None:
        """Get current tmux session name."""
        if not self.is_in_tmux:
            return None

        try:
            result = run_command(
                ["tmux", "display-message", "-p", "#S"],
                timeout=5,
                description="Get current tmux session name",
            )
            return result.stdout.strip() if result.returncode == 0 else None
        except Exception:
            return None

    def supports_session_management(self) -> bool:
        """tmux supports excellent session management."""
        return True

    def switch_to_session(
        self, session_id: str, init_script: str | None = None
    ) -> bool:
        """Switch to existing tmux session."""
        logger.debug(f"Switching to tmux session: {session_id}")

        try:
            # Check if session exists
            result = run_command(
                ["tmux", "has-session", "-t", session_id],
                timeout=5,
                description=f"Check if tmux session {session_id} exists",
            )

            if result.returncode != 0:
                return False

            # Switch to session
            if self.is_in_tmux:
                # If inside tmux, switch within tmux
                switch_result = run_command(
                    ["tmux", "switch-client", "-t", session_id],
                    timeout=5,
                    description=f"Switch to tmux session {session_id}",
                )
            else:
                # Not in tmux, attach to session
                switch_result = run_command(
                    ["tmux", "attach-session", "-t", session_id],
                    timeout=5,
                    description=f"Attach to tmux session {session_id}",
                )

            success = switch_result.returncode == 0

            # Run init script if provided and switch succeeded
            if success and init_script:
                run_command(
                    ["tmux", "send-keys", "-t", session_id, init_script, "Enter"],
                    timeout=5,
                    description=f"Send init script to tmux session {session_id}",
                )

            return success

        except Exception as e:
            logger.error(f"Failed to switch to tmux session: {e}")
            return False

    def _create_session_name(self, worktree_path: Path) -> str:
        """Create a tmux session name for the worktree."""
        # Use sanitized worktree directory name
        return f"autowt-{sanitize_branch_name(worktree_path.name)}"

    def open_new_tab(self, worktree_path: Path, init_script: str | None = None) -> bool:
        """Create new tmux window (tmux equivalent of tab)."""
        return self.open_new_window(worktree_path, init_script)

    def open_new_window(
        self, worktree_path: Path, init_script: str | None = None
    ) -> bool:
        """Create new tmux session for the worktree."""
        logger.debug(f"Creating tmux session for {worktree_path}")

        session_name = self._create_session_name(worktree_path)

        try:
            # Create or attach to session
            cmd = [
                "tmux",
                "new-session",
                "-A",
                "-s",
                session_name,
                "-c",
                str(worktree_path),
            ]

            if self.is_in_tmux:
                # If inside tmux, create detached and switch
                cmd.insert(-1, "-d")
                create_result = run_command(
                    cmd,
                    timeout=10,
                    description=f"Create tmux session {session_name}",
                )
                if create_result.returncode == 0:
                    return self.switch_to_session(session_name, init_script)
                return False
            else:
                # Not in tmux, can attach directly
                result = run_command(
                    cmd,
                    timeout=10,
                    description=f"Create/attach tmux session {session_name}",
                )

                if result.returncode == 0 and init_script:
                    run_command(
                        ["tmux", "send-keys", init_script, "Enter"],
                        timeout=5,
                        description="Send init script to new tmux session",
                    )

                return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to create tmux session: {e}")
            return False


class GnomeTerminalTerminal(Terminal):
    """GNOME Terminal implementation for Linux."""

    def get_current_session_id(self) -> str | None:
        """GNOME Terminal doesn't have session IDs."""
        return None

    def switch_to_session(
        self, session_id: str, init_script: str | None = None
    ) -> bool:
        """GNOME Terminal doesn't support session switching."""
        return False

    def open_new_tab(self, worktree_path: Path, init_script: str | None = None) -> bool:
        """Open a new GNOME Terminal tab."""
        logger.info(
            "Using experimental support for GNOME Terminal. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new GNOME Terminal tab for {worktree_path}")

        try:
            cmd = ["gnome-terminal", "--tab", "--working-directory", str(worktree_path)]
            if init_script:
                cmd.extend(["--", "bash", "-c", f"{init_script}; exec bash"])

            result = run_command(
                cmd,
                timeout=10,
                description="Open GNOME Terminal tab",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open GNOME Terminal tab: {e}")
            return False

    def open_new_window(
        self, worktree_path: Path, init_script: str | None = None
    ) -> bool:
        """Open a new GNOME Terminal window."""
        logger.info(
            "Using experimental support for GNOME Terminal. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new GNOME Terminal window for {worktree_path}")

        try:
            cmd = [
                "gnome-terminal",
                "--window",
                "--working-directory",
                str(worktree_path),
            ]
            if init_script:
                cmd.extend(["--", "bash", "-c", f"{init_script}; exec bash"])

            result = run_command(
                cmd,
                timeout=10,
                description="Open GNOME Terminal window",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open GNOME Terminal window: {e}")
            return False


class KonsoleTerminal(Terminal):
    """Konsole terminal implementation for KDE."""

    def get_current_session_id(self) -> str | None:
        """Konsole doesn't have session IDs."""
        return None

    def switch_to_session(
        self, session_id: str, init_script: str | None = None
    ) -> bool:
        """Konsole doesn't support session switching."""
        return False

    def open_new_tab(self, worktree_path: Path, init_script: str | None = None) -> bool:
        """Open a new Konsole tab."""
        logger.info(
            "Using experimental support for Konsole. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new Konsole tab for {worktree_path}")

        try:
            cmd = ["konsole", "--new-tab", "--workdir", str(worktree_path)]
            if init_script:
                cmd.extend(["-e", "bash", "-c", f"{init_script}; exec bash"])

            result = run_command(
                cmd,
                timeout=10,
                description="Open Konsole tab",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open Konsole tab: {e}")
            return False

    def open_new_window(
        self, worktree_path: Path, init_script: str | None = None
    ) -> bool:
        """Open a new Konsole window."""
        logger.info(
            "Using experimental support for Konsole. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new Konsole window for {worktree_path}")

        try:
            cmd = ["konsole", "--workdir", str(worktree_path)]
            if init_script:
                cmd.extend(["-e", "bash", "-c", f"{init_script}; exec bash"])

            result = run_command(
                cmd,
                timeout=10,
                description="Open Konsole window",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open Konsole window: {e}")
            return False


class XfceTerminalTerminal(Terminal):
    """XFCE4 Terminal implementation."""

    def get_current_session_id(self) -> str | None:
        """XFCE4 Terminal doesn't have session IDs."""
        return None

    def switch_to_session(
        self, session_id: str, init_script: str | None = None
    ) -> bool:
        """XFCE4 Terminal doesn't support session switching."""
        return False

    def open_new_tab(self, worktree_path: Path, init_script: str | None = None) -> bool:
        """Open a new XFCE4 Terminal tab."""
        logger.info(
            "Using experimental support for XFCE4 Terminal. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new XFCE4 Terminal tab for {worktree_path}")

        try:
            cmd = ["xfce4-terminal", "--tab", "--working-directory", str(worktree_path)]
            if init_script:
                cmd.extend(["--command", f"bash -c '{init_script}; exec bash'"])

            result = run_command(
                cmd,
                timeout=10,
                description="Open XFCE4 Terminal tab",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open XFCE4 Terminal tab: {e}")
            return False

    def open_new_window(
        self, worktree_path: Path, init_script: str | None = None
    ) -> bool:
        """Open a new XFCE4 Terminal window."""
        logger.info(
            "Using experimental support for XFCE4 Terminal. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new XFCE4 Terminal window for {worktree_path}")

        try:
            cmd = [
                "xfce4-terminal",
                "--window",
                "--working-directory",
                str(worktree_path),
            ]
            if init_script:
                cmd.extend(["--command", f"bash -c '{init_script}; exec bash'"])

            result = run_command(
                cmd,
                timeout=10,
                description="Open XFCE4 Terminal window",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open XFCE4 Terminal window: {e}")
            return False


class TilixTerminal(Terminal):
    """Tilix terminal implementation."""

    def get_current_session_id(self) -> str | None:
        """Tilix doesn't have session IDs."""
        return None

    def switch_to_session(
        self, session_id: str, init_script: str | None = None
    ) -> bool:
        """Tilix doesn't support session switching."""
        return False

    def open_new_tab(self, worktree_path: Path, init_script: str | None = None) -> bool:
        """Open a new Tilix session (tab equivalent)."""
        logger.info(
            "Using experimental support for Tilix. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new Tilix session for {worktree_path}")

        try:
            cmd = [
                "tilix",
                "--focus-window",
                "--action=app-new-session",
                "--working-directory",
                str(worktree_path),
            ]
            if init_script:
                cmd.extend(["-x", "bash", "-c", f"{init_script}; exec bash"])

            result = run_command(
                cmd,
                timeout=10,
                description="Open Tilix session",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open Tilix session: {e}")
            return False

    def open_new_window(
        self, worktree_path: Path, init_script: str | None = None
    ) -> bool:
        """Open a new Tilix window."""
        logger.info(
            "Using experimental support for Tilix. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new Tilix window for {worktree_path}")

        try:
            cmd = [
                "tilix",
                "--action=app-new-window",
                "--working-directory",
                str(worktree_path),
            ]
            if init_script:
                cmd.extend(["-x", "bash", "-c", f"{init_script}; exec bash"])

            result = run_command(
                cmd,
                timeout=10,
                description="Open Tilix window",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open Tilix window: {e}")
            return False


class TerminatorTerminal(Terminal):
    """Terminator terminal implementation."""

    def get_current_session_id(self) -> str | None:
        """Terminator doesn't have session IDs."""
        return None

    def switch_to_session(
        self, session_id: str, init_script: str | None = None
    ) -> bool:
        """Terminator doesn't support session switching."""
        return False

    def open_new_tab(self, worktree_path: Path, init_script: str | None = None) -> bool:
        """Open a new Terminator tab."""
        logger.info(
            "Using experimental support for Terminator. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new Terminator tab for {worktree_path}")

        try:
            cmd = ["terminator", "--new-tab", f"--working-directory={worktree_path}"]
            if init_script:
                cmd.extend(["-x", "bash", "-c", f"{init_script}; exec bash"])

            result = run_command(
                cmd,
                timeout=10,
                description="Open Terminator tab",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open Terminator tab: {e}")
            return False

    def open_new_window(
        self, worktree_path: Path, init_script: str | None = None
    ) -> bool:
        """Open a new Terminator window."""
        logger.info(
            "Using experimental support for Terminator. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new Terminator window for {worktree_path}")

        try:
            cmd = ["terminator", f"--working-directory={worktree_path}"]
            if init_script:
                cmd.extend(["-x", "bash", "-c", f"{init_script}; exec bash"])

            result = run_command(
                cmd,
                timeout=10,
                description="Open Terminator window",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open Terminator window: {e}")
            return False


class AlacrittyTerminal(Terminal):
    """Alacritty terminal implementation (no tab support, window-only)."""

    def get_current_session_id(self) -> str | None:
        """Alacritty doesn't have session IDs."""
        return None

    def switch_to_session(
        self, session_id: str, init_script: str | None = None
    ) -> bool:
        """Alacritty doesn't support session switching."""
        return False

    def open_new_tab(self, worktree_path: Path, init_script: str | None = None) -> bool:
        """Alacritty doesn't support tabs, fall back to window."""
        logger.warning("Alacritty doesn't support tabs, opening new window instead")
        return self.open_new_window(worktree_path, init_script)

    def open_new_window(
        self, worktree_path: Path, init_script: str | None = None
    ) -> bool:
        """Open a new Alacritty window."""
        logger.info(
            "Using experimental support for Alacritty. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new Alacritty window for {worktree_path}")

        try:
            cmd = ["alacritty", "--working-directory", str(worktree_path)]
            if init_script:
                cmd.extend(["-e", "bash", "-c", f"{init_script}; exec bash"])

            result = run_command(
                cmd,
                timeout=10,
                description="Open Alacritty window",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open Alacritty window: {e}")
            return False


class KittyTerminal(Terminal):
    """Kitty terminal implementation."""

    def get_current_session_id(self) -> str | None:
        """Kitty doesn't have session IDs."""
        return None

    def switch_to_session(
        self, session_id: str, init_script: str | None = None
    ) -> bool:
        """Kitty doesn't support session switching."""
        return False

    def open_new_tab(self, worktree_path: Path, init_script: str | None = None) -> bool:
        """Open a new Kitty tab using remote control."""
        logger.info(
            "Using experimental support for Kitty. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new Kitty tab for {worktree_path}")

        try:
            # Try using kitty remote control first
            cmd = ["kitty", "@", "launch", "--type=tab", "--cwd", str(worktree_path)]
            if init_script:
                cmd.extend(["bash", "-c", f"{init_script}; exec bash"])
            else:
                cmd.append("bash")

            result = run_command(
                cmd,
                timeout=10,
                description="Open Kitty tab via remote control",
            )

            if result.returncode == 0:
                return True

            # Fall back to opening new window if remote control fails
            logger.debug("Kitty remote control failed, falling back to new window")
            return self.open_new_window(worktree_path, init_script)

        except Exception as e:
            logger.error(f"Failed to open Kitty tab: {e}")
            return False

    def open_new_window(
        self, worktree_path: Path, init_script: str | None = None
    ) -> bool:
        """Open a new Kitty window."""
        logger.info(
            "Using experimental support for Kitty. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new Kitty window for {worktree_path}")

        try:
            cmd = ["kitty", "--directory", str(worktree_path)]
            if init_script:
                cmd.extend(["bash", "-c", f"{init_script}; exec bash"])

            result = run_command(
                cmd,
                timeout=10,
                description="Open Kitty window",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open Kitty window: {e}")
            return False


class WezTermTerminal(Terminal):
    """WezTerm terminal implementation."""

    def get_current_session_id(self) -> str | None:
        """WezTerm doesn't have session IDs."""
        return None

    def switch_to_session(
        self, session_id: str, init_script: str | None = None
    ) -> bool:
        """WezTerm doesn't support session switching."""
        return False

    def open_new_tab(self, worktree_path: Path, init_script: str | None = None) -> bool:
        """Open a new WezTerm tab."""
        logger.info(
            "Using experimental support for WezTerm. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new WezTerm tab for {worktree_path}")

        try:
            cmd = ["wezterm", "cli", "spawn", "--cwd", str(worktree_path)]
            if init_script:
                cmd.extend(["bash", "-c", f"{init_script}; exec bash"])
            else:
                cmd.append("bash")

            result = run_command(
                cmd,
                timeout=10,
                description="Open WezTerm tab",
            )

            if result.returncode == 0:
                return True

            # Fall back to opening new window if CLI fails
            logger.debug("WezTerm CLI failed, falling back to new window")
            return self.open_new_window(worktree_path, init_script)

        except Exception as e:
            logger.error(f"Failed to open WezTerm tab: {e}")
            return False

    def open_new_window(
        self, worktree_path: Path, init_script: str | None = None
    ) -> bool:
        """Open a new WezTerm window."""
        logger.info(
            "Using experimental support for WezTerm. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new WezTerm window for {worktree_path}")

        try:
            cmd = ["wezterm", "start", "--cwd", str(worktree_path)]
            if init_script:
                cmd.extend(["bash", "-c", f"{init_script}; exec bash"])

            result = run_command(
                cmd,
                timeout=10,
                description="Open WezTerm window",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open WezTerm window: {e}")
            return False


class HyperTerminal(Terminal):
    """Hyper terminal implementation."""

    def get_current_session_id(self) -> str | None:
        """Hyper doesn't have session IDs."""
        return None

    def switch_to_session(
        self, session_id: str, init_script: str | None = None
    ) -> bool:
        """Hyper doesn't support session switching."""
        return False

    def open_new_tab(self, worktree_path: Path, init_script: str | None = None) -> bool:
        """Open new Hyper tab (same as window for Hyper)."""
        return self.open_new_window(worktree_path, init_script)

    def open_new_window(
        self, worktree_path: Path, init_script: str | None = None
    ) -> bool:
        """Open a new Hyper window."""
        logger.info(
            "Using experimental support for Hyper. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new Hyper window for {worktree_path}")

        try:
            if self.is_macos:
                cmd = ["open", "-a", "Hyper", str(worktree_path)]
            else:
                cmd = ["hyper", str(worktree_path)]

            if init_script:
                # Hyper doesn't easily support init scripts via command line
                logger.warning(
                    "Hyper doesn't support init scripts via command line. "
                    "You may need to run the init script manually."
                )

            result = run_command(
                cmd,
                timeout=10,
                description="Open Hyper window",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open Hyper window: {e}")
            return False


class WindowsTerminalTerminal(Terminal):
    """Windows Terminal implementation."""

    def get_current_session_id(self) -> str | None:
        """Windows Terminal doesn't have session IDs."""
        return None

    def switch_to_session(
        self, session_id: str, init_script: str | None = None
    ) -> bool:
        """Windows Terminal doesn't support session switching."""
        return False

    def open_new_tab(self, worktree_path: Path, init_script: str | None = None) -> bool:
        """Open a new Windows Terminal tab."""
        logger.info(
            "Using experimental support for Windows Terminal. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new Windows Terminal tab for {worktree_path}")

        try:
            cmd = ["wt", "-d", str(worktree_path)]
            if init_script:
                # Use PowerShell to run the init script
                cmd.extend(["powershell", "-NoExit", "-Command", init_script])

            result = run_command(
                cmd,
                timeout=10,
                description="Open Windows Terminal tab",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open Windows Terminal tab: {e}")
            return False

    def open_new_window(
        self, worktree_path: Path, init_script: str | None = None
    ) -> bool:
        """Open a new Windows Terminal window."""
        logger.info(
            "Using experimental support for Windows Terminal. "
            "Please report issues at https://github.com/irskep/autowt/issues"
        )
        logger.debug(f"Opening new Windows Terminal window for {worktree_path}")

        try:
            cmd = ["wt", "--window", "0", "-d", str(worktree_path)]
            if init_script:
                # Use PowerShell to run the init script
                cmd.extend(["powershell", "-NoExit", "-Command", init_script])

            result = run_command(
                cmd,
                timeout=10,
                description="Open Windows Terminal window",
            )
            return result.returncode == 0

        except Exception as e:
            logger.error(f"Failed to open Windows Terminal window: {e}")
            return False


class GenericTerminal(Terminal):
    """Generic terminal implementation for fallback - echoes commands instead of executing them."""

    def get_current_session_id(self) -> str | None:
        """Generic terminals don't have session IDs."""
        return None

    def switch_to_session(
        self, session_id: str, init_script: str | None = None
    ) -> bool:
        """Generic terminals don't support session switching."""
        return False

    def open_new_tab(self, worktree_path: Path, init_script: str | None = None) -> bool:
        """Open terminal using generic methods (same as new window)."""
        return self.open_new_window(worktree_path, init_script)

    def _collect_debug_info(self) -> dict:
        """Collect debug information for GitHub issue reporting."""
        debug_info = {
            "platform": platform.system(),
            "platform_release": platform.release(),
            "platform_version": platform.version(),
            "architecture": platform.architecture(),
            "shell": os.environ.get("SHELL", "unknown"),
            "term": os.environ.get("TERM", "unknown"),
            "term_program": os.environ.get("TERM_PROGRAM", "unknown"),
            "desktop_env": os.environ.get("XDG_CURRENT_DESKTOP", "unknown"),
            "display": os.environ.get("DISPLAY", "not set"),
            "wayland_display": os.environ.get("WAYLAND_DISPLAY", "not set"),
        }

        # Check for common terminal executables
        terminal_programs = [
            "gnome-terminal",
            "konsole",
            "xterm",
            "xfce4-terminal",
            "tilix",
            "terminator",
            "alacritty",
            "kitty",
            "wezterm",
        ]

        available_terminals = []
        for terminal in terminal_programs:
            try:
                result = run_command(
                    ["which", terminal]
                    if not platform.system() == "Windows"
                    else ["where", terminal],
                    timeout=2,
                    description=f"Check for {terminal}",
                )
                if result.returncode == 0:
                    available_terminals.append(f"{terminal}: {result.stdout.strip()}")
            except Exception:
                pass

        debug_info["available_terminals"] = available_terminals
        return debug_info

    def open_new_window(
        self, worktree_path: Path, init_script: str | None = None
    ) -> bool:
        """Echo commands that would open a terminal instead of executing them."""
        print("\n=== Generic Terminal Fallback - Manual Commands Required ===")
        print(
            "autowt detected an unsupported terminal. Please run these commands manually:"
        )
        print()

        # Show the basic navigation command
        print("# Change to worktree directory:")
        print(f"cd {shlex.quote(str(worktree_path))}")

        if init_script:
            print("\n# Run initialization script:")
            print(f"{init_script}")

        print()

        # Platform-specific suggestions
        if self.is_macos:
            print("# To open a new Terminal window on macOS:")
            print(f"open -a Terminal {shlex.quote(str(worktree_path))}")
        elif platform.system() == "Windows":
            print(
                "# To open a new terminal window on Windows (if Windows Terminal is installed):"
            )
            print(f"wt -d {shlex.quote(str(worktree_path))}")
            print("# Or with Command Prompt:")
            print(f'start cmd /k "cd /d {shlex.quote(str(worktree_path))}"')
        else:
            print("# To open a new terminal window on Linux, try one of these:")
            terminals_with_commands = [
                (
                    "gnome-terminal",
                    f"gnome-terminal --working-directory={shlex.quote(str(worktree_path))}",
                ),
                ("konsole", f"konsole --workdir {shlex.quote(str(worktree_path))}"),
                (
                    "xfce4-terminal",
                    f"xfce4-terminal --working-directory={shlex.quote(str(worktree_path))}",
                ),
                ("xterm", f"cd {shlex.quote(str(worktree_path))} && xterm"),
            ]

            for terminal_name, command in terminals_with_commands:
                print(f"{command}")

        print()
        print("=== Debug Information for GitHub Issues ===")
        print(
            "If you'd like to request support for your terminal, please create an issue at:"
        )
        print("https://github.com/irskep/autowt/issues")
        print()
        print("Include this debug information:")

        debug_info = self._collect_debug_info()
        for key, value in debug_info.items():
            if isinstance(value, list):
                print(f"{key}:")
                for item in value:
                    print(f"  - {item}")
            else:
                print(f"{key}: {value}")

        print()
        print("=== End Debug Information ===")
        print()

        # Return True since we successfully provided the user with information
        return True


class TerminalService:
    """Handles terminal switching and session management."""

    def __init__(self, state_service: StateService):
        """Initialize terminal service."""
        self.state_service = state_service
        self.is_macos = platform.system() == "Darwin"
        self.terminal = self._create_terminal_implementation()
        logger.debug(
            f"Terminal service initialized with {type(self.terminal).__name__}"
        )

    def _is_experimental_terminal(self) -> bool:
        """Check if the current terminal is experimental (not fully supported)."""
        # Skip warning for Mock objects during testing
        if (
            hasattr(self.terminal, "_mock_name")
            or type(self.terminal).__name__ == "Mock"
        ):
            return False

        # Skip warning during pytest runs (pytest sets PYTEST_CURRENT_TEST)
        if os.getenv("PYTEST_CURRENT_TEST"):
            return False

        # Fully supported terminals
        fully_supported = (ITerm2Terminal, TerminalAppTerminal)
        return not isinstance(self.terminal, fully_supported)

    def _get_terminal_github_url(self) -> str:
        """Get GitHub URL pointing to the terminal implementation source code."""
        base_url = (
            "https://github.com/irskep/autowt/blob/main/src/autowt/services/terminal.py"
        )

        # Map terminal classes to their approximate line numbers in the source
        terminal_lines = {
            TmuxTerminal: "#L674",
            GnomeTerminalTerminal: "#L812",
            KonsoleTerminal: "#L881",
            XfceTerminalTerminal: "#L945",
            TilixTerminal: "#L1014",
            TerminatorTerminal: "#L1089",
            AlacrittyTerminal: "#L1153",
            KittyTerminal: "#L1198",
            WezTermTerminal: "#L1271",
            HyperTerminal: "#L1343",
            WindowsTerminalTerminal: "#L1395",
            GenericTerminal: "#L1461",
        }

        line_fragment = terminal_lines.get(type(self.terminal), "#L1")
        return f"{base_url}{line_fragment}"

    def _show_experimental_terminal_warning(self) -> bool:
        """Show experimental terminal warning and get user confirmation."""
        terminal_name = type(self.terminal).__name__.replace("Terminal", "")
        github_url = self._get_terminal_github_url()

        print("\n⚠️  Experimental Terminal Support")
        print(
            f"You're using {terminal_name}, which has experimental support in autowt."
        )
        print("This means it may be unstable or have limited functionality.")
        print("")
        print(f"Implementation: {github_url}")
        print("Report issues: https://github.com/irskep/autowt/issues")
        print("")

        return confirm_default_yes("Continue with experimental terminal support?")

    def _create_terminal_implementation(self) -> Terminal:
        """Create the appropriate terminal implementation."""
        # Check for tmux first (works on all platforms)
        if os.getenv("TMUX"):
            logger.debug("Detected tmux environment")
            return TmuxTerminal()

        term_program = os.getenv("TERM_PROGRAM", "")
        logger.debug(f"TERM_PROGRAM: {term_program}")

        # Check for specific terminal programs first
        if term_program == "iTerm.app":
            return ITerm2Terminal()
        elif term_program == "Apple_Terminal":
            return TerminalAppTerminal()
        elif term_program == "WezTerm":
            return WezTermTerminal()
        elif term_program == "Hyper":
            return HyperTerminal()

        # Check for terminal-specific environment variables
        if os.getenv("KITTY_WINDOW_ID"):
            return KittyTerminal()
        if os.getenv("ALACRITTY_SOCKET") or os.getenv("ALACRITTY_LOG"):
            return AlacrittyTerminal()

        # Platform-specific detection
        if platform.system() == "Windows":
            # Check if Windows Terminal is available
            try:
                result = run_command(
                    ["where", "wt"],
                    timeout=5,
                    description="Check for Windows Terminal",
                )
                if result.returncode == 0:
                    return WindowsTerminalTerminal()
            except Exception:
                pass
            return GenericTerminal()

        # Linux/Unix terminal detection
        if not self.is_macos:
            # Check desktop environment for default terminals
            desktop_env = os.getenv("XDG_CURRENT_DESKTOP", "").lower()

            # Try to detect based on available executables
            terminal_checks = [
                ("tilix", TilixTerminal),
                ("terminator", TerminatorTerminal),
                ("kitty", KittyTerminal),
                ("alacritty", AlacrittyTerminal),
                ("wezterm", WezTermTerminal),
                ("konsole", KonsoleTerminal),
                ("gnome-terminal", GnomeTerminalTerminal),
                ("xfce4-terminal", XfceTerminalTerminal),
            ]

            # Prioritize based on desktop environment
            if "gnome" in desktop_env:
                terminal_checks.insert(0, ("gnome-terminal", GnomeTerminalTerminal))
            elif "kde" in desktop_env or "plasma" in desktop_env:
                terminal_checks.insert(0, ("konsole", KonsoleTerminal))
            elif "xfce" in desktop_env:
                terminal_checks.insert(0, ("xfce4-terminal", XfceTerminalTerminal))

            # Check which terminals are available
            for terminal_name, terminal_class in terminal_checks:
                try:
                    result = run_command(
                        ["which", terminal_name],
                        timeout=5,
                        description=f"Check for {terminal_name}",
                    )
                    if result.returncode == 0:
                        logger.debug(
                            f"Found {terminal_name}, using {terminal_class.__name__}"
                        )
                        return terminal_class()
                except Exception:
                    continue

        # Fallback to generic terminal
        return GenericTerminal()

    def get_current_session_id(self) -> str | None:
        """Get the current terminal session ID."""
        return self.terminal.get_current_session_id()

    def _combine_scripts(
        self, init_script: str | None, after_init: str | None
    ) -> str | None:
        """Combine init script and after-init command into a single script."""
        scripts = []
        if init_script:
            scripts.append(init_script)
        if after_init:
            scripts.append(after_init)
        return "; ".join(scripts) if scripts else None

    def switch_to_worktree(
        self,
        worktree_path: Path,
        mode: TerminalMode,
        session_id: str | None = None,
        init_script: str | None = None,
        after_init: str | None = None,
        branch_name: str | None = None,
        auto_confirm: bool = False,
        ignore_same_session: bool = False,
    ) -> bool:
        """Switch to a worktree using the specified terminal mode."""
        logger.debug(f"Switching to worktree {worktree_path} with mode {mode}")

        # Check for experimental terminal warning on first use
        if self._is_experimental_terminal():
            if not self.state_service.has_shown_experimental_terminal_warning():
                if not self._show_experimental_terminal_warning():
                    # User declined to continue with experimental terminal
                    return False
                self.state_service.mark_experimental_terminal_warning_shown()

        if mode == TerminalMode.INPLACE:
            return self._change_directory_inplace(
                worktree_path, init_script, after_init
            )
        elif mode == TerminalMode.ECHO:
            return self._echo_commands(worktree_path, init_script, after_init)
        elif mode == TerminalMode.TAB:
            return self._switch_to_existing_or_new_tab(
                worktree_path,
                session_id,
                init_script,
                after_init,
                branch_name,
                auto_confirm,
                ignore_same_session,
            )
        elif mode == TerminalMode.WINDOW:
            return self._switch_to_existing_or_new_window(
                worktree_path,
                session_id,
                init_script,
                after_init,
                branch_name,
                auto_confirm,
                ignore_same_session,
            )
        else:
            logger.error(f"Unknown terminal mode: {mode}")
            return False

    def _echo_commands(
        self,
        worktree_path: Path,
        init_script: str | None = None,
        after_init: str | None = None,
    ) -> bool:
        """Output shell command to change directory for eval usage."""
        logger.debug(f"Outputting cd command for {worktree_path}")

        try:
            # Output the cd command that the user can evaluate
            # Usage: eval "$(autowt ci --terminal=echo)"
            commands = [f"cd {shlex.quote(str(worktree_path))}"]
            if init_script:
                # Handle multi-line scripts by replacing newlines with semicolons
                normalized_script = init_script.replace("\n", "; ").strip()
                if normalized_script:
                    commands.append(normalized_script)
            if after_init:
                # Handle multi-line scripts by replacing newlines with semicolons
                normalized_after = after_init.replace("\n", "; ").strip()
                if normalized_after:
                    commands.append(normalized_after)
            print("; ".join(commands))
            return True
        except Exception as e:
            logger.error(f"Failed to output cd command: {e}")
            return False

    def _change_directory_inplace(
        self,
        worktree_path: Path,
        init_script: str | None = None,
        after_init: str | None = None,
    ) -> bool:
        """Execute directory change and commands directly in current terminal session."""
        logger.debug(f"Executing cd command in current session for {worktree_path}")

        try:
            # Build command list
            commands = [f"cd {shlex.quote(str(worktree_path))}"]
            if init_script:
                commands.append(init_script)
            if after_init:
                commands.append(after_init)

            combined_command = "; ".join(commands)

            # Try to execute in current terminal session using osascript
            if hasattr(self.terminal, "execute_in_current_session"):
                return self.terminal.execute_in_current_session(combined_command)
            else:
                # Fallback to echo behavior for unsupported terminals
                logger.warning(
                    "Current terminal doesn't support inplace execution, falling back to echo"
                )
                print(combined_command)
                return True

        except Exception as e:
            logger.error(f"Failed to execute cd command in current session: {e}")
            return False

    def _switch_to_existing_or_new_tab(
        self,
        worktree_path: Path,
        session_id: str | None = None,
        init_script: str | None = None,
        after_init: str | None = None,
        branch_name: str | None = None,
        auto_confirm: bool = False,
        ignore_same_session: bool = False,
    ) -> bool:
        """Switch to existing session or create new tab."""
        # If ignore_same_session is True, skip session detection and always create new tab
        if not ignore_same_session:
            # For Terminal.app, use worktree path as session identifier
            # For other terminals (iTerm2, tmux), use provided session_id
            if self.terminal.supports_session_management():
                if isinstance(self.terminal, TerminalAppTerminal):
                    effective_session_id = str(worktree_path)
                else:
                    effective_session_id = session_id

                # First try: Check if the stored session ID exists and is in correct directory
                if effective_session_id and self.terminal.session_exists(
                    effective_session_id
                ):
                    # For iTerm2, verify the session is still in the correct directory
                    if isinstance(self.terminal, ITerm2Terminal):
                        if not self.terminal.session_in_directory(
                            effective_session_id, worktree_path
                        ):
                            logger.debug(
                                f"Session {effective_session_id} no longer in directory {worktree_path}, discarding"
                            )
                            # Skip using this session ID and fall through to create new tab
                        else:
                            if auto_confirm or self._should_switch_to_existing(
                                branch_name
                            ):
                                # Try to switch to existing session (no init script - session already exists)
                                if self.terminal.switch_to_session(
                                    effective_session_id, None
                                ):
                                    print(
                                        f"Switched to existing {branch_name or 'worktree'} session"
                                    )
                                    return True
                    else:
                        # For other terminals, use existing logic
                        if auto_confirm or self._should_switch_to_existing(branch_name):
                            # Try to switch to existing session (no init script - session already exists)
                            if self.terminal.switch_to_session(
                                effective_session_id, None
                            ):
                                print(
                                    f"Switched to existing {branch_name or 'worktree'} session"
                                )
                                return True

                # Second try: For iTerm2, check if there's a session in the worktree directory
                if isinstance(self.terminal, ITerm2Terminal) and hasattr(
                    self.terminal, "find_session_by_working_directory"
                ):
                    fallback_session_id = (
                        self.terminal.find_session_by_working_directory(
                            str(worktree_path)
                        )
                    )
                    if fallback_session_id:
                        logger.debug(
                            f"Found session {fallback_session_id} in directory {worktree_path}"
                        )
                        if auto_confirm or self._should_switch_to_existing(branch_name):
                            if self.terminal.switch_to_session(
                                fallback_session_id, None
                            ):
                                print(
                                    f"Switched to existing {branch_name or 'worktree'} session (found by directory)"
                                )
                                return True

                # Second try: For Terminal.app, always scan for existing tabs in target directory
                elif isinstance(self.terminal, TerminalAppTerminal):
                    # Always scan for tabs in the worktree directory (Terminal.app should use workdir matching every time)
                    logger.debug(
                        f"Scanning Terminal.app tabs for directory: {worktree_path}"
                    )
                    if auto_confirm or self._should_switch_to_existing(branch_name):
                        if self.terminal.switch_to_session(str(worktree_path), None):
                            print(
                                f"Switched to existing {branch_name or 'worktree'} session (found by directory scan)"
                            )
                            return True

        # Fall back to creating new tab (or forced by ignore_same_session)
        combined_script = self._combine_scripts(init_script, after_init)
        return self.terminal.open_new_tab(worktree_path, combined_script)

    def _switch_to_existing_or_new_window(
        self,
        worktree_path: Path,
        session_id: str | None = None,
        init_script: str | None = None,
        after_init: str | None = None,
        branch_name: str | None = None,
        auto_confirm: bool = False,
        ignore_same_session: bool = False,
    ) -> bool:
        """Switch to existing session or create new window."""
        # If ignore_same_session is True, skip session detection and always create new window
        if not ignore_same_session:
            # For Terminal.app, use worktree path as session identifier
            # For other terminals (iTerm2, tmux), use provided session_id
            if self.terminal.supports_session_management():
                if isinstance(self.terminal, TerminalAppTerminal):
                    effective_session_id = str(worktree_path)
                else:
                    effective_session_id = session_id

                # First try: Check if the stored session ID exists and is in correct directory
                if effective_session_id and self.terminal.session_exists(
                    effective_session_id
                ):
                    # For iTerm2, verify the session is still in the correct directory
                    if isinstance(self.terminal, ITerm2Terminal):
                        if not self.terminal.session_in_directory(
                            effective_session_id, worktree_path
                        ):
                            logger.debug(
                                f"Session {effective_session_id} no longer in directory {worktree_path}, discarding"
                            )
                            # Skip using this session ID and fall through to create new window
                        else:
                            if auto_confirm or self._should_switch_to_existing(
                                branch_name
                            ):
                                # Try to switch to existing session (no init script - session already exists)
                                if self.terminal.switch_to_session(
                                    effective_session_id, None
                                ):
                                    print(
                                        f"Switched to existing {branch_name or 'worktree'} session"
                                    )
                                    return True
                    else:
                        # For other terminals, use existing logic
                        if auto_confirm or self._should_switch_to_existing(branch_name):
                            # Try to switch to existing session (no init script - session already exists)
                            if self.terminal.switch_to_session(
                                effective_session_id, None
                            ):
                                print(
                                    f"Switched to existing {branch_name or 'worktree'} session"
                                )
                                return True

                # Second try: For iTerm2, check if there's a session in the worktree directory
                if isinstance(self.terminal, ITerm2Terminal) and hasattr(
                    self.terminal, "find_session_by_working_directory"
                ):
                    fallback_session_id = (
                        self.terminal.find_session_by_working_directory(
                            str(worktree_path)
                        )
                    )
                    if fallback_session_id:
                        logger.debug(
                            f"Found session {fallback_session_id} in directory {worktree_path}"
                        )
                        if auto_confirm or self._should_switch_to_existing(branch_name):
                            if self.terminal.switch_to_session(
                                fallback_session_id, None
                            ):
                                print(
                                    f"Switched to existing {branch_name or 'worktree'} session (found by directory)"
                                )
                                return True

                # Second try: For Terminal.app, always scan for existing tabs in target directory
                elif isinstance(self.terminal, TerminalAppTerminal):
                    # Always scan for tabs in the worktree directory (Terminal.app should use workdir matching every time)
                    logger.debug(
                        f"Scanning Terminal.app tabs for directory: {worktree_path}"
                    )
                    if auto_confirm or self._should_switch_to_existing(branch_name):
                        if self.terminal.switch_to_session(str(worktree_path), None):
                            print(
                                f"Switched to existing {branch_name or 'worktree'} session (found by directory scan)"
                            )
                            return True

        # Fall back to creating new window (or forced by ignore_same_session)
        combined_script = self._combine_scripts(init_script, after_init)
        return self.terminal.open_new_window(worktree_path, combined_script)

    def _should_switch_to_existing(self, branch_name: str | None) -> bool:
        """Ask user if they want to switch to existing session."""
        if branch_name:
            return confirm_default_yes(
                f"{branch_name} already has a session. Switch to it?"
            )
        else:
            return confirm_default_yes("Worktree already has a session. Switch to it?")



---
File: /src/autowt/tui/__init__.py
---




---
File: /src/autowt/tui/agents.py
---

"""Textual TUI for agent monitoring dashboard."""

from datetime import datetime
from pathlib import Path

from textual.app import App, ComposeResult
from textual.binding import Binding
from textual.containers import Container
from textual.timer import Timer
from textual.widgets import DataTable, Footer, Header, Static

from autowt.models import Services


class AgentDashboard(App):
    """Live agent monitoring dashboard."""

    TITLE = "Autowt - Agent Dashboard"
    CSS_PATH = "agents.css"
    BINDINGS = [
        Binding("q,escape", "quit", "Quit"),
        Binding("r", "refresh", "Refresh"),
        Binding("w", "switch_waiting", "Switch to Waiting"),
        Binding("enter", "switch_selected", "Switch to Selected"),
        Binding("j,down", "cursor_down", "Down"),
        Binding("k,up", "cursor_up", "Up"),
    ]

    def __init__(self, services: Services, repo_path: Path):
        super().__init__()
        self.services = services
        self.repo_path = repo_path
        self.refresh_timer: Timer | None = None
        self.table: DataTable | None = None

    def compose(self) -> ComposeResult:
        """Create dashboard layout."""
        yield Header()
        yield Container(
            Static(
                "Agent Status Dashboard - Auto-refresh every 3 seconds", id="status"
            ),
            DataTable(id="agents-table"),
            id="main-container",
        )
        yield Footer()

    def on_mount(self) -> None:
        """Set up dashboard when mounted."""
        self.table = self.query_one("#agents-table", DataTable)
        self.table.add_columns("Branch", "Status", "Last Activity", "Session")
        self.table.cursor_type = "row"

        self.refresh_data()
        # Set up auto-refresh every 3 seconds
        self.refresh_timer = self.set_interval(3.0, self.refresh_data)

    def refresh_data(self) -> None:
        """Refresh agent data from worktrees."""
        # Get worktrees
        git_worktrees = self.services.git.list_worktrees(self.repo_path)

        # Enhance with agent status
        enhanced_worktrees = self.services.agent.enhance_worktrees_with_agent_status(
            git_worktrees, self.services.state, self.repo_path
        )

        # Clear and populate table
        self.table.clear()

        for worktree in enhanced_worktrees:
            status_display = "Idle"
            if worktree.agent_status:
                status_display = f"{worktree.agent_status.status_indicator} {worktree.agent_status.status.title()}"

            last_activity = "Never"
            if worktree.agent_status and worktree.agent_status.last_activity:
                try:
                    dt = datetime.fromisoformat(
                        worktree.agent_status.last_activity.replace("Z", "+00:00")
                    )
                    last_activity = dt.strftime("%H:%M:%S")
                except ValueError:
                    last_activity = "Unknown"

            session_display = "✓" if worktree.has_active_session else "✗"

            self.table.add_row(
                worktree.branch,
                status_display,
                last_activity,
                session_display,
                key=worktree.branch,
            )

    def action_refresh(self) -> None:
        """Manual refresh action."""
        self.refresh_data()

    def action_switch_waiting(self) -> None:
        """Switch to first agent waiting for input."""
        # Find waiting agents
        git_worktrees = self.services.git.list_worktrees(self.repo_path)
        enhanced_worktrees = self.services.agent.enhance_worktrees_with_agent_status(
            git_worktrees, self.services.state, self.repo_path
        )

        waiting_agents = self.services.agent.find_waiting_agents(enhanced_worktrees)
        if waiting_agents:
            self.exit(result={"action": "switch", "branch": waiting_agents[0].branch})
        else:
            self.notify("No agents waiting for input")

    def action_switch_selected(self) -> None:
        """Switch to selected worktree."""
        if self.table.cursor_row is not None:
            row_key = self.table.get_row_at(self.table.cursor_row)[0]  # Branch name
            self.exit(result={"action": "switch", "branch": row_key})

    def on_unmount(self) -> None:
        """Clean up when unmounting."""
        if self.refresh_timer:
            self.refresh_timer.stop()



---
File: /src/autowt/tui/cleanup.py
---

"""Textual TUI for interactive cleanup."""

from pathlib import Path

from textual.app import App, ComposeResult
from textual.binding import Binding
from textual.containers import Container, Horizontal, Vertical
from textual.widgets import Button, Footer, Header, ListItem, ListView, Static

from autowt.models import BranchStatus


class ClickableStatic(Static):
    """A Static widget that can handle clicks."""

    def __init__(self, *args, on_click_callback=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.on_click_callback = on_click_callback

    def on_click(self) -> None:
        """Handle click events on this widget."""
        if self.on_click_callback:
            self.on_click_callback()


class CleanupTUI(App):
    """Interactive cleanup interface using Textual."""

    TITLE = "Autowt - Interactive Cleanup"
    CSS_PATH = "cleanup.css"
    BINDINGS = [
        Binding("q,escape", "quit", "Quit"),
        Binding("a", "select_all", "Select All"),
        Binding("n", "select_none", "None"),
        Binding("m", "select_merged", "Merged"),
        Binding("r", "select_remoteless", "No Remote"),
        Binding("space", "toggle_selection", "Toggle"),
        Binding("j", "cursor_down", "Down"),
        Binding("k", "cursor_up", "Up"),
        Binding("enter", "confirm", "Confirm"),
    ]

    def __init__(self, branch_statuses: list[BranchStatus]):
        super().__init__()
        self.branch_statuses = branch_statuses
        self.selected_rows = set()
        self.selected_branches = []
        self.list_view = None

    def compose(self) -> ComposeResult:
        """Create the TUI layout."""
        yield Header()

        with Container(id="main"):
            with Vertical(id="header-section"):
                yield Static(
                    "Select worktrees to remove (Space=toggle, Enter=confirm):",
                    id="instructions",
                )
                yield Static(
                    f"Found {len(self.branch_statuses)} worktrees | 0 selected",
                    id="status-bar",
                )

            if not self.branch_statuses:
                yield Static("No worktrees found for cleanup.", id="empty")
            else:
                # Create list items
                list_items = []
                for i, branch_status in enumerate(self.branch_statuses):
                    list_items.append(self._create_list_item(i, branch_status))

                self.list_view = ListView(*list_items, id="branch-list")
                yield self.list_view

            with Horizontal(id="button-row"):
                yield Button("Confirm Selection", id="confirm", variant="primary")
                yield Button("Cancel", id="cancel", variant="error")

        yield Footer()

    def _create_list_item(self, index: int, branch_status: BranchStatus) -> ListItem:
        """Create a list item for a branch with 3-column layout."""
        # Format path for display
        relative_path = self._format_path_for_display(branch_status.path)

        # Status text
        status_parts = []
        if branch_status.has_uncommitted_changes:
            status_parts.append("[red]uncommitted[/]")
        if branch_status.is_merged:
            status_parts.append("[green]merged[/]")
        if not branch_status.has_remote:
            status_parts.append("[yellow]no remote[/]")
        status_text = ", ".join(status_parts) if status_parts else "[dim]active[/]"

        # Create clickable selection widget
        def handle_selection_click():
            # Toggle selection for this index
            if index in self.selected_rows:
                self.selected_rows.remove(index)
            else:
                self.selected_rows.add(index)

            # Update ListView cursor to this row
            if self.list_view:
                self.list_view.index = index

            self.update_status_bar()
            self._update_selection_display()

        selection_widget = ClickableStatic(
            "[dim][ ][/]",
            id=f"sel-{index}",
            classes="selection-indicator",
            on_click_callback=handle_selection_click,
        )

        content = Horizontal(
            Static(f"{branch_status.branch}\n{relative_path}", classes="branch-info"),
            Static(status_text, classes="status-info"),
            selection_widget,
            classes="branch-row",
        )

        return ListItem(content, id=f"item-{index}")

    def on_mount(self) -> None:
        """Initialize after mounting."""
        self.update_status_bar()

    def on_button_pressed(self, event: Button.Pressed) -> None:
        """Handle button presses."""
        if event.button.id == "confirm":
            self.action_confirm()
        elif event.button.id == "cancel":
            self.action_quit()

    def update_status_bar(self) -> None:
        """Update the status bar with selection count."""
        status_bar = self.query_one("#status-bar", Static)
        status_bar.update(
            f"Found {len(self.branch_statuses)} worktrees | {len(self.selected_rows)} selected"
        )

    def action_toggle_selection(self) -> None:
        """Toggle selection of current row."""
        if not self.list_view:
            return

        cursor_row = self.list_view.index
        if cursor_row in self.selected_rows:
            self.selected_rows.remove(cursor_row)
        else:
            self.selected_rows.add(cursor_row)

        self.update_status_bar()
        self._update_selection_display()

    def action_select_all(self) -> None:
        """Select all rows."""
        self.selected_rows = set(range(len(self.branch_statuses)))
        self.update_status_bar()
        self._update_selection_display()

    def action_select_none(self) -> None:
        """Deselect all rows."""
        self.selected_rows.clear()
        self.update_status_bar()
        self._update_selection_display()

    def action_select_merged(self) -> None:
        """Select only merged branches."""
        self.selected_rows = {
            i
            for i, branch_status in enumerate(self.branch_statuses)
            if branch_status.is_merged
        }
        self.update_status_bar()
        self._update_selection_display()

    def action_select_remoteless(self) -> None:
        """Select only branches without remotes."""
        self.selected_rows = {
            i
            for i, branch_status in enumerate(self.branch_statuses)
            if not branch_status.has_remote
        }
        self.update_status_bar()
        self._update_selection_display()

    def action_cursor_down(self) -> None:
        """Move cursor down."""
        if self.list_view:
            self.list_view.action_cursor_down()

    def action_cursor_up(self) -> None:
        """Move cursor up."""
        if self.list_view:
            self.list_view.action_cursor_up()

    def on_key(self, event) -> None:
        """Handle key presses for quick selection."""
        if event.key.isdigit():
            row_index = int(event.key) - 1
            if 0 <= row_index < len(self.branch_statuses):
                if row_index in self.selected_rows:
                    self.selected_rows.remove(row_index)
                else:
                    self.selected_rows.add(row_index)

                # Move cursor to this row
                if self.list_view:
                    # ListView doesn't have direct move_cursor, but we can use index property
                    self.list_view.index = row_index

                self.update_status_bar()
                self._update_selection_display()
                event.prevent_default()
        elif event.key == "enter":
            # Ensure Enter key triggers confirm action
            self.action_confirm()
            event.prevent_default()

    def _format_path_for_display(self, path) -> str:
        """Format a path for compact display."""
        try:
            # Try to make it relative to current working directory
            current_dir = Path.cwd()
            relative_path = path.relative_to(current_dir)
            return str(relative_path)
        except ValueError:
            # Try to make it relative to home directory
            try:
                home_dir = Path.home()
                relative_path = path.relative_to(home_dir)
                return f"~/{relative_path}"
            except ValueError:
                # Fall back to absolute path
                return str(path)

    def _update_selection_display(self) -> None:
        """Update selection indicators."""
        for i in range(len(self.branch_statuses)):
            try:
                selection_widget = self.query_one(f"#sel-{i}", Static)
                if i in self.selected_rows:
                    selection_widget.update("[bold green][\u2713][/]")
                else:
                    selection_widget.update("[dim][ ][/]")
            except Exception:
                # Ignore errors updating selection indicators
                pass

    def action_confirm(self) -> None:
        """Confirm selection and exit."""
        self.selected_branches = [self.branch_statuses[i] for i in self.selected_rows]
        self.exit()

    def action_quit(self) -> None:
        """Cancel and exit without selection."""
        self.selected_branches = []
        self.exit()


def run_cleanup_tui(branch_statuses: list[BranchStatus]) -> list[BranchStatus]:
    """Run the cleanup TUI and return selected branches."""
    app = CleanupTUI(branch_statuses)
    app.run()
    return app.selected_branches



---
File: /src/autowt/tui/hooks.py
---

"""Textual TUI for interactive hooks installation."""

import json
from pathlib import Path

from textual.app import App, ComposeResult
from textual.binding import Binding
from textual.containers import Horizontal, Vertical
from textual.widgets import Button, Label, RadioButton, RadioSet, Static

from autowt.commands.hooks import HOOKS_CONFIG, _extract_autowt_hooks
from autowt.models import Services


class HooksApp(App):
    """Interactive hooks installation interface."""

    TITLE = "Autowt - Hook Installation"
    CSS_PATH = "hooks.css"
    BINDINGS = [
        Binding("ctrl+s", "install", "Continue & Exit"),
        Binding("enter", "confirm_install", "Continue & Exit"),
        Binding("escape", "cancel", "Cancel & Exit"),
        Binding("q", "cancel", "Quit"),
    ]

    def __init__(self, services: Services):
        super().__init__()
        self.services = services

    def compose(self) -> ComposeResult:
        """Create the UI layout."""
        with Vertical():
            yield Label("Hook Installation", classes="title")
            yield Label("")

            # Show current hook status
            yield Label("Current Hook Status:", classes="section-header")
            yield Static(
                self._get_current_status(), id="status-display", classes="status"
            )
            yield Label("")

            # Installation level selection
            yield Label("Installation Level:", classes="section-header")
            with RadioSet(id="installation-level"):
                yield RadioButton(
                    "User level (affects all projects)",
                    value=True,
                    id="level-user",
                )
                yield RadioButton(
                    "Project level (this project only)",
                    value=False,
                    id="level-project",
                )
                yield RadioButton(
                    "Print to console (manual installation)",
                    value=False,
                    id="level-console",
                )

            yield Label("")

            # Project settings file selection (initially hidden)
            with Vertical(id="project-settings", classes="hidden"):
                yield Label("Project Settings File:", classes="section-header")
                with RadioSet(id="project-file"):
                    yield RadioButton(
                        "settings.json (shared with team, tracked by git)",
                        value=True,
                        id="file-shared",
                    )
                    yield RadioButton(
                        "settings.local.json (local only, not tracked by git)",
                        value=False,
                        id="file-local",
                    )
                yield Label("")

            # Action buttons
            with Horizontal(classes="buttons"):
                yield Button("Continue", id="install", variant="primary")
                yield Button("Cancel", id="cancel")

            yield Label("")
            yield Label(
                "Navigation: Tab to move around • Space to select • Enter/Ctrl+S to continue • Esc/Q to cancel",
                classes="help",
            )

    def _get_current_status(self) -> str:
        """Get current hooks status as formatted text."""
        status_lines = []

        # User level
        user_path = Path.home() / ".claude" / "settings.json"
        user_hooks = self._get_hooks_for_path(user_path)
        status_lines.append("User Level (~/.claude/settings.json):")
        if user_hooks:
            for hook_type, hooks in user_hooks.items():
                status_lines.append(f"  ✓ {hook_type}: {len(hooks)} autowt hook(s)")
        else:
            status_lines.append("  No autowt hooks installed")

        status_lines.append("")

        # Project level
        project_path = Path.cwd() / ".claude" / "settings.json"
        project_hooks = self._get_hooks_for_path(project_path)
        status_lines.append("Project Level (./.claude/settings.json):")
        if project_hooks:
            for hook_type, hooks in project_hooks.items():
                status_lines.append(f"  ✓ {hook_type}: {len(hooks)} autowt hook(s)")
        else:
            status_lines.append("  No autowt hooks installed")

        status_lines.append("")

        # Project local level
        project_local_path = Path.cwd() / ".claude" / "settings.local.json"
        project_local_hooks = self._get_hooks_for_path(project_local_path)
        status_lines.append("Project Local Level (./.claude/settings.local.json):")
        if project_local_hooks:
            for hook_type, hooks in project_local_hooks.items():
                status_lines.append(f"  ✓ {hook_type}: {len(hooks)} autowt hook(s)")
        else:
            status_lines.append("  No autowt hooks installed")

        return "\n".join(status_lines)

    def _get_hooks_for_path(self, settings_path: Path) -> dict:
        """Get autowt hooks for a specific settings file."""
        if not settings_path.exists():
            return {}

        try:
            settings = json.loads(settings_path.read_text())
            return _extract_autowt_hooks(settings)
        except (json.JSONDecodeError, Exception):
            return {}

    def on_radio_set_changed(self, event: RadioSet.Changed) -> None:
        """Handle radio button changes."""
        if event.radio_set.id == "installation-level":
            # Show/hide project settings based on selection
            project_section = self.query_one("#project-settings")
            if event.pressed.id == "level-project":
                project_section.remove_class("hidden")
            else:
                project_section.add_class("hidden")

    def on_button_pressed(self, event: Button.Pressed) -> None:
        """Handle button presses."""
        if event.button.id == "install":
            self._confirm_selections()
        elif event.button.id == "cancel":
            self.exit()

    def action_install(self) -> None:
        """Confirm selections via keyboard shortcut."""
        self._confirm_selections()

    def action_cancel(self) -> None:
        """Cancel installation via keyboard shortcut."""
        self.exit()

    def action_confirm_install(self) -> None:
        """Confirm selections via Enter key."""
        self._confirm_selections()

    def _confirm_selections(self) -> None:
        """Return user selections to main command for final confirmation."""
        # Get installation level
        level_radio = self.query_one("#installation-level", RadioSet)
        level_button = level_radio.pressed_button

        if level_button.id == "level-console":
            # Exit with console instruction
            self.exit(result="console")
            return

        # Determine settings path and description
        if level_button.id == "level-user":
            settings_path = Path.home() / ".claude" / "settings.json"
            description = "User level (affects all projects)"
        else:  # project level
            project_radio = self.query_one("#project-file", RadioSet)
            project_button = project_radio.pressed_button
            filename = (
                "settings.json"
                if project_button.id == "file-shared"
                else "settings.local.json"
            )
            settings_path = Path.cwd() / ".claude" / filename

            if project_button.id == "file-shared":
                description = "Project level (shared with team, tracked by git)"
            else:
                description = "Project level (local only, not tracked by git)"

        # Exit with installation plan
        result = {
            "action": "install",
            "path": settings_path,
            "description": description,
        }
        self.exit(result=result)

    def _install_hooks(self) -> None:
        """Install hooks based on user selections."""
        # Get installation level
        level_radio = self.query_one("#installation-level", RadioSet)
        level_button = level_radio.pressed_button

        if level_button.id == "level-console":
            # Print to console
            self._print_hooks_config()
            return

        # Determine settings path
        if level_button.id == "level-user":
            settings_path = Path.home() / ".claude" / "settings.json"
        else:  # project level
            project_radio = self.query_one("#project-file", RadioSet)
            project_button = project_radio.pressed_button
            filename = (
                "settings.json"
                if project_button.id == "file-shared"
                else "settings.local.json"
            )
            settings_path = Path.cwd() / ".claude" / filename

        # Install hooks
        try:
            self._install_to_path(settings_path)
            self.exit(message=f"Hooks installed successfully to {settings_path}")
        except Exception as e:
            self.exit(message=f"Error installing hooks: {e}")

    def _print_hooks_config(self) -> None:
        """Print hooks configuration to console."""
        print("\nAdd this to your Claude Code settings:")
        print(json.dumps(HOOKS_CONFIG, indent=2))
        self.exit()

    def _install_to_path(self, settings_path: Path) -> None:
        """Install hooks to a specific settings file."""
        # Ensure directory exists
        settings_path.parent.mkdir(parents=True, exist_ok=True)

        # Load existing settings
        existing_settings = {}
        if settings_path.exists():
            try:
                existing_settings = json.loads(settings_path.read_text())
            except json.JSONDecodeError:
                pass

        # Initialize hooks section
        if "hooks" not in existing_settings:
            existing_settings["hooks"] = {}

        # Remove existing autowt hooks
        hooks_removed = 0
        for hook_type in existing_settings["hooks"]:
            original_count = len(existing_settings["hooks"][hook_type])
            existing_settings["hooks"][hook_type] = [
                hook
                for hook in existing_settings["hooks"][hook_type]
                if not hook.get("autowt_hook_id", "").startswith("agent_status_")
            ]
            hooks_removed += original_count - len(existing_settings["hooks"][hook_type])

        # Add current autowt hooks
        hooks_added = 0
        for hook_type, hook_configs in HOOKS_CONFIG["hooks"].items():
            if hook_type not in existing_settings["hooks"]:
                existing_settings["hooks"][hook_type] = []

            for new_hook in hook_configs:
                existing_settings["hooks"][hook_type].append(new_hook)
                hooks_added += 1

        # Write updated settings
        settings_path.write_text(json.dumps(existing_settings, indent=2))



---
File: /src/autowt/__init__.py
---




---
File: /src/autowt/cli_config.py
---

"""CLI configuration integration for autowt.

This module handles the integration between Click CLI arguments and the configuration system.
It provides utilities to convert CLI options to config overrides and initialize the global config.
"""

import logging
from pathlib import Path
from typing import Any

from autowt.config import get_config, load_config
from autowt.models import CleanupMode, TerminalMode

logger = logging.getLogger(__name__)


def create_cli_config_overrides(
    terminal: str | None = None,
    init: str | None = None,
    after_init: str | None = None,
    ignore_same_session: bool | None = None,
    kill: bool | None = None,
    no_kill: bool | None = None,
    mode: str | None = None,
    custom_script: str | None = None,
    **kwargs: Any,
) -> dict[str, Any]:
    """Create configuration overrides from CLI arguments.

    Args:
        terminal: Terminal mode override
        init: Init script override
        after_init: After-init script override
        ignore_same_session: Always new terminal override
        kill: Force kill processes override
        no_kill: Don't kill processes override
        mode: Cleanup mode override
        custom_script: Custom script name override
        **kwargs: Additional CLI arguments to ignore

    Returns:
        Dictionary of configuration overrides
    """
    overrides: dict[str, Any] = {}

    # Terminal configuration overrides
    if terminal is not None:
        overrides.setdefault("terminal", {})["mode"] = terminal

    if ignore_same_session is not None:
        overrides.setdefault("terminal", {})["always_new"] = ignore_same_session

    # Scripts configuration overrides
    if init is not None:
        overrides.setdefault("scripts", {})["init"] = init

    # Handle custom scripts
    if custom_script is not None:
        # This would be used in commands that support --custom-script
        overrides.setdefault("scripts", {}).setdefault(
            "_selected_custom", custom_script
        )

    # Cleanup configuration overrides
    if kill and no_kill:
        raise ValueError("Cannot specify both kill and no_kill")

    if kill:
        overrides.setdefault("cleanup", {})["kill_processes"] = True
    elif no_kill:
        overrides.setdefault("cleanup", {})["kill_processes"] = False

    if mode is not None:
        overrides.setdefault("cleanup", {})["default_mode"] = mode

    return overrides


def initialize_config(cli_overrides: dict[str, Any] | None = None) -> None:
    """Initialize global configuration with CLI overrides.

    This should be called early in the CLI lifecycle to set up configuration
    before any commands run.

    Args:
        cli_overrides: Optional dictionary of CLI argument overrides
    """
    try:
        # Find project directory (current working directory)
        project_dir = Path.cwd()

        # Load configuration with all sources and CLI overrides
        load_config(project_dir=project_dir, cli_overrides=cli_overrides)

        logger.debug("Configuration initialized successfully")

    except Exception as e:
        logger.error(f"Failed to initialize configuration: {e}")
        # Fall back to loading without project dir
        load_config(cli_overrides=cli_overrides)


def get_terminal_mode_from_config() -> TerminalMode:
    """Get the terminal mode from current configuration."""
    config = get_config()
    return config.terminal.mode


def get_init_script_from_config() -> str | None:
    """Get the init script from current configuration."""
    config = get_config()
    return config.scripts.init


def get_cleanup_kill_processes_from_config() -> bool:
    """Get the cleanup kill_processes setting from current configuration."""
    config = get_config()
    return config.cleanup.kill_processes


def get_cleanup_mode_from_config() -> CleanupMode:
    """Get the cleanup default mode from current configuration."""
    config = get_config()
    return config.cleanup.default_mode


def get_always_new_from_config() -> bool:
    """Get the terminal always_new setting from current configuration."""
    config = get_config()
    return config.terminal.always_new


def get_custom_script_from_config(script_name: str) -> str | None:
    """Get a custom script command from current configuration.

    Args:
        script_name: Name of the custom script to retrieve

    Returns:
        The script command string, or None if not found
    """
    config = get_config()
    return config.scripts.custom.get(script_name)


def should_confirm_operation(operation_type: str) -> bool:
    """Check if an operation should require user confirmation.

    Args:
        operation_type: Type of operation ('cleanup_multiple', 'kill_process', 'force_operations')

    Returns:
        True if confirmation is required, False otherwise
    """
    config = get_config()

    if operation_type == "cleanup_multiple":
        return config.confirmations.cleanup_multiple
    elif operation_type == "kill_process":
        return config.confirmations.kill_process
    elif operation_type == "force_operations":
        return config.confirmations.force_operations
    else:
        # Default to requiring confirmation for unknown operations
        return True



---
File: /src/autowt/cli.py
---

"""Main CLI entry point for autowt."""

import logging
import os
import sys
from importlib.metadata import version
from pathlib import Path

import click
from click_aliases import ClickAliasedGroup

from autowt.cli_config import create_cli_config_overrides, initialize_config
from autowt.commands.agents import show_agent_dashboard
from autowt.commands.checkout import (
    checkout_branch,
    find_latest_agent_branch,
    find_waiting_agent_branch,
)
from autowt.commands.cleanup import cleanup_worktrees
from autowt.commands.config import configure_settings, show_config
from autowt.commands.hooks import (
    install_hooks_command,
    remove_hooks_command,
    show_installed_hooks,
)
from autowt.commands.ls import list_worktrees
from autowt.config import get_config
from autowt.global_config import options
from autowt.models import (
    CleanupCommand,
    CleanupMode,
    Services,
    SwitchCommand,
    TerminalMode,
)
from autowt.utils import setup_command_logging


def setup_logging(debug: bool) -> None:
    """Configure logging based on debug flag."""
    level = logging.DEBUG if debug else logging.WARNING
    logging.basicConfig(
        level=level,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    # Setup command logging to show subprocess execution
    setup_command_logging(debug)


def create_services() -> Services:
    """Create and return a Services container with all service instances."""
    return Services.create()


def auto_register_session(services: Services) -> None:
    """Automatically register the current terminal session if possible."""
    try:
        # Only register if we're in a git repository
        repo_path = services.git.find_repo_root()
        if not repo_path:
            return

        # Get current session ID
        session_id = services.terminal.get_current_session_id()
        if not session_id:
            return

        # Get actual git branch name instead of directory name
        worktree_path = Path(os.getcwd())
        branch_name = services.git.get_current_branch(repo_path) or worktree_path.name

        # Only register if not already registered for this branch
        existing_session_id = services.state.get_session_id(repo_path, branch_name)
        if existing_session_id != session_id:
            services.state.set_session_id(repo_path, branch_name, session_id)

    except Exception:
        # Silently fail - session registration should never break the main command
        pass


def is_interactive_terminal() -> bool:
    """Check if running in an interactive terminal.

    Uses the same approach as Click's internal TTY detection.
    This function can be easily mocked in tests for consistent behavior.
    """
    return sys.stdin.isatty()


def _show_shell_config(shell_override: str | None = None) -> None:
    """Show shell integration instructions for the current shell."""
    shell = shell_override or os.getenv("SHELL", "").split("/")[-1]

    print("# Shell Integration for autowt")
    print(
        "# Add this function to your shell configuration for convenient worktree switching:"
    )
    print()

    if shell == "fish":
        print("# Add to ~/.config/fish/config.fish:")
        print("# Example usage: autowt_cd feature-branch")
        print("function autowt_cd")
        print("    eval (autowt $argv --terminal=echo)")
        print("end")
    elif shell in ["bash", "zsh"]:
        config_file = "~/.bashrc" if shell == "bash" else "~/.zshrc"
        print(f"# Add to {config_file}:")
        print("# Example usage: autowt_cd feature-branch")
        print('autowt_cd() { eval "$(autowt "$@" --terminal=echo)"; }')
    elif shell in ["tcsh", "csh"]:
        config_file = "~/.tcshrc" if shell == "tcsh" else "~/.cshrc"
        print(f"# Add to {config_file}:")
        print("# Example usage: autowt_cd feature-branch")
        print("alias autowt_cd 'eval `autowt \\!* --terminal=echo`'")
    elif shell == "nu":
        print("# Add to ~/.config/nushell/config.nu:")
        print("# Example usage: autowt_cd feature-branch")
        print("def autowt_cd [...args] {")
        print(
            "    load-env (autowt ...$args --terminal=echo | parse 'export {name}={value}' | transpose -r)"
        )
        print("}")
        print()
        print(
            "# Note: nushell requires different syntax. You may need to adjust based on output format."
        )
    elif shell in ["oil", "osh"]:
        print("# Add to ~/.config/oil/oshrc:")
        print("# Example usage: autowt_cd feature-branch")
        print('autowt_cd() { eval "$(autowt "$@" --terminal=echo)"; }')
    elif shell == "elvish":
        print("# Add to ~/.config/elvish/rc.elv:")
        print("# Example usage: autowt_cd feature-branch")
        print("fn autowt_cd {|@args|")
        print("    eval (autowt $@args --terminal=echo)")
        print("}")
    else:
        # Comprehensive fallback for unknown shells
        print(
            f"# Shell '{shell}' not specifically supported. Here are options for common shells:"
        )
        print()
        print("# POSIX-compatible shells (bash, zsh, dash, ash, etc.):")
        print("# Add to your shell's config file (e.g., ~/.bashrc, ~/.zshrc):")
        print("# Example usage: autowt_cd feature-branch")
        print('autowt_cd() { eval "$(autowt "$@" --terminal=echo)"; }')
        print()
        print("# Fish shell - add to ~/.config/fish/config.fish:")
        print("# Example usage: autowt_cd feature-branch")
        print("function autowt_cd")
        print("    eval (autowt $argv --terminal=echo)")
        print("end")
        print()
        print("# C shell variants (csh, tcsh) - add to ~/.cshrc or ~/.tcshrc:")
        print("# Example usage: autowt_cd feature-branch")
        print("alias autowt_cd 'eval `autowt \\!* --terminal=echo`'")
        print()
        print("# For other shells, adapt the above patterns or use manual eval:")
        print('# eval "$(autowt branch-name --terminal=echo)"')


# Custom Group class that handles unknown commands as branch names and supports aliases
class AutowtGroup(ClickAliasedGroup):
    def get_command(self, ctx, cmd_name):
        # First, try to get the command normally
        rv = super().get_command(ctx, cmd_name)
        if rv is not None:
            return rv

        # If command not found, create a dynamic command that treats it as a branch name
        def branch_command(**kwargs):
            # Set global options for dynamic branch commands
            options.auto_confirm = kwargs.get("auto_confirm", kwargs.get("yes", False))
            options.debug = kwargs.get("debug", False)

            setup_logging(kwargs.get("debug", False))

            # Create CLI overrides for this specific command
            cli_overrides = create_cli_config_overrides(
                terminal=kwargs.get("terminal"),
                init=kwargs.get("init"),
                after_init=kwargs.get("after_init"),
                ignore_same_session=kwargs.get("ignore_same_session", False),
            )

            # Initialize configuration with CLI overrides
            initialize_config(cli_overrides)

            # Get terminal mode from configuration
            config = get_config()
            terminal_mode = (
                config.terminal.mode
                if not kwargs.get("terminal")
                else TerminalMode(kwargs["terminal"])
            )

            services = create_services()
            auto_register_session(services)

            # Create and execute SwitchCommand
            switch_cmd = SwitchCommand(
                branch=cmd_name,
                terminal_mode=terminal_mode,
                init_script=config.scripts.init,
                after_init=kwargs.get("after_init"),
                ignore_same_session=config.terminal.always_new
                or kwargs.get("ignore_same_session", False),
                auto_confirm=kwargs.get("auto_confirm", kwargs.get("yes", False)),
                debug=kwargs.get("debug", False),
            )
            checkout_branch(switch_cmd, services)

        # Create a new command with the same options as switch
        branch_cmd = click.Command(
            name=cmd_name,
            callback=branch_command,
            params=[
                click.Option(
                    ["--terminal"],
                    type=click.Choice(["tab", "window", "inplace", "echo"]),
                    help="How to open the worktree terminal",
                ),
                click.Option(
                    ["-y", "--yes"],
                    "auto_confirm",
                    is_flag=True,
                    help="Automatically confirm all prompts",
                ),
                click.Option(["--debug"], is_flag=True, help="Enable debug logging"),
                click.Option(
                    ["--init"],
                    help="Init script to run in the new terminal",
                ),
                click.Option(
                    ["--after-init"],
                    help="Command to run after init script completes",
                ),
                click.Option(
                    ["--ignore-same-session"],
                    is_flag=True,
                    help="Always create new terminal, ignore existing sessions",
                ),
            ],
            help=f"Switch to or create a worktree for branch '{cmd_name}'",
        )
        return branch_cmd


@click.group(
    cls=AutowtGroup,
    invoke_without_command=True,
    context_settings={"help_option_names": ["-h", "--help"]},
)
@click.option(
    "-y",
    "--yes",
    "auto_confirm",
    is_flag=True,
    help="Automatically confirm all prompts",
)
@click.option("--debug", is_flag=True, help="Enable debug logging")
@click.option(
    "--version",
    is_flag=True,
    expose_value=False,
    is_eager=True,
    callback=lambda ctx, param, value: (
        click.echo(version("autowt")) if value else None,
        ctx.exit() if value else None,
    ),
    help="Show version and exit",
)
@click.pass_context
def main(ctx: click.Context, auto_confirm: bool, debug: bool) -> None:
    """Git worktree manager.

    Use subcommands like 'ls', 'cleanup', 'config', or 'switch'.
    Or simply run 'autowt <branch>' to switch to a branch.
    """
    # Set global options
    options.auto_confirm = auto_confirm
    options.debug = debug

    setup_logging(debug)

    # Initialize configuration system early
    initialize_config()

    # If no subcommand was invoked, show list
    if ctx.invoked_subcommand is None:
        services = create_services()
        auto_register_session(services)
        list_worktrees(services)


@main.command(
    "register-session-for-path",
    hidden=True,
    context_settings={"help_option_names": ["-h", "--help"]},
)
@click.option("--debug", is_flag=True, help="Enable debug logging")
def register_session_for_path(debug: bool) -> None:
    """Register the current terminal session for the current working directory."""
    setup_logging(debug)
    services = create_services()

    # Get current session ID
    session_id = services.terminal.get_current_session_id()
    if session_id:
        # Get actual git branch name instead of directory name
        worktree_path = Path(os.getcwd())
        repo_path = services.git.find_repo_root()
        branch_name = (
            services.git.get_current_branch(repo_path) or worktree_path.name
            if repo_path
            else worktree_path.name
        )

        # Set session ID for this repo/branch
        services.state.set_session_id(repo_path, branch_name, session_id)
        print(
            f"Registered session {session_id} for branch {branch_name} (path: {worktree_path})"
        )
    else:
        print("Could not detect current session ID")


@main.command(
    aliases=["list"], context_settings={"help_option_names": ["-h", "--help"]}
)
@click.option("--debug", is_flag=True, help="Enable debug logging")
def ls(debug: bool) -> None:
    """List all worktrees and their status."""
    setup_logging(debug)
    services = create_services()
    auto_register_session(services)
    list_worktrees(services, debug=debug)


@main.command(context_settings={"help_option_names": ["-h", "--help"]})
@click.option(
    "--mode",
    type=click.Choice(["all", "remoteless", "merged", "interactive"]),
    default=None,
    help="Cleanup mode (default: interactive in TTY, required otherwise)",
)
@click.option(
    "--dry-run",
    is_flag=True,
    help="Show what would be removed without actually removing",
)
@click.option("-y", "--yes", is_flag=True, help="Auto-confirm all prompts")
@click.option(
    "--force", is_flag=True, help="Force remove worktrees with modified files"
)
@click.option(
    "--kill", is_flag=True, help="Force kill processes in worktrees (override config)"
)
@click.option(
    "--no-kill",
    is_flag=True,
    help="Skip killing processes in worktrees (override config)",
)
@click.option("--debug", is_flag=True, help="Enable debug logging")
def cleanup(
    mode: str | None,
    dry_run: bool,
    yes: bool,
    force: bool,
    kill: bool,
    no_kill: bool,
    debug: bool,
) -> None:
    """Clean up merged or remoteless worktrees."""
    # Validate mutually exclusive options
    if kill and no_kill:
        raise click.UsageError("Cannot specify both --kill and --no-kill")

    setup_logging(debug)

    # Create CLI overrides for cleanup command
    cli_overrides = create_cli_config_overrides(
        mode=mode,
        kill=kill,
        no_kill=no_kill,
    )

    # Initialize configuration with CLI overrides
    initialize_config(cli_overrides)

    # Get configuration values
    config = get_config()

    # Use configured mode if not specified
    if mode is None:
        if is_interactive_terminal():
            mode = config.cleanup.default_mode.value
        else:
            # Non-interactive environment (script, CI, etc.) - require explicit mode
            raise click.UsageError(
                "No TTY detected. Please specify --mode explicitly when running in scripts or CI. "
                "Available modes: all, remoteless, merged, interactive"
            )

    services = create_services()
    auto_register_session(services)

    # Determine kill_processes from configuration or override
    kill_processes = None
    if kill:
        kill_processes = True
    elif no_kill:
        kill_processes = False
    # Note: When no CLI flags are specified, pass None to allow prompting
    # The cleanup logic will use config.cleanup.kill_processes for the default

    cleanup_cmd = CleanupCommand(
        mode=CleanupMode(mode),
        dry_run=dry_run,
        auto_confirm=yes,
        force=force,
        debug=debug,
        kill_processes=kill_processes,
    )
    cleanup_worktrees(cleanup_cmd, services)


@main.command(
    aliases=["configure", "settings"],
    context_settings={"help_option_names": ["-h", "--help"]},
)
@click.option("--debug", is_flag=True, help="Enable debug logging")
@click.option("--show", is_flag=True, help="Show current configuration values")
def config(debug: bool, show: bool) -> None:
    """Configure autowt settings using interactive TUI."""
    setup_logging(debug)
    services = create_services()
    auto_register_session(services)

    if show:
        show_config(services)
    else:
        configure_settings(services)


@main.command(context_settings={"help_option_names": ["-h", "--help"]})
@click.option("--debug", is_flag=True, help="Enable debug logging")
@click.option(
    "--shell",
    type=click.Choice(["bash", "zsh", "fish", "tcsh", "csh", "nu", "oil", "elvish"]),
    help="Override shell detection (useful for generating docs)",
)
def shellconfig(debug: bool, shell: str | None) -> None:
    """Show shell integration instructions for your current shell."""
    setup_logging(debug)
    _show_shell_config(shell)


@main.command(context_settings={"help_option_names": ["-h", "--help"]})
@click.argument("branch", required=False)
@click.option(
    "--terminal",
    type=click.Choice(["tab", "window", "inplace", "echo"]),
    help="How to open the worktree terminal",
)
@click.option(
    "--init",
    help="Init script to run in the new terminal",
)
@click.option(
    "--after-init",
    help="Command to run after init script completes",
)
@click.option(
    "--ignore-same-session",
    is_flag=True,
    help="Always create new terminal, ignore existing sessions",
)
@click.option(
    "-y", "--yes", "auto_confirm", is_flag=True, help="Auto-confirm all prompts"
)
@click.option(
    "--waiting",
    is_flag=True,
    help="Switch to first agent waiting for input",
)
@click.option(
    "--latest",
    is_flag=True,
    help="Switch to most recently active agent",
)
@click.option("--debug", is_flag=True, help="Enable debug logging")
def switch(
    branch: str | None,
    terminal: str | None,
    init: str | None,
    after_init: str | None,
    ignore_same_session: bool,
    auto_confirm: bool,
    waiting: bool,
    latest: bool,
    debug: bool,
) -> None:
    """Switch to or create a worktree for the specified branch."""
    setup_logging(debug)

    # Validate mutually exclusive options
    option_count = sum([bool(branch), waiting, latest])
    if option_count != 1:
        raise click.UsageError(
            "Must specify exactly one of: branch name, --waiting, or --latest"
        )

    services = create_services()
    auto_register_session(services)

    # Determine target branch
    target_branch = branch
    if waiting:
        target_branch = find_waiting_agent_branch(services)
        if not target_branch:
            return
    elif latest:
        target_branch = find_latest_agent_branch(services)
        if not target_branch:
            return

    # Create CLI overrides for switch command (now includes all options)
    cli_overrides = create_cli_config_overrides(
        terminal=terminal,
        init=init,
        after_init=after_init,
        ignore_same_session=ignore_same_session,
    )

    # Initialize configuration with CLI overrides
    initialize_config(cli_overrides)

    # Get configuration values
    config = get_config()
    terminal_mode = config.terminal.mode if not terminal else TerminalMode(terminal)

    # Create and execute SwitchCommand with full option support
    switch_cmd = SwitchCommand(
        branch=target_branch,
        terminal_mode=terminal_mode,
        init_script=config.scripts.init,
        after_init=after_init,
        ignore_same_session=config.terminal.always_new or ignore_same_session,
        auto_confirm=auto_confirm,
        debug=debug,
    )
    checkout_branch(switch_cmd, services)


@main.command(context_settings={"help_option_names": ["-h", "--help"]})
@click.option("--debug", is_flag=True, help="Enable debug logging")
def agents(debug: bool) -> None:
    """Show live agent monitoring dashboard."""
    setup_logging(debug)
    services = create_services()
    auto_register_session(services)

    result = show_agent_dashboard(services)

    # Handle dashboard exit actions
    if result and result.get("action") == "switch":
        branch = result.get("branch")
        if branch:
            config = get_config()
            switch_cmd = SwitchCommand(
                branch=branch,
                terminal_mode=config.terminal.mode,
                init_script=config.scripts.init,
            )
            checkout_branch(switch_cmd, services)


@main.command(context_settings={"help_option_names": ["-h", "--help"]})
@click.option(
    "--user", is_flag=True, help="Install hooks at user level (affects all projects)"
)
@click.option(
    "--project", is_flag=True, help="Install hooks at project level (this project only)"
)
@click.option(
    "--dry-run",
    is_flag=True,
    help="Show what would be installed without making changes",
)
@click.option(
    "--show",
    is_flag=True,
    help="Show currently installed autowt hooks at user and project levels",
)
@click.option(
    "--remove",
    is_flag=True,
    help="Remove autowt hooks instead of installing them",
)
@click.option("--debug", is_flag=True, help="Enable debug logging")
def hooks_install(
    user: bool, project: bool, dry_run: bool, show: bool, remove: bool, debug: bool
) -> None:
    """Install Claude Code hooks for agent monitoring."""
    if user and project:
        raise click.UsageError("Cannot specify both --user and --project")

    if show and (user or project or dry_run or remove):
        raise click.UsageError("--show cannot be combined with other options")

    if remove and not (user or project):
        raise click.UsageError("--remove requires either --user or --project")

    level = None
    if user:
        level = "user"
    elif project:
        level = "project"

    setup_logging(debug)
    services = create_services()

    if show:
        show_installed_hooks(services)
    elif remove:
        remove_hooks_command(level, services, dry_run=dry_run)
    else:
        install_hooks_command(level, services, dry_run=dry_run)


if __name__ == "__main__":
    main()



---
File: /src/autowt/config.py
---

"""Comprehensive configuration system for autowt.

This module provides type-safe configuration management with support for:
- Global and project configuration files
- Environment variable overrides
- Command line argument overrides
- Proper precedence order and cascading
"""

import logging
import os
import platform
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

import toml

from autowt.models import CleanupMode, TerminalMode

logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class TerminalConfig:
    """Terminal management configuration."""

    mode: TerminalMode = TerminalMode.TAB
    always_new: bool = False
    program: str | None = None


@dataclass(frozen=True)
class BranchSanitizationConfig:
    """Branch name sanitization rules."""

    replace_chars: str = "/:#@^~"
    max_length: int = 255
    lowercase: bool = False


@dataclass(frozen=True)
class WorktreeConfig:
    """Worktree management configuration."""

    directory_pattern: str = "../{repo_name}-worktrees/{branch}"
    max_worktrees: int | None = None
    auto_fetch: bool = True
    default_remote: str = "origin"
    branch_sanitization: BranchSanitizationConfig = field(
        default_factory=BranchSanitizationConfig
    )


@dataclass(frozen=True)
class CleanupConfig:
    """Cleanup behavior configuration."""

    kill_processes: bool = True
    kill_process_timeout: int = 10
    default_mode: CleanupMode = CleanupMode.INTERACTIVE


@dataclass(frozen=True)
class ScriptsConfig:
    """Init scripts and custom commands."""

    init: str | None = None
    custom: dict[str, str] = field(default_factory=dict)


@dataclass(frozen=True)
class ConfirmationsConfig:
    """User confirmation settings."""

    cleanup_multiple: bool = True
    kill_process: bool = True
    force_operations: bool = True


@dataclass(frozen=True)
class Config:
    """Complete autowt configuration."""

    terminal: TerminalConfig = field(default_factory=TerminalConfig)
    worktree: WorktreeConfig = field(default_factory=WorktreeConfig)
    cleanup: CleanupConfig = field(default_factory=CleanupConfig)
    scripts: ScriptsConfig = field(default_factory=ScriptsConfig)
    confirmations: ConfirmationsConfig = field(default_factory=ConfirmationsConfig)

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "Config":
        """Create configuration from dictionary with proper type conversion."""
        terminal_data = data.get("terminal", {})
        worktree_data = data.get("worktree", {})
        cleanup_data = data.get("cleanup", {})
        scripts_data = data.get("scripts", {})
        confirmations_data = data.get("confirmations", {})

        # Handle nested configurations
        branch_sanitization_data = worktree_data.get("branch_sanitization", {})
        branch_sanitization = BranchSanitizationConfig(
            replace_chars=branch_sanitization_data.get("replace_chars", "/:#@^~"),
            max_length=branch_sanitization_data.get("max_length", 255),
            lowercase=branch_sanitization_data.get("lowercase", False),
        )

        worktree_config = WorktreeConfig(
            directory_pattern=worktree_data.get(
                "directory_pattern", "../{repo_name}-worktrees/{branch}"
            ),
            max_worktrees=worktree_data.get("max_worktrees"),
            auto_fetch=worktree_data.get("auto_fetch", True),
            default_remote=worktree_data.get("default_remote", "origin"),
            branch_sanitization=branch_sanitization,
        )

        # Handle case where terminal_data might be a string (legacy compatibility)
        if isinstance(terminal_data, str):
            terminal_config = TerminalConfig(
                mode=TerminalMode(terminal_data),
                always_new=False,
                program=None,
            )
        else:
            terminal_config = TerminalConfig(
                mode=TerminalMode(terminal_data.get("mode", "tab")),
                always_new=terminal_data.get("always_new", False),
                program=terminal_data.get("program"),
            )

        cleanup_config = CleanupConfig(
            kill_processes=cleanup_data.get("kill_processes", True),
            kill_process_timeout=cleanup_data.get("kill_process_timeout", 10),
            default_mode=CleanupMode(cleanup_data.get("default_mode", "interactive")),
        )

        scripts_config = ScriptsConfig(
            init=scripts_data.get("init"),
            custom=scripts_data.get("custom", {}),
        )

        confirmations_config = ConfirmationsConfig(
            cleanup_multiple=confirmations_data.get("cleanup_multiple", True),
            kill_process=confirmations_data.get("kill_process", True),
            force_operations=confirmations_data.get("force_operations", True),
        )

        return cls(
            terminal=terminal_config,
            worktree=worktree_config,
            cleanup=cleanup_config,
            scripts=scripts_config,
            confirmations=confirmations_config,
        )

    def to_dict(self) -> dict[str, Any]:
        """Convert configuration to dictionary for serialization."""
        return {
            "terminal": {
                "mode": self.terminal.mode.value,
                "always_new": self.terminal.always_new,
                "program": self.terminal.program,
            },
            "worktree": {
                "directory_pattern": self.worktree.directory_pattern,
                "max_worktrees": self.worktree.max_worktrees,
                "auto_fetch": self.worktree.auto_fetch,
                "default_remote": self.worktree.default_remote,
                "branch_sanitization": {
                    "replace_chars": self.worktree.branch_sanitization.replace_chars,
                    "max_length": self.worktree.branch_sanitization.max_length,
                    "lowercase": self.worktree.branch_sanitization.lowercase,
                },
            },
            "cleanup": {
                "kill_processes": self.cleanup.kill_processes,
                "kill_process_timeout": self.cleanup.kill_process_timeout,
                "default_mode": self.cleanup.default_mode.value,
            },
            "scripts": {
                "init": self.scripts.init,
                "custom": self.scripts.custom,
            },
            "confirmations": {
                "cleanup_multiple": self.confirmations.cleanup_multiple,
                "kill_process": self.confirmations.kill_process,
                "force_operations": self.confirmations.force_operations,
            },
        }


class ConfigLoader:
    """Handles loading and merging configuration from multiple sources."""

    def __init__(self, app_dir: Path | None = None):
        """Initialize configuration loader."""
        if app_dir is None:
            app_dir = self._get_default_app_dir()

        self.app_dir = app_dir
        self.global_config_file = app_dir / "config.toml"

        # Ensure app directory exists
        self.app_dir.mkdir(parents=True, exist_ok=True)
        logger.debug(f"Config loader initialized with app dir: {self.app_dir}")

    def _get_default_app_dir(self) -> Path:
        """Get the default application directory based on platform."""
        system = platform.system()
        if system == "Darwin":  # macOS
            return Path.home() / "Library" / "Application Support" / "autowt"
        elif system == "Linux":
            # Follow XDG Base Directory Specification
            xdg_config = Path(os.getenv("XDG_CONFIG_HOME", Path.home() / ".config"))
            return xdg_config / "autowt"
        else:
            # Windows or other
            return Path.home() / ".autowt"

    def load_config(
        self,
        project_dir: Path | None = None,
        cli_overrides: dict[str, Any] | None = None,
    ) -> Config:
        """Load configuration with proper precedence order.

        Precedence (later overrides earlier):
        1. Built-in defaults
        2. Global config file
        3. Project config file
        4. Environment variables
        5. CLI overrides
        """
        logger.debug("Loading configuration with cascading precedence")

        # 1. Start with defaults
        config_data: dict[str, Any] = {}

        # 2. Load global config file
        global_data = self._load_global_config()
        config_data = self._merge_dicts(config_data, global_data)

        # 3. Load project config file
        if project_dir:
            project_data = self._load_project_config(project_dir)
            config_data = self._merge_dicts(config_data, project_data)

        # 4. Apply environment variables
        env_data = self._load_env_vars()
        config_data = self._merge_dicts(config_data, env_data)

        # 5. Apply CLI overrides
        if cli_overrides:
            config_data = self._merge_dicts(config_data, cli_overrides)

        # Convert to Config object
        return Config.from_dict(config_data)

    def _load_global_config(self) -> dict[str, Any]:
        """Load global configuration file."""
        if not self.global_config_file.exists():
            logger.debug("No global config file found")
            return {}

        try:
            data = toml.load(self.global_config_file)
            logger.debug("Global configuration loaded successfully")
            return data
        except Exception as e:
            logger.error(f"Failed to load global configuration: {e}")
            return {}

    def _load_project_config(self, project_dir: Path) -> dict[str, Any]:
        """Load project-specific configuration."""
        config_files = [project_dir / "autowt.toml", project_dir / ".autowt.toml"]

        for config_file in config_files:
            if config_file.exists():
                logger.debug(f"Found project config file: {config_file}")
                try:
                    data = toml.load(config_file)
                    logger.debug("Project configuration loaded successfully")
                    return data
                except Exception as e:
                    logger.error(
                        f"Failed to load project configuration from {config_file}: {e}"
                    )
                    continue

        logger.debug("No project config file found")
        return {}

    def _load_env_vars(self) -> dict[str, Any]:
        """Load configuration from environment variables with AUTOWT_ prefix."""
        config_data: dict[str, Any] = {}

        # Define the mapping from environment variable suffixes to config paths
        # This handles field names with underscores correctly
        env_mapping = {
            "TERMINAL_MODE": ["terminal", "mode"],
            "TERMINAL_ALWAYS_NEW": ["terminal", "always_new"],
            "TERMINAL_PROGRAM": ["terminal", "program"],
            "WORKTREE_DIRECTORY_PATTERN": ["worktree", "directory_pattern"],
            "WORKTREE_MAX_WORKTREES": ["worktree", "max_worktrees"],
            "WORKTREE_AUTO_FETCH": ["worktree", "auto_fetch"],
            "WORKTREE_DEFAULT_REMOTE": ["worktree", "default_remote"],
            "WORKTREE_BRANCH_SANITIZATION_REPLACE_CHARS": [
                "worktree",
                "branch_sanitization",
                "replace_chars",
            ],
            "WORKTREE_BRANCH_SANITIZATION_MAX_LENGTH": [
                "worktree",
                "branch_sanitization",
                "max_length",
            ],
            "WORKTREE_BRANCH_SANITIZATION_LOWERCASE": [
                "worktree",
                "branch_sanitization",
                "lowercase",
            ],
            "CLEANUP_KILL_PROCESSES": ["cleanup", "kill_processes"],
            "CLEANUP_KILL_PROCESS_TIMEOUT": ["cleanup", "kill_process_timeout"],
            "CLEANUP_DEFAULT_MODE": ["cleanup", "default_mode"],
            "SCRIPTS_INIT": ["scripts", "init"],
            "CONFIRMATIONS_CLEANUP_MULTIPLE": ["confirmations", "cleanup_multiple"],
            "CONFIRMATIONS_KILL_PROCESS": ["confirmations", "kill_process"],
            "CONFIRMATIONS_FORCE_OPERATIONS": ["confirmations", "force_operations"],
        }

        for key, value in os.environ.items():
            if not key.startswith("AUTOWT_"):
                continue

            # Get the suffix after AUTOWT_
            suffix = key[7:]  # Remove AUTOWT_ prefix

            # Look up the config path
            if suffix in env_mapping:
                path_parts = env_mapping[suffix]

                # Convert value to appropriate type
                converted_value = self._convert_env_value(value)

                # Set nested value in config_data
                self._set_nested_value(config_data, path_parts, converted_value)
            else:
                logger.warning(f"Unknown environment variable: {key}")

        if config_data:
            logger.debug(
                f"Loaded configuration from {len([k for k in os.environ if k.startswith('AUTOWT_')])} environment variables"
            )

        return config_data

    def _convert_env_value(self, value: str) -> Any:
        """Convert environment variable string to appropriate Python type."""
        # Boolean conversion
        if value.lower() in ("true", "yes", "1", "on"):
            return True
        elif value.lower() in ("false", "no", "0", "off"):
            return False

        # Integer conversion
        try:
            return int(value)
        except ValueError:
            pass

        # Return as string
        return value

    def _set_nested_value(
        self, data: dict[str, Any], path: list[str], value: Any
    ) -> None:
        """Set a nested value in a dictionary using a path list."""
        current = data
        for key in path[:-1]:
            if key not in current:
                current[key] = {}
            current = current[key]
        current[path[-1]] = value

    def _merge_dicts(
        self, base: dict[str, Any], override: dict[str, Any]
    ) -> dict[str, Any]:
        """Recursively merge two dictionaries, with override taking precedence."""
        result = base.copy()

        for key, value in override.items():
            if (
                key in result
                and isinstance(result[key], dict)
                and isinstance(value, dict)
            ):
                result[key] = self._merge_dicts(result[key], value)
            else:
                result[key] = value

        return result

    def save_config(self, config: Config) -> None:
        """Save configuration to global config file."""
        logger.debug("Saving global configuration")

        try:
            with open(self.global_config_file, "w") as f:
                toml.dump(config.to_dict(), f)
            logger.debug("Configuration saved successfully")
        except Exception as e:
            logger.error(f"Failed to save configuration: {e}")
            raise


# Global configuration instance
_config: Config | None = None
_config_loader: ConfigLoader | None = None


def get_config() -> Config:
    """Get the current global configuration.

    Raises RuntimeError if configuration hasn't been loaded yet.
    """
    if _config is None:
        raise RuntimeError("Configuration not initialized. Call load_config() first.")
    return _config


def get_config_loader() -> ConfigLoader:
    """Get the global configuration loader instance."""
    global _config_loader
    if _config_loader is None:
        _config_loader = ConfigLoader()
    return _config_loader


def load_config(
    project_dir: Path | None = None, cli_overrides: dict[str, Any] | None = None
) -> Config:
    """Load configuration and set it globally.

    Args:
        project_dir: Optional project directory for project-specific config
        cli_overrides: Optional dictionary of CLI argument overrides

    Returns:
        The loaded configuration object
    """
    global _config

    loader = get_config_loader()
    _config = loader.load_config(project_dir=project_dir, cli_overrides=cli_overrides)

    logger.debug("Global configuration loaded and set")
    return _config


def set_config(config: Config) -> None:
    """Set the global configuration (mainly for testing)."""
    global _config
    _config = config


def save_config() -> None:
    """Save the current global configuration."""
    if _config is None:
        raise RuntimeError("No configuration to save")

    loader = get_config_loader()
    loader.save_config(_config)



---
File: /src/autowt/console.py
---

"""Styled console output for autowt using rich."""

from rich.console import Console
from rich.theme import Theme

from autowt.global_config import options

# Theme for consistent styling across autowt
AUTOWT_THEME = Theme(
    {
        "command": "dim grey50",  # Command strings
        "output": "dim grey50",  # Raw command output
        "prompt": "bold cyan",  # User prompts
        "section": "bold white",  # Section headers
        "success": "green",  # Success messages
        "warning": "yellow",  # Warnings
        "error": "bold red",  # Errors
        "info": "dim cyan",  # General info
    }
)

# Single console instance for the entire application
console = Console(theme=AUTOWT_THEME)


def print_command(cmd_str: str) -> None:
    """Print a command string in gray styling."""
    if not options.suppress_rich_output:
        console.print(f"> {cmd_str}", style="command")


def print_section(text: str) -> None:
    """Print a section header in bold."""
    if not options.suppress_rich_output:
        console.print(text, style="section")


def print_prompt(text: str) -> None:
    """Print a prompt in bold cyan."""
    if not options.suppress_rich_output:
        console.print(text, style="prompt")


def print_success(text: str) -> None:
    """Print a success message in green."""
    if not options.suppress_rich_output:
        console.print(text, style="success")


def print_warning(text: str) -> None:
    """Print a warning message in yellow."""
    if not options.suppress_rich_output:
        console.print(text, style="warning")


def print_error(text: str) -> None:
    """Print an error message in bold red."""
    if not options.suppress_rich_output:
        console.print(text, style="error")


def print_info(text: str) -> None:
    """Print an info message in dim cyan."""
    if not options.suppress_rich_output:
        console.print(text, style="info")


def print_output(text: str) -> None:
    """Print raw command output in gray."""
    if not options.suppress_rich_output:
        console.print(text, style="output")


def print_plain(text: str) -> None:
    """Print plain text without styling."""
    if not options.suppress_rich_output:
        console.print(text)



---
File: /src/autowt/global_config.py
---

"""Global application configuration and options."""

from dataclasses import dataclass


@dataclass
class GlobalOptions:
    """Global options that affect application behavior."""

    auto_confirm: bool = False  # -y flag: automatically confirm all prompts
    debug: bool = False  # --debug flag
    suppress_rich_output: bool = False  # Suppress all rich output for echo mode


# Global instance that gets set by CLI
options = GlobalOptions()



---
File: /src/autowt/models.py
---

"""Data models for autowt state and configuration."""

import json
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from autowt.services.agent import AgentService
    from autowt.services.git import GitService
    from autowt.services.process import ProcessService
    from autowt.services.state import StateService
    from autowt.services.terminal import TerminalService


class TerminalMode(Enum):
    """Terminal switching modes."""

    TAB = "tab"
    WINDOW = "window"
    INPLACE = "inplace"
    ECHO = "echo"


class CleanupMode(Enum):
    """Cleanup selection modes."""

    ALL = "all"
    REMOTELESS = "remoteless"
    MERGED = "merged"
    INTERACTIVE = "interactive"


@dataclass
class WorktreeInfo:
    """Information about a single worktree."""

    branch: str
    path: Path
    is_current: bool = False
    is_primary: bool = False


@dataclass
class AgentStatus:
    """Status of a Claude Code agent in a worktree."""

    status: str  # "waiting", "working", "idle", "notification", "subagent_complete"
    last_activity: str  # ISO 8601 timestamp
    tool: str | None = None  # Current/last tool being used

    @classmethod
    def from_file(cls, status_file: Path) -> "AgentStatus | None":
        """Load agent status from .claude/autowt/status file."""
        if not status_file.exists():
            return None
        try:
            data = json.loads(status_file.read_text())
            return cls(
                status=data["status"],
                last_activity=data["last_activity"],
                tool=data.get("tool"),
            )
        except (json.JSONDecodeError, KeyError, FileNotFoundError):
            return None

    @property
    def status_indicator(self) -> str:
        """Get single-character status indicator for display."""
        return {
            "waiting": "C?",
            "processing": "C~",
            "working": "C…",
            "subagent_complete": "C*",
        }.get(self.status, "C?")


@dataclass
class WorktreeWithAgent(WorktreeInfo):
    """Extends WorktreeInfo with agent status."""

    agent_status: AgentStatus | None = None
    has_active_session: bool = False


@dataclass
class BranchStatus:
    """Status information for cleanup decisions."""

    branch: str
    has_remote: bool
    is_merged: bool
    is_identical: bool  # True if branch has no unique commits vs main
    path: Path
    has_uncommitted_changes: bool = False


@dataclass
class ProjectScriptsConfig:
    """Project-specific scripts configuration."""

    init: str | None = None
    custom: dict[str, str] | None = None

    @classmethod
    def from_dict(cls, data: dict) -> "ProjectScriptsConfig":
        """Create project scripts configuration from dictionary."""
        return cls(
            init=data.get("init"),
            custom=data.get("custom"),
        )

    def to_dict(self) -> dict:
        """Convert project scripts configuration to dictionary."""
        result = {}
        if self.init is not None:
            result["init"] = self.init
        if self.custom is not None:
            result["custom"] = self.custom
        return result


@dataclass
class ProjectConfig:
    """Project-specific configuration."""

    scripts: ProjectScriptsConfig | None = None

    @classmethod
    def from_dict(cls, data: dict) -> "ProjectConfig":
        """Create project configuration from dictionary."""
        scripts_data = data.get("scripts", {})
        scripts = ProjectScriptsConfig.from_dict(scripts_data) if scripts_data else None
        return cls(
            scripts=scripts,
        )

    def to_dict(self) -> dict:
        """Convert project configuration to dictionary."""
        result = {}
        if self.scripts is not None:
            scripts_dict = self.scripts.to_dict()
            if scripts_dict:
                result["scripts"] = scripts_dict
        return result

    @property
    def init(self) -> str | None:
        """Get init script from scripts configuration."""
        return self.scripts.init if self.scripts else None


@dataclass
class ProcessInfo:
    """Information about a running process."""

    pid: int
    command: str
    working_dir: Path


@dataclass
class Services:
    """Container for all application services."""

    state: "StateService"
    git: "GitService"
    terminal: "TerminalService"
    process: "ProcessService"
    agent: "AgentService"

    @classmethod
    def create(cls) -> "Services":
        """Create a new Services container with all services initialized."""
        # Import here to avoid circular imports
        from autowt.services.agent import AgentService  # noqa: PLC0415
        from autowt.services.git import GitService  # noqa: PLC0415
        from autowt.services.process import ProcessService  # noqa: PLC0415
        from autowt.services.state import StateService  # noqa: PLC0415
        from autowt.services.terminal import TerminalService  # noqa: PLC0415

        state_service = StateService()
        return cls(
            state=state_service,
            git=GitService(),
            terminal=TerminalService(state_service),
            process=ProcessService(),
            agent=AgentService(),
        )


@dataclass
class SwitchCommand:
    """Encapsulates all parameters for switching to/creating a worktree."""

    branch: str
    terminal_mode: TerminalMode | None = None
    init_script: str | None = None
    after_init: str | None = None
    ignore_same_session: bool = False
    auto_confirm: bool = False
    debug: bool = False


@dataclass
class CleanupCommand:
    """Encapsulates all parameters for cleaning up worktrees."""

    mode: CleanupMode
    dry_run: bool = False
    auto_confirm: bool = False
    force: bool = False
    debug: bool = False
    kill_processes: bool | None = None  # None = use config, True/False = CLI override



---
File: /src/autowt/prompts.py
---

"""Prompt utilities that respect global options."""

from autowt.global_config import options


def confirm(message: str, default: bool = False) -> bool:
    """
    Ask for user confirmation, respecting the global auto_confirm option.

    Args:
        message: The prompt message to display
        default: The default value if user just presses enter

    Returns:
        bool: True if confirmed, False otherwise
    """
    if options.auto_confirm:
        print(f"{message} [auto-confirmed]")
        return True

    # Format the prompt based on default
    if default:
        prompt = f"{message} (Y/n) "
        valid_yes = ["y", "yes", ""]  # Empty string defaults to yes
    else:
        prompt = f"{message} (y/N) "
        valid_yes = ["y", "yes"]

    response = input(prompt)
    return response.lower() in valid_yes


def confirm_default_yes(message: str) -> bool:
    """Ask for confirmation with default=True."""
    return confirm(message, default=True)


def confirm_default_no(message: str) -> bool:
    """Ask for confirmation with default=False."""
    return confirm(message, default=False)



---
File: /src/autowt/utils.py
---

"""Utility functions for autowt."""

import logging
import shlex
import subprocess
from pathlib import Path

from autowt.console import print_command

# Special logger for command execution
command_logger = logging.getLogger("autowt.commands")


def run_command(
    cmd: list[str],
    cwd: Path | None = None,
    capture_output: bool = True,
    text: bool = True,
    timeout: int | None = None,
    description: str | None = None,
) -> subprocess.CompletedProcess:
    """Run a subprocess command with debug logging only."""
    cmd_str = shlex.join(cmd)

    # Only log at debug level - this is for read-only operations
    if description:
        command_logger.debug(f"{description}: {cmd_str}")
    else:
        command_logger.debug(f"Running: {cmd_str}")

    if cwd:
        command_logger.debug(f"Working directory: {cwd}")

    # Run the command
    try:
        result = subprocess.run(
            cmd, cwd=cwd, capture_output=capture_output, text=text, timeout=timeout
        )

        # Log result - failures are only warnings if they have stderr output
        if result.returncode == 0:
            command_logger.debug(f"Command succeeded (exit code: {result.returncode})")
        else:
            # Many commands are expected to fail (checking for existence, etc.)
            # Only warn if there's actual error output, otherwise just debug
            if result.stderr and result.stderr.strip():
                command_logger.warning(
                    f"Command failed (exit code: {result.returncode})"
                )
                command_logger.warning(f"Error output: {result.stderr.strip()}")
            else:
                command_logger.debug(
                    f"Command completed (exit code: {result.returncode})"
                )

        return result

    except subprocess.TimeoutExpired:
        command_logger.error(f"Command timed out after {timeout}s: {cmd_str}")
        raise
    except Exception as e:
        command_logger.error(f"Command failed with exception: {e}")
        raise


def run_command_visible(
    cmd: list[str],
    cwd: Path | None = None,
    capture_output: bool = True,
    text: bool = True,
    timeout: int | None = None,
) -> subprocess.CompletedProcess:
    """Run a subprocess command that should be visible to the user.

    Use this for state-changing operations like create, delete, fetch, etc.
    """
    cmd_str = shlex.join(cmd)

    # Show the command with a clear prefix
    print_command(cmd_str)

    if cwd:
        command_logger.debug(f"Working directory: {cwd}")

    # Run the command
    try:
        result = subprocess.run(
            cmd, cwd=cwd, capture_output=capture_output, text=text, timeout=timeout
        )

        # Log result
        if result.returncode == 0:
            command_logger.debug(f"Command succeeded (exit code: {result.returncode})")
        else:
            command_logger.warning(f"Command failed (exit code: {result.returncode})")
            if result.stderr:
                command_logger.warning(f"Error output: {result.stderr.strip()}")

        return result

    except subprocess.TimeoutExpired:
        command_logger.error(f"Command timed out after {timeout}s: {cmd_str}")
        raise
    except Exception as e:
        command_logger.error(f"Command failed with exception: {e}")
        raise


def run_command_quiet_on_failure(
    cmd: list[str],
    cwd: Path | None = None,
    capture_output: bool = True,
    text: bool = True,
    timeout: int | None = None,
    description: str | None = None,
) -> subprocess.CompletedProcess:
    """Run a command that's expected to sometimes fail without stderr warnings."""
    cmd_str = shlex.join(cmd)

    # Log the command at debug level
    if description:
        command_logger.debug(f"{description}: {cmd_str}")
    else:
        command_logger.debug(f"Running: {cmd_str}")

    if cwd:
        command_logger.debug(f"Working directory: {cwd}")

    # Run the command
    try:
        result = subprocess.run(
            cmd, cwd=cwd, capture_output=capture_output, text=text, timeout=timeout
        )

        # Log result at debug level only
        if result.returncode == 0:
            command_logger.debug(f"Command succeeded (exit code: {result.returncode})")
        else:
            command_logger.debug(f"Command completed (exit code: {result.returncode})")
            if result.stderr:
                command_logger.debug(f"Error output: {result.stderr.strip()}")

        return result

    except subprocess.TimeoutExpired:
        command_logger.error(f"Command timed out after {timeout}s: {cmd_str}")
        raise
    except Exception as e:
        command_logger.error(f"Command failed with exception: {e}")
        raise


def sanitize_branch_name(branch: str) -> str:
    """Sanitize branch name for use in filesystem paths."""
    # Replace problematic characters with hyphens
    sanitized = branch.replace("/", "-").replace(" ", "-").replace("\\", "-")

    # Remove other problematic characters
    sanitized = "".join(c for c in sanitized if c.isalnum() or c in "-_.")

    # Ensure it doesn't start or end with dots or hyphens
    sanitized = sanitized.strip(".-")

    # Ensure it's not empty
    if not sanitized:
        sanitized = "branch"

    return sanitized


def setup_command_logging(debug: bool = False) -> None:
    """Setup command logging to show subprocess execution."""
    # In debug mode, show all commands (DEBUG level)
    # In normal mode, only show visible commands (INFO level)
    level = logging.DEBUG if debug else logging.INFO

    # Only add handler if none exists yet
    if not command_logger.handlers:
        # Create handler for command logger
        handler = logging.StreamHandler()
        handler.setLevel(level)

        # Format just the message for command output
        formatter = logging.Formatter("%(message)s")
        handler.setFormatter(formatter)

        # Configure command logger
        command_logger.addHandler(handler)
        command_logger.propagate = False  # Don't propagate to root logger

    # Always update the level in case debug setting changed
    command_logger.setLevel(level)

    # Also update handler level if it exists
    if command_logger.handlers:
        command_logger.handlers[0].setLevel(level)



---
File: /tests/mocks/__init__.py
---




---
File: /tests/mocks/services.py
---

"""Mock services for testing business logic."""

from pathlib import Path
from typing import Any
from unittest.mock import Mock

from autowt.config import Config
from autowt.models import (
    AgentStatus,
    BranchStatus,
    ProcessInfo,
    ProjectConfig,
    TerminalMode,
    WorktreeInfo,
    WorktreeWithAgent,
)


class MockStateService:
    """Mock state service for testing."""

    def __init__(self):
        self.configs: dict[str, Config] = {}
        self.project_configs: dict[str, ProjectConfig] = {}
        self.session_ids: dict[str, str] = {}
        self.app_state: dict[str, Any] = {}

    def load_config(self) -> Config:
        return self.configs.get("default", Config())

    def save_config(self, config: Config) -> None:
        self.configs["default"] = config

    def load_project_config(self, repo_path: Path) -> ProjectConfig:
        key = str(repo_path)
        return self.project_configs.get(key, ProjectConfig())

    def save_project_config(self, repo_path: Path, config: ProjectConfig) -> None:
        self.project_configs[str(repo_path)] = config

    def load_session_ids(self) -> dict[str, str]:
        return self.session_ids.copy()

    def save_session_ids(self, session_ids: dict[str, str]) -> None:
        self.session_ids = session_ids.copy()

    def _make_session_key(self, repo_path: Path, branch_name: str) -> str:
        """Create a composite key for session storage."""
        return f"{repo_path.resolve()}:{branch_name}"

    def get_session_id(self, repo_path: Path, branch_name: str) -> str | None:
        """Get session ID for specific repo/branch combination."""
        key = self._make_session_key(repo_path, branch_name)
        return self.session_ids.get(key)

    def set_session_id(
        self, repo_path: Path, branch_name: str, session_id: str
    ) -> None:
        """Set session ID for specific repo/branch combination."""
        key = self._make_session_key(repo_path, branch_name)
        self.session_ids[key] = session_id

    def remove_session_id(self, repo_path: Path, branch_name: str) -> None:
        """Remove session ID for specific repo/branch combination."""
        key = self._make_session_key(repo_path, branch_name)
        if key in self.session_ids:
            self.session_ids.pop(key)

    def get_session_ids_for_repo(self, repo_path: Path) -> dict[str, str]:
        """Get all session IDs for a repo, with branch names as keys."""
        repo_key_prefix = f"{repo_path.resolve()}:"

        result = {}
        for key, session_id in self.session_ids.items():
            if key.startswith(repo_key_prefix):
                branch_name = key[len(repo_key_prefix) :]
                result[branch_name] = session_id

        return result

    def load_app_state(self) -> dict[str, Any]:
        return self.app_state.copy()

    def save_app_state(self, state: dict[str, Any]) -> None:
        self.app_state = state.copy()

    def has_shown_hooks_prompt(self) -> bool:
        return self.app_state.get("hooks_prompt_shown", False)

    def mark_hooks_prompt_shown(self) -> None:
        self.app_state["hooks_prompt_shown"] = True

    def has_shown_experimental_terminal_warning(self) -> bool:
        return self.app_state.get("experimental_terminal_warning_shown", False)

    def mark_experimental_terminal_warning_shown(self) -> None:
        self.app_state["experimental_terminal_warning_shown"] = True


class MockGitService:
    """Mock git service for testing."""

    def __init__(self):
        self.repo_root: Path | None = None
        self.worktrees: list[WorktreeInfo] = []
        self.branch_statuses: list[BranchStatus] = []
        self.current_branch = "main"
        self.fetch_success = True
        self.create_success = True
        self.remove_success = True
        self.install_hooks_success = True

        # Track method calls
        self.fetch_called = False
        self.create_worktree_calls = []
        self.remove_worktree_calls = []
        self.install_hooks_called = False

    def find_repo_root(self, start_path: Path | None = None) -> Path | None:
        return self.repo_root

    def is_git_repo(self, path: Path) -> bool:
        return self.repo_root is not None

    def get_current_branch(self, repo_path: Path) -> str | None:
        return self.current_branch

    def list_worktrees(self, repo_path: Path) -> list[WorktreeInfo]:
        return self.worktrees.copy()

    def fetch_branches(self, repo_path: Path) -> bool:
        self.fetch_called = True
        return self.fetch_success

    def create_worktree(
        self, repo_path: Path, branch: str, worktree_path: Path
    ) -> bool:
        self.create_worktree_calls.append((repo_path, branch, worktree_path))
        if self.create_success:
            # Add to our mock worktree list
            self.worktrees.append(
                WorktreeInfo(branch=branch, path=worktree_path, is_current=False)
            )
        return self.create_success

    def remove_worktree(
        self,
        repo_path: Path,
        worktree_path: Path,
        force: bool = False,
        interactive: bool = True,
    ) -> bool:
        self.remove_worktree_calls.append((repo_path, worktree_path))
        if self.remove_success:
            # Remove from our mock worktree list
            self.worktrees = [wt for wt in self.worktrees if wt.path != worktree_path]
        return self.remove_success

    def delete_branch(self, repo_path: Path, branch: str, force: bool = False) -> bool:
        """Mock branch deletion."""
        return True  # Always succeed for tests

    def analyze_branches_for_cleanup(
        self, repo_path: Path, worktrees: list[WorktreeInfo]
    ) -> list[BranchStatus]:
        return self.branch_statuses.copy()

    def install_hooks(self, repo_path: Path) -> bool:
        self.install_hooks_called = True
        return self.install_hooks_success


class MockTerminalService:
    """Mock terminal service for testing."""

    def __init__(self):
        self.current_session_id = "test-session-123"
        self.switch_success = True

        # Track method calls
        self.switch_calls = []

        # Mock the terminal implementation
        self.terminal = Mock()
        self.terminal.get_current_session_id.return_value = self.current_session_id
        self.terminal.supports_session_management.return_value = True

    def get_current_session_id(self) -> str | None:
        return self.current_session_id

    def switch_to_worktree(
        self,
        worktree_path: Path,
        mode: TerminalMode,
        session_id: str | None = None,
        init_script: str | None = None,
        after_init: str | None = None,
        branch_name: str | None = None,
        auto_confirm: bool = False,
        ignore_same_session: bool = False,
    ) -> bool:
        self.switch_calls.append(
            (
                worktree_path,
                mode,
                session_id,
                init_script,
                after_init,
                branch_name,
                auto_confirm,
                ignore_same_session,
            )
        )
        return self.switch_success


class MockProcessService:
    """Mock process service for testing."""

    def __init__(self):
        self.processes: list[ProcessInfo] = []
        self.terminate_success = True

        # Track method calls
        self.find_calls = []
        self.terminate_calls = []

    def find_processes_in_directory(self, directory: Path) -> list[ProcessInfo]:
        self.find_calls.append(directory)
        # Return processes that match this directory
        return [p for p in self.processes if p.working_dir == directory]

    def terminate_processes(self, processes: list[ProcessInfo]) -> bool:
        self.terminate_calls.append(processes)
        return self.terminate_success

    def print_process_summary(self, processes: list[ProcessInfo]) -> None:
        # Mock implementation - just track the call
        pass


class MockAgentService:
    """Mock agent service for testing."""

    def __init__(self):
        self.agent_statuses: dict[Path, AgentStatus | None] = {}
        self.process_running_results: dict[Path, bool] = {}

    def detect_agent_status(self, worktree_path: Path) -> AgentStatus | None:
        return self.agent_statuses.get(worktree_path)

    def enhance_worktrees_with_agent_status(
        self, worktrees: list[WorktreeInfo], state_service, repo_path: Path
    ) -> list[WorktreeWithAgent]:
        """Add agent status to worktree information."""
        enhanced = []
        for worktree in worktrees:
            agent_status = self.detect_agent_status(worktree.path)
            session_id = state_service.get_session_id(repo_path, worktree.branch)
            has_session = session_id is not None
            enhanced.append(
                WorktreeWithAgent(
                    branch=worktree.branch,
                    path=worktree.path,
                    is_current=worktree.is_current,
                    is_primary=worktree.is_primary,
                    agent_status=agent_status,
                    has_active_session=has_session,
                )
            )
        return enhanced

    def find_waiting_agents(
        self, enhanced_worktrees: list[WorktreeWithAgent]
    ) -> list[WorktreeWithAgent]:
        """Find worktrees with agents waiting for input."""
        return [
            wt
            for wt in enhanced_worktrees
            if wt.agent_status and wt.agent_status.status == "waiting"
        ]

    def find_latest_active_agent(
        self, enhanced_worktrees: list[WorktreeWithAgent]
    ) -> WorktreeWithAgent | None:
        """Find the most recently active agent."""
        active_agents = [
            wt
            for wt in enhanced_worktrees
            if wt.agent_status
            and wt.agent_status.status in ["working", "idle", "waiting"]
        ]
        if not active_agents:
            return None
        return sorted(
            active_agents, key=lambda w: w.agent_status.last_activity, reverse=True
        )[0]


class MockServices:
    """Mock Services container for testing."""

    def __init__(self):
        self.state = MockStateService()
        self.git = MockGitService()
        self.terminal = MockTerminalService()
        self.process = MockProcessService()
        self.agent = MockAgentService()



---
File: /tests/unit/__init__.py
---




---
File: /tests/unit/test_agent_switching.py
---

"""Tests for agent switching functionality with CLI options."""

from unittest.mock import patch

from click.testing import CliRunner

from autowt.cli import main
from autowt.models import SwitchCommand, TerminalMode
from tests.mocks.services import MockServices


class TestAgentSwitching:
    """Tests for unified agent switching with CLI options."""

    def test_switch_waiting_with_terminal_option(self):
        """Test that --waiting supports --terminal option."""
        runner = CliRunner()

        with patch("autowt.cli.create_services") as mock_create_services:
            # Setup mock services
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            # Mock find_waiting_agent_branch to return a branch
            with patch("autowt.cli.find_waiting_agent_branch") as mock_find_waiting:
                mock_find_waiting.return_value = "feature-branch"

                with patch("autowt.cli.checkout_branch") as mock_checkout:
                    result = runner.invoke(
                        main, ["switch", "--waiting", "--terminal", "window"]
                    )

                    if result.exit_code != 0:
                        print(f"Exit code: {result.exit_code}")
                        print(f"Output: {result.output}")
                        print(f"Exception: {result.exception}")
                    assert result.exit_code == 0
                    mock_find_waiting.assert_called_once()
                    mock_checkout.assert_called_once()

                    # Verify the SwitchCommand was created with correct options
                    args, kwargs = mock_checkout.call_args
                    switch_cmd = args[0]
                    assert isinstance(switch_cmd, SwitchCommand)
                    assert switch_cmd.branch == "feature-branch"
                    assert switch_cmd.terminal_mode == TerminalMode.WINDOW

    def test_switch_latest_with_init_script(self):
        """Test that --latest supports --init option."""
        runner = CliRunner()

        with patch("autowt.cli.create_services") as mock_create_services:
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            with patch("autowt.cli.find_latest_agent_branch") as mock_find_latest:
                mock_find_latest.return_value = "hotfix-branch"

                with patch("autowt.cli.checkout_branch") as mock_checkout:
                    result = runner.invoke(
                        main, ["switch", "--latest", "--init", "npm install"]
                    )

                    assert result.exit_code == 0
                    mock_find_latest.assert_called_once()
                    mock_checkout.assert_called_once()

                    # Verify checkout was called (init script comes from config + CLI overrides)
                    # This tests that the CLI overrides system works for agent switches
                    args, kwargs = mock_checkout.call_args
                    assert args[0].branch == "hotfix-branch"

    def test_switch_waiting_with_after_init(self):
        """Test that --waiting supports --after-init option."""
        runner = CliRunner()

        with patch("autowt.cli.create_services") as mock_create_services:
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            with patch("autowt.cli.find_waiting_agent_branch") as mock_find_waiting:
                mock_find_waiting.return_value = "feature-ai"

                with patch("autowt.cli.checkout_branch") as mock_checkout:
                    result = runner.invoke(
                        main, ["switch", "--waiting", "--after-init", "npm start"]
                    )

                    assert result.exit_code == 0
                    mock_checkout.assert_called_once()

                    args, kwargs = mock_checkout.call_args
                    switch_cmd = args[0]
                    assert switch_cmd.after_init == "npm start"

    def test_switch_agent_with_auto_confirm(self):
        """Test that agent switches support -y/--yes option."""
        runner = CliRunner()

        with patch("autowt.cli.create_services") as mock_create_services:
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            with patch("autowt.cli.find_waiting_agent_branch") as mock_find_waiting:
                mock_find_waiting.return_value = "test-branch"

                with patch("autowt.cli.checkout_branch") as mock_checkout:
                    result = runner.invoke(main, ["switch", "--waiting", "-y"])

                    assert result.exit_code == 0
                    args, kwargs = mock_checkout.call_args
                    switch_cmd = args[0]
                    assert switch_cmd.auto_confirm is True

    def test_switch_agent_with_ignore_same_session(self):
        """Test that agent switches support --ignore-same-session option."""
        runner = CliRunner()

        with patch("autowt.cli.create_services") as mock_create_services:
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            with patch("autowt.cli.find_latest_agent_branch") as mock_find_latest:
                mock_find_latest.return_value = "dev-branch"

                with patch("autowt.cli.checkout_branch") as mock_checkout:
                    result = runner.invoke(
                        main, ["switch", "--latest", "--ignore-same-session"]
                    )

                    assert result.exit_code == 0
                    args, kwargs = mock_checkout.call_args
                    switch_cmd = args[0]
                    assert switch_cmd.ignore_same_session is True

    def test_switch_agent_with_multiple_options(self):
        """Test agent switches with multiple CLI options combined."""
        runner = CliRunner()

        with patch("autowt.cli.create_services") as mock_create_services:
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            with patch("autowt.cli.find_waiting_agent_branch") as mock_find_waiting:
                mock_find_waiting.return_value = "complex-feature"

                with patch("autowt.cli.checkout_branch") as mock_checkout:
                    result = runner.invoke(
                        main,
                        [
                            "switch",
                            "--waiting",
                            "--terminal",
                            "tab",
                            "--init",
                            "echo 'Setting up'",
                            "--after-init",
                            "code .",
                            "--ignore-same-session",
                            "-y",
                        ],
                    )

                    assert result.exit_code == 0
                    args, kwargs = mock_checkout.call_args
                    switch_cmd = args[0]

                    assert switch_cmd.branch == "complex-feature"
                    assert switch_cmd.terminal_mode == TerminalMode.TAB
                    assert switch_cmd.after_init == "code ."
                    assert switch_cmd.ignore_same_session is True
                    assert switch_cmd.auto_confirm is True

    def test_no_waiting_agents_found(self):
        """Test behavior when no waiting agents are found."""
        runner = CliRunner()

        with patch("autowt.cli.create_services") as mock_create_services:
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            with patch("autowt.cli.find_waiting_agent_branch") as mock_find_waiting:
                mock_find_waiting.return_value = None  # No waiting agents

                with patch("autowt.cli.checkout_branch") as mock_checkout:
                    result = runner.invoke(main, ["switch", "--waiting"])

                    assert result.exit_code == 0
                    mock_find_waiting.assert_called_once()
                    # checkout_branch should NOT be called when no agent found
                    mock_checkout.assert_not_called()

    def test_no_latest_agents_found(self):
        """Test behavior when no latest agents are found."""
        runner = CliRunner()

        with patch("autowt.cli.create_services") as mock_create_services:
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            with patch("autowt.cli.find_latest_agent_branch") as mock_find_latest:
                mock_find_latest.return_value = None  # No recent agents

                with patch("autowt.cli.checkout_branch") as mock_checkout:
                    result = runner.invoke(main, ["switch", "--latest"])

                    assert result.exit_code == 0
                    mock_find_latest.assert_called_once()
                    # checkout_branch should NOT be called when no agent found
                    mock_checkout.assert_not_called()

    def test_mutually_exclusive_options_validation(self):
        """Test that mutually exclusive options are properly validated."""
        runner = CliRunner()

        # Test branch + waiting
        result = runner.invoke(main, ["switch", "my-branch", "--waiting"])
        assert result.exit_code != 0
        assert "Must specify exactly one of" in result.output

        # Test branch + latest
        result = runner.invoke(main, ["switch", "my-branch", "--latest"])
        assert result.exit_code != 0
        assert "Must specify exactly one of" in result.output

        # Test waiting + latest
        result = runner.invoke(main, ["switch", "--waiting", "--latest"])
        assert result.exit_code != 0
        assert "Must specify exactly one of" in result.output

        # Test no options
        result = runner.invoke(main, ["switch"])
        assert result.exit_code != 0
        assert "Must specify exactly one of" in result.output

    def test_switch_help_shows_all_options(self):
        """Test that switch help shows all available options."""
        runner = CliRunner()

        result = runner.invoke(main, ["switch", "--help"])
        assert result.exit_code == 0

        # Verify all options are documented
        expected_options = [
            "--terminal",
            "--init",
            "--after-init",
            "--ignore-same-session",
            "-y, --yes",
            "--waiting",
            "--latest",
            "--debug",
        ]

        for option in expected_options:
            assert option in result.output, f"Missing option {option} in help"



---
File: /tests/unit/test_checkout_conflicts.py
---

"""Tests for checkout command worktree conflict resolution."""

from pathlib import Path
from unittest.mock import patch

from autowt.commands.checkout import (
    _generate_alternative_worktree_path,
    _prompt_for_alternative_worktree,
)
from autowt.models import WorktreeInfo


class TestCheckoutConflicts:
    """Tests for worktree conflict resolution during checkout."""

    def test_creates_alternative_path_when_conflict_exists(self):
        """Test that alternative path is generated correctly when conflicts exist."""

        # Mock existing worktrees that conflict with desired path
        existing_worktrees = [
            WorktreeInfo(
                branch="other-branch",
                path=Path("/mock/repo-worktrees/testbranch"),
                is_current=False,
                is_primary=False,
            ),
            WorktreeInfo(
                branch="another-branch",
                path=Path("/mock/repo-worktrees/testbranch-2"),
                is_current=False,
                is_primary=False,
            ),
        ]

        base_path = Path("/mock/repo-worktrees/testbranch")
        alternative_path = _generate_alternative_worktree_path(
            base_path, existing_worktrees
        )

        # Should generate testbranch-3 since testbranch and testbranch-2 are taken
        assert str(alternative_path).endswith("testbranch-3")

    def test_cancels_when_user_declines_alternative_path(self):
        """Test that worktree creation is cancelled when user declines alternative path."""
        with patch(
            "autowt.commands.checkout.confirm_default_yes", return_value=False
        ) as mock_confirm:
            original_path = Path("/mock/repo-worktrees/testbranch")
            alternative_path = Path("/mock/repo-worktrees/testbranch-2")

            # Should return False when user declines
            result = _prompt_for_alternative_worktree(
                original_path, alternative_path, "other-branch"
            )
            assert result is False
            mock_confirm.assert_called_once()



---
File: /tests/unit/test_cleanup_cli.py
---

"""Tests for cleanup CLI command behavior."""

from pathlib import Path
from unittest.mock import Mock, patch

import pytest
from click.testing import CliRunner

from autowt.cli import main
from autowt.config import CleanupConfig, Config
from autowt.models import CleanupMode, Services


class TestCleanupCLI:
    """Tests for cleanup command CLI behavior."""

    def _create_mock_services(self):
        """Create a properly mocked Services object."""
        mock_services = Mock(spec=Services)
        mock_services.state = Mock()
        mock_services.git = Mock()
        mock_services.terminal = Mock()
        mock_services.process = Mock()

        # Mock git service methods to return empty lists to avoid iteration errors
        mock_services.git.find_repo_root.return_value = Path("/mock/repo")
        mock_services.git.fetch_branches.return_value = True
        mock_services.git.list_worktrees.return_value = []

        # Mock state service methods
        mock_config = Mock(spec=Config)
        mock_config.cleanup = Mock(spec=CleanupConfig)
        mock_config.cleanup.kill_processes = False
        mock_config.cleanup.default_mode = CleanupMode.INTERACTIVE
        mock_services.state.load_config.return_value = mock_config

        return mock_services

    def test_cleanup_defaults_to_interactive_in_tty(self):
        """Test that cleanup defaults to interactive mode when in a TTY."""
        runner = CliRunner()

        # Instead of mocking the whole cleanup function, just mock the CLI behavior
        # by checking that the correct CleanupCommand is created with interactive mode
        with (
            patch(
                "autowt.cli.create_services", return_value=self._create_mock_services()
            ),
            patch(
                "autowt.cli.is_interactive_terminal", return_value=True
            ),  # Simulate TTY
            patch("autowt.cli.cleanup_worktrees") as mock_cleanup,
        ):
            result = runner.invoke(main, ["cleanup"])

            if result.exit_code != 0:
                print(f"Exit code: {result.exit_code}")
                print(f"Output: {result.output}")
                print(f"Exception: {result.exception}")

            assert result.exit_code == 0
            mock_cleanup.assert_called_once()

            # Check that interactive mode was used
            cleanup_cmd = mock_cleanup.call_args[0][0]
            assert cleanup_cmd.mode == CleanupMode.INTERACTIVE

    def test_cleanup_requires_mode_in_non_tty(self):
        """Test that cleanup requires explicit mode when not in a TTY."""
        runner = CliRunner()

        with patch(
            "autowt.cli.is_interactive_terminal", return_value=False
        ):  # Simulate non-TTY
            result = runner.invoke(main, ["cleanup"])

            assert result.exit_code != 0
            assert "No TTY detected" in result.output
            assert "Please specify --mode explicitly" in result.output

    def test_cleanup_works_with_explicit_mode_in_non_tty(self):
        """Test that cleanup works when mode is explicitly specified in non-TTY."""
        runner = CliRunner()

        with (
            patch("autowt.cli.cleanup_worktrees") as mock_cleanup,
            patch(
                "autowt.cli.create_services", return_value=self._create_mock_services()
            ),
            patch(
                "autowt.cli.is_interactive_terminal", return_value=False
            ),  # Simulate non-TTY
        ):
            result = runner.invoke(main, ["cleanup", "--mode", "merged"])

            assert result.exit_code == 0
            mock_cleanup.assert_called_once()

            # Check that merged mode was used
            cleanup_cmd = mock_cleanup.call_args[0][0]
            assert cleanup_cmd.mode == CleanupMode.MERGED

    def test_cleanup_respects_explicit_mode_in_tty(self):
        """Test that explicit mode is respected even in TTY."""
        runner = CliRunner()

        with (
            patch("autowt.cli.cleanup_worktrees") as mock_cleanup,
            patch(
                "autowt.cli.create_services", return_value=self._create_mock_services()
            ),
            patch(
                "autowt.cli.is_interactive_terminal", return_value=True
            ),  # Simulate TTY
        ):
            result = runner.invoke(main, ["cleanup", "--mode", "all"])

            assert result.exit_code == 0
            mock_cleanup.assert_called_once()

            # Check that explicit mode was used (not interactive default)
            cleanup_cmd = mock_cleanup.call_args[0][0]
            assert cleanup_cmd.mode == CleanupMode.ALL

    @pytest.mark.parametrize("mode", ["all", "remoteless", "merged", "interactive"])
    def test_cleanup_accepts_all_valid_modes(self, mode):
        """Test that all valid cleanup modes are accepted."""
        runner = CliRunner()

        with (
            patch("autowt.cli.cleanup_worktrees") as mock_cleanup,
            patch(
                "autowt.cli.create_services", return_value=self._create_mock_services()
            ),
        ):
            result = runner.invoke(main, ["cleanup", "--mode", mode])

            assert result.exit_code == 0
            mock_cleanup.assert_called_once()

            # Check that the correct mode was used
            cleanup_cmd = mock_cleanup.call_args[0][0]
            assert cleanup_cmd.mode == CleanupMode(mode)

    def test_cleanup_passes_other_options_correctly(self):
        """Test that other cleanup options are passed through correctly."""
        runner = CliRunner()

        with (
            patch("autowt.cli.cleanup_worktrees") as mock_cleanup,
            patch(
                "autowt.cli.create_services", return_value=self._create_mock_services()
            ),
        ):
            result = runner.invoke(
                main,
                [
                    "cleanup",
                    "--mode",
                    "merged",
                    "--dry-run",
                    "--yes",
                    "--force",
                    "--kill",
                    "--debug",
                ],
            )

            assert result.exit_code == 0
            mock_cleanup.assert_called_once()

            # Check that all options were passed correctly
            cleanup_cmd = mock_cleanup.call_args[0][0]
            assert cleanup_cmd.mode == CleanupMode.MERGED
            assert cleanup_cmd.dry_run is True
            assert cleanup_cmd.auto_confirm is True
            assert cleanup_cmd.force is True
            assert cleanup_cmd.debug is True
            assert cleanup_cmd.kill_processes is True

    def test_cleanup_mutually_exclusive_kill_options(self):
        """Test that --kill and --no-kill options are mutually exclusive."""
        runner = CliRunner()

        result = runner.invoke(
            main, ["cleanup", "--mode", "merged", "--kill", "--no-kill"]
        )

        assert result.exit_code != 0
        assert "Cannot specify both --kill and --no-kill" in result.output

    def test_kill_processes_flag_handling(self):
        """Test that kill_processes flag is handled correctly based on CLI args and config."""
        runner = CliRunner()

        # Test --kill flag sets kill_processes=True
        with (
            patch("autowt.cli.cleanup_worktrees") as mock_cleanup,
            patch(
                "autowt.cli.create_services", return_value=self._create_mock_services()
            ),
            patch("autowt.cli.get_config") as mock_get_config,
        ):
            mock_config = Mock()
            mock_config.cleanup.kill_processes = False  # Config says don't kill
            mock_config.cleanup.default_mode = CleanupMode.INTERACTIVE
            mock_get_config.return_value = mock_config

            result = runner.invoke(main, ["cleanup", "--mode", "merged", "--kill"])

            assert result.exit_code == 0
            cleanup_cmd = mock_cleanup.call_args[0][0]
            assert cleanup_cmd.kill_processes is True  # --kill overrides config

        # Test --no-kill flag sets kill_processes=False
        with (
            patch("autowt.cli.cleanup_worktrees") as mock_cleanup,
            patch(
                "autowt.cli.create_services", return_value=self._create_mock_services()
            ),
            patch("autowt.cli.get_config") as mock_get_config,
        ):
            mock_config = Mock()
            mock_config.cleanup.kill_processes = True  # Config says kill
            mock_config.cleanup.default_mode = CleanupMode.INTERACTIVE
            mock_get_config.return_value = mock_config

            result = runner.invoke(main, ["cleanup", "--mode", "merged", "--no-kill"])

            assert result.exit_code == 0
            cleanup_cmd = mock_cleanup.call_args[0][0]
            assert cleanup_cmd.kill_processes is False  # --no-kill overrides config

        # Test no flags means kill_processes=None (allows prompting)
        with (
            patch("autowt.cli.cleanup_worktrees") as mock_cleanup,
            patch(
                "autowt.cli.create_services", return_value=self._create_mock_services()
            ),
            patch("autowt.cli.get_config") as mock_get_config,
        ):
            mock_config = Mock()
            mock_config.cleanup.kill_processes = True  # Config says kill
            mock_config.cleanup.default_mode = CleanupMode.INTERACTIVE
            mock_get_config.return_value = mock_config

            result = runner.invoke(main, ["cleanup", "--mode", "merged"])

            assert result.exit_code == 0
            cleanup_cmd = mock_cleanup.call_args[0][0]
            assert cleanup_cmd.kill_processes is None  # None allows prompting



---
File: /tests/unit/test_cli_init_flag.py
---

"""Tests for CLI --init flag functionality."""

from click.testing import CliRunner

from autowt.cli import main


class TestCLIInitFlag:
    """Test the --init flag in CLI commands."""

    def test_switch_command_help_shows_init_option(self):
        """Test that --init option appears in switch command help."""
        runner = CliRunner()
        result = runner.invoke(main, ["switch", "--help"])

        assert result.exit_code == 0
        assert "--init TEXT" in result.output
        assert "Init script to run in the new terminal" in result.output

    def test_dynamic_branch_command_help_shows_init_option(self):
        """Test that --init option appears in dynamic branch command help."""
        runner = CliRunner()
        result = runner.invoke(main, ["test-branch", "--help"])

        assert result.exit_code == 0
        assert "--init TEXT" in result.output
        assert "Init script to run in the new terminal" in result.output



---
File: /tests/unit/test_cli.py
---

"""Tests for CLI command routing and argument handling."""

from unittest.mock import Mock, patch

from click.testing import CliRunner

from autowt.cli import main
from autowt.models import CleanupMode
from tests.mocks.services import MockServices


class TestCLIRouting:
    """Tests for CLI command routing and fallback behavior."""

    def test_explicit_commands_work(self):
        """Test that explicit subcommands work correctly."""
        runner = CliRunner()

        # Mock all the command functions to avoid actual execution
        with (
            patch("autowt.cli.list_worktrees") as mock_ls,
            patch("autowt.cli.cleanup_worktrees") as mock_cleanup,
            patch("autowt.cli.configure_settings") as mock_configure,
            patch("autowt.cli.create_services") as mock_create_services,
            patch("autowt.cli.auto_register_session"),
            patch("autowt.cli.is_interactive_terminal", return_value=True),
            patch("autowt.cli.initialize_config"),
            patch("autowt.cli.get_config") as mock_get_config,
        ):
            # Setup mock services
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            # Setup mock config
            mock_config = Mock()
            mock_config.cleanup.default_mode = CleanupMode.INTERACTIVE
            mock_get_config.return_value = mock_config
            # Test ls command
            result = runner.invoke(main, ["ls"])
            if result.exit_code != 0:
                print(f"Exit code: {result.exit_code}")
                print(f"Output: {result.output}")
                print(f"Exception: {result.exception}")
            assert result.exit_code == 0
            mock_ls.assert_called_once()

            # Test cleanup command
            result = runner.invoke(main, ["cleanup"])
            assert result.exit_code == 0
            mock_cleanup.assert_called_once()

            # Test config command
            result = runner.invoke(main, ["config"])
            assert result.exit_code == 0
            mock_configure.assert_called_once()

    def test_switch_command_works(self):
        """Test that explicit switch command works."""
        runner = CliRunner()

        with (
            patch("autowt.cli.checkout_branch") as mock_checkout,
            patch("autowt.cli.create_services") as mock_create_services,
            patch("autowt.cli.auto_register_session"),
            patch("autowt.cli.initialize_config"),
            patch("autowt.cli.get_config") as mock_get_config,
        ):
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            # Setup mock config
            mock_config = Mock()
            mock_config.terminal.mode = "tab"
            mock_config.scripts.init = None
            mock_get_config.return_value = mock_config

            result = runner.invoke(main, ["switch", "feature-branch"])
            assert result.exit_code == 0
            mock_checkout.assert_called_once()
            # Check that the SwitchCommand was created correctly
            args, kwargs = mock_checkout.call_args
            switch_cmd = args[0]
            assert switch_cmd.branch == "feature-branch"

    def test_branch_name_fallback(self):
        """Test that unknown commands are treated as branch names."""
        runner = CliRunner()

        with (
            patch("autowt.cli.checkout_branch") as mock_checkout,
            patch("autowt.cli.create_services") as mock_create_services,
            patch("autowt.cli.auto_register_session"),
            patch("autowt.cli.initialize_config"),
            patch("autowt.cli.get_config") as mock_get_config,
        ):
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            # Setup mock config
            mock_config = Mock()
            mock_config.terminal.mode = "tab"
            mock_config.scripts.init = None
            mock_config.terminal.always_new = False
            mock_get_config.return_value = mock_config

            # Test simple branch name
            result = runner.invoke(main, ["feature-branch"])
            if result.exit_code != 0:
                print(f"Exit code: {result.exit_code}")
                print(f"Output: {result.output}")
                print(f"Exception: {result.exception}")
            assert result.exit_code == 0
            mock_checkout.assert_called_once()
            args, kwargs = mock_checkout.call_args
            switch_cmd = args[0]
            assert switch_cmd.branch == "feature-branch"

            mock_checkout.reset_mock()

            # Test branch name with slashes
            result = runner.invoke(main, ["steve/bugfix"])
            assert result.exit_code == 0
            mock_checkout.assert_called_once()
            args, kwargs = mock_checkout.call_args
            switch_cmd = args[0]
            assert switch_cmd.branch == "steve/bugfix"

    def test_terminal_option_passed_through(self):
        """Test that --terminal option is passed to checkout function."""
        runner = CliRunner()

        with (
            patch("autowt.cli.checkout_branch") as mock_checkout,
            patch("autowt.cli.create_services") as mock_create_services,
            patch("autowt.cli.auto_register_session"),
            patch("autowt.cli.initialize_config"),
            patch("autowt.cli.get_config") as mock_get_config,
        ):
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            # Setup mock config
            mock_config = Mock()
            mock_config.terminal.mode = "tab"
            mock_config.scripts.init = None
            mock_config.terminal.always_new = False
            mock_get_config.return_value = mock_config

            # Test with explicit switch command
            result = runner.invoke(
                main, ["switch", "feature-branch", "--terminal", "window"]
            )
            assert result.exit_code == 0
            args, kwargs = mock_checkout.call_args
            switch_cmd = args[0]
            assert switch_cmd.branch == "feature-branch"
            assert switch_cmd.terminal_mode.value == "window"

            mock_checkout.reset_mock()

            # Test with branch name fallback
            result = runner.invoke(main, ["feature-branch", "--terminal", "tab"])
            assert result.exit_code == 0
            args, kwargs = mock_checkout.call_args
            switch_cmd = args[0]
            assert switch_cmd.branch == "feature-branch"
            assert switch_cmd.terminal_mode.value == "tab"

    def test_no_args_shows_list(self):
        """Test that running with no arguments shows the worktree list."""
        runner = CliRunner()

        with (
            patch("autowt.cli.list_worktrees") as mock_ls,
            patch("autowt.cli.create_services") as mock_create_services,
            patch("autowt.cli.auto_register_session"),
        ):
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            result = runner.invoke(main, [])
            assert result.exit_code == 0
            mock_ls.assert_called_once()

    def test_help_works(self):
        """Test that help commands work correctly."""
        runner = CliRunner()

        # Main help
        result = runner.invoke(main, ["--help"])
        assert result.exit_code == 0
        assert "Git worktree manager" in result.output

        # Subcommand help
        result = runner.invoke(main, ["switch", "--help"])
        assert result.exit_code == 0
        assert "Switch to or create a worktree" in result.output

    def test_debug_flag_works(self):
        """Test that debug flag is handled correctly."""
        runner = CliRunner()

        with (
            patch("autowt.cli.setup_logging") as mock_setup_logging,
            patch("autowt.cli.list_worktrees"),
            patch("autowt.cli.create_services") as mock_create_services,
            patch("autowt.cli.auto_register_session"),
        ):
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            # Test debug flag - setup_logging is called in both main and ls command
            result = runner.invoke(main, ["ls", "--debug"])
            assert result.exit_code == 0
            # Should be called twice: once from main group, once from ls command
            assert mock_setup_logging.call_count == 2
            mock_setup_logging.assert_any_call(True)

            mock_setup_logging.reset_mock()

            # Test without debug flag
            result = runner.invoke(main, ["ls"])
            assert result.exit_code == 0
            # Should be called twice: once from main group, once from ls command
            assert mock_setup_logging.call_count == 2
            mock_setup_logging.assert_any_call(False)

    def test_cleanup_mode_options(self):
        """Test that cleanup mode options work correctly."""
        runner = CliRunner()

        with (
            patch("autowt.cli.cleanup_worktrees") as mock_cleanup,
            patch("autowt.cli.create_services") as mock_create_services,
            patch("autowt.cli.auto_register_session"),
            patch("autowt.cli.initialize_config"),
            patch("autowt.cli.get_config") as mock_get_config,
        ):
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            # Setup mock config
            mock_config = Mock()
            mock_config.cleanup.kill_processes = False
            mock_get_config.return_value = mock_config

            # Test different modes
            for mode_str, mode_enum in [
                ("all", CleanupMode.ALL),
                ("merged", CleanupMode.MERGED),
                ("remoteless", CleanupMode.REMOTELESS),
                ("interactive", CleanupMode.INTERACTIVE),
            ]:
                result = runner.invoke(main, ["cleanup", "--mode", mode_str])
                assert result.exit_code == 0
                mock_cleanup.assert_called_once()
                args, kwargs = mock_cleanup.call_args
                cleanup_cmd = args[0]
                assert cleanup_cmd.mode == mode_enum
                mock_cleanup.reset_mock()

    def test_complex_branch_names(self):
        """Test that complex branch names work as fallback."""
        runner = CliRunner()

        with (
            patch("autowt.cli.checkout_branch") as mock_checkout,
            patch("autowt.cli.create_services") as mock_create_services,
            patch("autowt.cli.auto_register_session"),
            patch("autowt.cli.initialize_config"),
            patch("autowt.cli.get_config") as mock_get_config,
        ):
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            # Setup mock config
            mock_config = Mock()
            mock_config.terminal.mode = "tab"
            mock_config.scripts.init = None
            mock_config.terminal.always_new = False
            mock_get_config.return_value = mock_config

            # Test various complex branch names
            complex_names = [
                "feature/user-auth",
                "steve/bugfix-123",
                "release/v2.1.0",
                "hotfix/critical-bug",
                "chore/update-deps",
            ]

            for branch_name in complex_names:
                result = runner.invoke(main, [branch_name])
                assert result.exit_code == 0, f"Failed for branch: {branch_name}"
                mock_checkout.assert_called_once()
                args, kwargs = mock_checkout.call_args
                switch_cmd = args[0]
                assert switch_cmd.branch == branch_name
                mock_checkout.reset_mock()

    def test_reserved_words_as_branch_names(self):
        """Test handling of reserved command names as branch names using switch."""
        runner = CliRunner()

        with (
            patch("autowt.cli.checkout_branch") as mock_checkout,
            patch("autowt.cli.create_services") as mock_create_services,
            patch("autowt.cli.auto_register_session"),
            patch("autowt.cli.initialize_config"),
            patch("autowt.cli.get_config") as mock_get_config,
        ):
            mock_services = MockServices()
            mock_create_services.return_value = mock_services

            # Setup mock config
            mock_config = Mock()
            mock_config.terminal.mode = "tab"
            mock_config.scripts.init = None
            mock_config.terminal.always_new = False
            mock_get_config.return_value = mock_config

            # If someone has a branch literally named 'cleanup', they need to use 'switch'
            result = runner.invoke(main, ["switch", "cleanup"])
            assert result.exit_code == 0
            mock_checkout.assert_called_once()
            args, kwargs = mock_checkout.call_args
            switch_cmd = args[0]
            assert switch_cmd.branch == "cleanup"



---
File: /tests/unit/test_commands.py
---

"""Tests for command handlers with mocked services."""

from unittest.mock import patch

from autowt.commands import checkout, cleanup, ls
from autowt.models import (
    CleanupCommand,
    CleanupMode,
    SwitchCommand,
    TerminalMode,
)
from tests.mocks.services import (
    MockServices,
)


class TestListCommand:
    """Tests for ls command."""

    def test_ls_with_worktrees(self, temp_repo_path, sample_worktrees, capsys):
        """Test listing worktrees."""
        # Setup mocks
        services = MockServices()
        services.git.repo_root = temp_repo_path
        services.git.worktrees = sample_worktrees

        # Run command
        ls.list_worktrees(services)

        # Check output
        captured = capsys.readouterr()
        assert "Worktrees:" in captured.out
        assert "feature1" in captured.out
        assert "feature2" in captured.out
        assert "bugfix" in captured.out
        assert "autowt <branch>" in captured.out

    def test_ls_no_worktrees(self, temp_repo_path, capsys):
        """Test listing when no worktrees exist."""
        # Setup mocks
        services = MockServices()
        services.git.repo_root = temp_repo_path
        services.git.worktrees = []

        # Run command
        ls.list_worktrees(services)

        # Check output
        captured = capsys.readouterr()
        assert "No worktrees found." in captured.out

    def test_ls_not_in_repo(self, capsys):
        """Test ls when not in a git repository."""
        # Setup mocks
        services = MockServices()
        services.git.repo_root = None

        # Run command
        ls.list_worktrees(services)

        # Check output
        captured = capsys.readouterr()
        assert "Error: Not in a git repository" in captured.out


class TestCheckoutCommand:
    """Tests for checkout command."""

    def test_checkout_existing_worktree(self, temp_repo_path, sample_worktrees):
        """Test switching to existing worktree."""
        # Setup mocks
        services = MockServices()
        # Add session ID data using composite key format
        composite_key = f"{temp_repo_path.resolve()}:feature1"
        services.state.session_ids = {composite_key: "session1"}  # Add session ID data
        services.git.repo_root = temp_repo_path
        services.git.worktrees = sample_worktrees

        # Create SwitchCommand
        switch_cmd = SwitchCommand(branch="feature1", terminal_mode=TerminalMode.TAB)

        # Mock user input to confirm switch
        with (
            patch("builtins.input", return_value="y"),
            patch("builtins.print"),
        ):  # Suppress print output
            checkout.checkout_branch(switch_cmd, services)

        # Verify terminal switching was called
        assert len(services.terminal.switch_calls) == 1
        call = services.terminal.switch_calls[0]
        assert call[0] == sample_worktrees[0].path  # worktree path
        assert call[1] == TerminalMode.TAB  # terminal mode
        assert call[2] == "session1"  # session ID
        assert call[3] is None  # init script

    def test_checkout_already_in_worktree(
        self, temp_repo_path, sample_worktrees, capsys
    ):
        """Test trying to switch to a worktree you're already in."""
        # Setup mocks
        services = MockServices()
        services.git.repo_root = temp_repo_path
        services.git.worktrees = sample_worktrees

        # Create SwitchCommand for feature1
        switch_cmd = SwitchCommand(branch="feature1", terminal_mode=TerminalMode.TAB)

        # Mock current working directory to be inside the feature1 worktree
        target_worktree = sample_worktrees[0]  # feature1 worktree
        with patch("pathlib.Path.cwd", return_value=target_worktree.path / "subdir"):
            checkout.checkout_branch(switch_cmd, services)

        # Verify no terminal switching was attempted
        assert len(services.terminal.switch_calls) == 0

        # Check that appropriate message was printed
        captured = capsys.readouterr()
        assert "Already in feature1 worktree" in captured.out

    def test_checkout_new_worktree(self, temp_repo_path):
        """Test creating new worktree."""
        # Setup mocks
        services = MockServices()
        services.git.repo_root = temp_repo_path
        services.git.worktrees = []  # No existing worktrees
        services.git.fetch_success = True
        services.git.create_success = True

        # Create SwitchCommand
        switch_cmd = SwitchCommand(
            branch="new-feature", terminal_mode=TerminalMode.WINDOW
        )

        # Run command
        checkout.checkout_branch(switch_cmd, services)

        # Verify git operations
        assert services.git.fetch_called
        assert len(services.git.create_worktree_calls) == 1

        create_call = services.git.create_worktree_calls[0]
        assert create_call[1] == "new-feature"  # branch name

        # Verify terminal switching
        assert len(services.terminal.switch_calls) == 1
        switch_call = services.terminal.switch_calls[0]
        assert switch_call[1] == TerminalMode.WINDOW
        assert switch_call[3] is None  # init script

        # State is no longer saved - worktree info is derived from git

    def test_checkout_decline_switch(self, temp_repo_path, sample_worktrees):
        """Test declining to switch to existing worktree."""
        # Setup mocks
        services = MockServices()
        services.git.repo_root = temp_repo_path
        services.git.worktrees = sample_worktrees
        services.terminal.switch_success = (
            False  # Simulate user declining/switch failure
        )

        # Create SwitchCommand
        switch_cmd = SwitchCommand(branch="feature1", terminal_mode=TerminalMode.TAB)

        checkout.checkout_branch(switch_cmd, services)

        # Verify terminal service was called but returned False (declined/failed)
        assert len(services.terminal.switch_calls) == 1
        assert services.terminal.switch_calls[0][5] == "feature1"  # branch_name
        assert not services.terminal.switch_calls[0][6]  # auto_confirm

    def test_checkout_existing_worktree_with_init_script(
        self, temp_repo_path, sample_worktrees
    ):
        """Test switching to existing worktree with init script."""
        # Setup mocks
        services = MockServices()
        # Add session ID data using composite key format
        composite_key = f"{temp_repo_path.resolve()}:feature1"
        services.state.session_ids = {composite_key: "session1"}
        services.git.repo_root = temp_repo_path
        services.git.worktrees = sample_worktrees

        # Create SwitchCommand
        switch_cmd = SwitchCommand(
            branch="feature1", terminal_mode=TerminalMode.TAB, init_script="setup.sh"
        )

        # Mock user input to confirm switch
        with (
            patch("builtins.input", return_value="y"),
            patch("builtins.print"),
        ):
            checkout.checkout_branch(switch_cmd, services)

        # Verify terminal switching was called WITHOUT init script (existing worktree)
        assert len(services.terminal.switch_calls) == 1
        call = services.terminal.switch_calls[0]
        assert call[0] == sample_worktrees[0].path  # worktree path
        assert call[1] == TerminalMode.TAB  # terminal mode
        assert call[2] == "session1"  # session ID
        assert call[3] is None  # no init script for existing worktrees
        assert call[4] is None  # no after_init for existing worktrees
        assert call[5] == "feature1"  # branch name

    def test_checkout_new_worktree_with_init_script(self, temp_repo_path):
        """Test creating new worktree with init script."""
        # Setup mocks
        services = MockServices()
        services.git.repo_root = temp_repo_path
        services.git.worktrees = []  # No existing worktrees
        services.git.fetch_success = True
        services.git.create_success = True

        # Create SwitchCommand
        switch_cmd = SwitchCommand(
            branch="feature-with-init",
            terminal_mode=TerminalMode.TAB,
            init_script="npm install",
        )

        # Run command
        checkout.checkout_branch(switch_cmd, services)

        # Verify terminal switching was called WITH init script (new worktree)
        assert len(services.terminal.switch_calls) == 1
        call = services.terminal.switch_calls[0]
        assert call[1] == TerminalMode.TAB  # terminal mode
        assert call[3] == "npm install"  # init script
        assert call[5] == "feature-with-init"  # branch name

    def test_checkout_with_complex_init_script(self, temp_repo_path):
        """Test creating worktree with complex init script."""
        # Setup mocks
        services = MockServices()
        services.git.repo_root = temp_repo_path
        services.git.worktrees = []
        services.git.fetch_success = True
        services.git.create_success = True

        # Create SwitchCommand
        switch_cmd = SwitchCommand(
            branch="feature-complex",
            terminal_mode=TerminalMode.WINDOW,
            init_script="echo 'Setting up...' && npm install && npm run build",
        )

        # Run command
        checkout.checkout_branch(switch_cmd, services)

        # Verify the complex init script was passed correctly
        assert len(services.terminal.switch_calls) == 1
        call = services.terminal.switch_calls[0]
        assert call[3] == "echo 'Setting up...' && npm install && npm run build"


class TestCleanupCommand:
    """Tests for cleanup command."""

    def test_cleanup_all_mode(
        self, temp_repo_path, sample_worktrees, sample_branch_statuses
    ):
        """Test cleanup in all mode."""
        # Setup mocks
        services = MockServices()
        services.git.repo_root = temp_repo_path
        services.git.worktrees = sample_worktrees
        services.git.branch_statuses = sample_branch_statuses

        # Mock user confirmation and print output
        with (
            patch("builtins.input", return_value="y"),
            patch("builtins.print"),
        ):  # Suppress print output
            cleanup_cmd = CleanupCommand(mode=CleanupMode.ALL)
            cleanup.cleanup_worktrees(cleanup_cmd, services)

        # Verify git operations
        assert services.git.fetch_called
        assert len(services.git.remove_worktree_calls) == len(sample_branch_statuses)

    def test_cleanup_remoteless_mode(
        self, temp_repo_path, sample_worktrees, sample_branch_statuses
    ):
        """Test cleanup in remoteless mode."""
        # Setup mocks
        services = MockServices()
        services.git.repo_root = temp_repo_path
        services.git.worktrees = sample_worktrees
        services.git.branch_statuses = sample_branch_statuses

        # Mock user confirmation and print output
        with (
            patch("builtins.input", return_value="y"),
            patch("builtins.print"),
        ):  # Suppress print output
            cleanup_cmd = CleanupCommand(mode=CleanupMode.REMOTELESS)
            cleanup.cleanup_worktrees(cleanup_cmd, services)

        # Verify git operations
        assert services.git.fetch_called

    def test_cleanup_merged_mode(
        self, temp_repo_path, sample_worktrees, sample_branch_statuses
    ):
        """Test cleanup in merged mode."""
        # Setup mocks
        services = MockServices()
        services.git.repo_root = temp_repo_path
        services.git.worktrees = sample_worktrees
        services.git.branch_statuses = sample_branch_statuses

        # Mock user confirmation and print output
        with (
            patch("builtins.input", return_value="y"),
            patch("builtins.print"),
        ):  # Suppress print output
            cleanup_cmd = CleanupCommand(mode=CleanupMode.MERGED)
            cleanup.cleanup_worktrees(cleanup_cmd, services)

        # Verify git operations
        assert services.git.fetch_called

    def test_cleanup_with_processes(
        self, temp_repo_path, sample_worktrees, sample_branch_statuses
    ):
        """Test cleanup with running processes."""
        # Setup mocks
        services = MockServices()
        services.git.repo_root = temp_repo_path
        services.git.worktrees = sample_worktrees
        services.git.branch_statuses = sample_branch_statuses
        # Add mock processes to terminate (empty for now)
        services.process.processes = []

        # Mock user confirmation and print output
        with (
            patch("builtins.input", return_value="y"),
            patch("builtins.print"),
        ):  # Suppress print output
            cleanup_cmd = CleanupCommand(mode=CleanupMode.ALL)
            cleanup.cleanup_worktrees(cleanup_cmd, services)

        # Verify operations
        assert services.git.fetch_called

    def test_cleanup_cancel(
        self, temp_repo_path, sample_worktrees, sample_branch_statuses
    ):
        """Test canceling cleanup."""
        # Setup mocks
        services = MockServices()
        services.git.repo_root = temp_repo_path
        services.git.worktrees = sample_worktrees
        services.git.branch_statuses = sample_branch_statuses

        # Mock user cancellation and print output
        with (
            patch("builtins.input", return_value="n"),
            patch("builtins.print"),
        ):  # Suppress print output
            cleanup_cmd = CleanupCommand(mode=CleanupMode.ALL)
            cleanup.cleanup_worktrees(cleanup_cmd, services)

        # Verify no removal calls were made
        assert len(services.git.remove_worktree_calls) == 0



---
File: /tests/unit/test_config_tui.py
---

"""Tests for config TUI functionality."""

import tempfile
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

from autowt.commands.config import ConfigApp
from autowt.config import (
    CleanupConfig,
    Config,
    ConfigLoader,
    TerminalConfig,
    WorktreeConfig,
)
from autowt.models import Services, TerminalMode
from autowt.services.state import StateService


class TestConfigTUIBusinessLogic:
    """Level 1: Business logic tests (no async needed)."""

    def test_config_loader_integration(self):
        """Test ConfigLoader actually works with real paths - would catch attribute bugs."""
        # This would have caught my global_config_path vs global_config_file bug
        app_dir = Path("/tmp/test_autowt")
        loader = ConfigLoader(app_dir=app_dir)

        # Test the actual API I tried to use
        config_file = loader.global_config_file
        assert config_file.name == "config.toml"
        assert str(app_dir) in str(config_file)

    def test_save_config_creates_correct_terminal_mode(self):
        """Test _save_config() method creates correct Config object."""
        # Mock services
        mock_services = MagicMock(spec=Services)
        mock_state = MagicMock(spec=StateService)
        mock_state.app_dir = Path("/tmp/test")
        mock_services.state = mock_state

        # Create app with mock config
        app = ConfigApp(mock_services)
        app.config = Config(
            terminal=TerminalConfig(mode=TerminalMode.TAB, always_new=False),
            worktree=WorktreeConfig(auto_fetch=True),
            cleanup=CleanupConfig(kill_processes=True),
        )

        # Mock the UI widgets to simulate user selections
        with patch.object(app, "query_one") as mock_query:
            # Mock radio button for ECHO mode
            mock_radio_set = MagicMock()
            mock_pressed_button = MagicMock()
            mock_pressed_button.id = "mode-echo"
            mock_radio_set.pressed_button = mock_pressed_button

            # Mock switches
            mock_always_new_switch = MagicMock()
            mock_always_new_switch.value = True
            mock_auto_fetch_switch = MagicMock()
            mock_auto_fetch_switch.value = False
            mock_kill_processes_switch = MagicMock()
            mock_kill_processes_switch.value = False

            # Configure query_one to return appropriate mocks
            def query_side_effect(selector, widget_type=None):
                if selector == "#terminal-mode":
                    return mock_radio_set
                elif selector == "#always-new":
                    return mock_always_new_switch
                elif selector == "#auto-fetch":
                    return mock_auto_fetch_switch
                elif selector == "#kill-processes":
                    return mock_kill_processes_switch

            mock_query.side_effect = query_side_effect

            # Call the method under test
            app._save_config()

            # Verify save_config was called with correct values
            mock_state.save_config.assert_called_once()
            saved_config = mock_state.save_config.call_args[0][0]

            # Test the key values that would have been affected by my changes
            assert saved_config.terminal.mode == TerminalMode.ECHO
            assert saved_config.terminal.always_new is True
            assert saved_config.worktree.auto_fetch is False
            assert saved_config.cleanup.kill_processes is False

    def test_save_config_preserves_unchanged_settings(self):
        """Test that _save_config preserves settings not exposed in TUI."""
        mock_services = MagicMock(spec=Services)
        mock_state = MagicMock(spec=StateService)
        mock_state.app_dir = Path("/tmp/test")
        mock_services.state = mock_state

        # Create app with config that has settings not in TUI
        app = ConfigApp(mock_services)
        app.config = Config(
            terminal=TerminalConfig(
                mode=TerminalMode.TAB,
                always_new=False,
                program="custom_terminal",  # Not in TUI
            ),
            worktree=WorktreeConfig(
                auto_fetch=True,
                directory_pattern="custom/{branch}",  # Not in TUI
                max_worktrees=5,  # Not in TUI
            ),
        )

        # Mock UI widgets with no changes
        with patch.object(app, "query_one") as mock_query:
            mock_radio_set = MagicMock()
            mock_radio_set.pressed_button = None  # No selection change

            mock_switches = {
                "#always-new": MagicMock(value=False),
                "#auto-fetch": MagicMock(value=True),
                "#kill-processes": MagicMock(value=True),
            }

            def query_side_effect(selector, widget_type=None):
                if selector == "#terminal-mode":
                    return mock_radio_set
                return mock_switches.get(selector, MagicMock())

            mock_query.side_effect = query_side_effect

            app._save_config()

            # Verify unchanged settings are preserved
            saved_config = mock_state.save_config.call_args[0][0]
            assert saved_config.terminal.program == "custom_terminal"
            assert saved_config.worktree.directory_pattern == "custom/{branch}"
            assert saved_config.worktree.max_worktrees == 5


@pytest.mark.asyncio
class TestConfigTUIUserWorkflows:
    """Level 2: User workflow tests (async - real value)."""

    async def test_user_selects_echo_mode_and_saves(self):
        """Test complete user workflow: open → change → save → persist."""
        # Mock services
        mock_services = MagicMock(spec=Services)
        mock_state = MagicMock(spec=StateService)
        mock_state.app_dir = Path("/tmp/test")
        mock_services.state = mock_state

        # Mock load_config to return a test config
        test_config = Config(
            terminal=TerminalConfig(mode=TerminalMode.TAB, always_new=False),
            worktree=WorktreeConfig(auto_fetch=True),
            cleanup=CleanupConfig(kill_processes=True),
        )
        mock_state.load_config.return_value = test_config

        app = ConfigApp(mock_services)

        async with app.run_test() as pilot:
            # Click echo mode radio button
            await pilot.click("#mode-echo")

            # Click save button
            await pilot.click("#save")

            # Verify the service received correct config
            mock_state.save_config.assert_called_once()
            saved_config = mock_state.save_config.call_args[0][0]
            assert saved_config.terminal.mode == TerminalMode.ECHO

    async def test_global_config_path_displays_correctly(self):
        """Test TUI shows real config path - would catch my attribute bug."""
        # Use tmp directory to avoid permission issues
        with tempfile.TemporaryDirectory() as tmp_dir:
            app_dir = Path(tmp_dir) / "autowt"

            # Mock services with temporary paths
            mock_services = MagicMock(spec=Services)
            mock_state = MagicMock(spec=StateService)
            mock_state.app_dir = app_dir
            mock_services.state = mock_state

            # Mock load_config
            test_config = Config()
            mock_state.load_config.return_value = test_config

            app = ConfigApp(mock_services)

            async with app.run_test() as pilot:
                # Let the UI render
                await pilot.pause()

                # Find labels containing config path info
                labels = app.query("Label")
                label_texts = [str(label.renderable) for label in labels]

                # Should show global config path without crashing
                global_labels = [text for text in label_texts if "Global:" in text]
                assert len(global_labels) == 1
                assert "config.toml" in global_labels[0]
                assert str(app_dir / "config.toml") in global_labels[0]

    async def test_toggle_switches_work(self):
        """Test that boolean toggle switches actually work."""
        mock_services = MagicMock(spec=Services)
        mock_state = MagicMock(spec=StateService)
        mock_state.app_dir = Path("/tmp/test")
        mock_services.state = mock_state

        # Start with default config
        test_config = Config(
            terminal=TerminalConfig(always_new=False),
            worktree=WorktreeConfig(auto_fetch=True),
            cleanup=CleanupConfig(kill_processes=True),
        )
        mock_state.load_config.return_value = test_config

        app = ConfigApp(mock_services)

        async with app.run_test() as pilot:
            # Toggle the always_new switch
            await pilot.click("#always-new")

            # Toggle auto_fetch switch
            await pilot.click("#auto-fetch")

            # Save config
            await pilot.click("#save")

            # Verify toggles were applied
            mock_state.save_config.assert_called_once()
            saved_config = mock_state.save_config.call_args[0][0]
            assert saved_config.terminal.always_new is True  # Was False, now True
            assert saved_config.worktree.auto_fetch is False  # Was True, now False
            assert saved_config.cleanup.kill_processes is True  # Unchanged

    async def test_cancel_button_exits_without_saving(self):
        """Test that cancel button exits without calling save."""
        mock_services = MagicMock(spec=Services)
        mock_state = MagicMock(spec=StateService)
        mock_state.app_dir = Path("/tmp/test")
        mock_services.state = mock_state

        test_config = Config()
        mock_state.load_config.return_value = test_config

        app = ConfigApp(mock_services)

        async with app.run_test() as pilot:
            # Make some changes
            await pilot.click("#mode-echo")
            await pilot.click("#always-new")

            # Click cancel instead of save
            await pilot.click("#cancel")

            # Verify save was never called
            mock_state.save_config.assert_not_called()



---
File: /tests/unit/test_config.py
---

"""Tests for the comprehensive configuration system."""

import os
import tempfile
from pathlib import Path
from unittest.mock import patch

import pytest
import toml

import autowt.config
from autowt.config import (
    BranchSanitizationConfig,
    CleanupConfig,
    Config,
    ConfigLoader,
    ConfirmationsConfig,
    ScriptsConfig,
    TerminalConfig,
    WorktreeConfig,
    get_config,
    load_config,
    save_config,
    set_config,
)
from autowt.models import CleanupMode, TerminalMode


class TestConfigDataClasses:
    """Tests for configuration data classes."""

    def test_terminal_config_defaults(self):
        """Test TerminalConfig default values."""
        config = TerminalConfig()
        assert config.mode == TerminalMode.TAB
        assert config.always_new is False
        assert config.program is None

    def test_terminal_config_with_values(self):
        """Test TerminalConfig with custom values."""
        config = TerminalConfig(
            mode=TerminalMode.WINDOW, always_new=True, program="iterm2"
        )
        assert config.mode == TerminalMode.WINDOW
        assert config.always_new is True
        assert config.program == "iterm2"

    def test_branch_sanitization_config_defaults(self):
        """Test BranchSanitizationConfig default values."""
        config = BranchSanitizationConfig()
        assert config.replace_chars == "/:#@^~"
        assert config.max_length == 255
        assert config.lowercase is False

    def test_worktree_config_defaults(self):
        """Test WorktreeConfig default values."""
        config = WorktreeConfig()
        assert config.directory_pattern == "../{repo_name}-worktrees/{branch}"
        assert config.max_worktrees is None
        assert config.auto_fetch is True
        assert config.default_remote == "origin"
        assert isinstance(config.branch_sanitization, BranchSanitizationConfig)

    def test_cleanup_config_defaults(self):
        """Test CleanupConfig default values."""
        config = CleanupConfig()
        assert config.kill_processes is True
        assert config.kill_process_timeout == 10
        assert config.default_mode == CleanupMode.INTERACTIVE

    def test_scripts_config_defaults(self):
        """Test ScriptsConfig default values."""
        config = ScriptsConfig()
        assert config.init is None
        assert config.custom == {}

    def test_confirmations_config_defaults(self):
        """Test ConfirmationsConfig default values."""
        config = ConfirmationsConfig()
        assert config.cleanup_multiple is True
        assert config.kill_process is True
        assert config.force_operations is True

    def test_main_config_defaults(self):
        """Test main Config default values."""
        config = Config()
        assert isinstance(config.terminal, TerminalConfig)
        assert isinstance(config.worktree, WorktreeConfig)
        assert isinstance(config.cleanup, CleanupConfig)
        assert isinstance(config.scripts, ScriptsConfig)
        assert isinstance(config.confirmations, ConfirmationsConfig)


class TestConfigFromDict:
    """Tests for creating configuration from dictionaries."""

    def test_config_from_empty_dict(self):
        """Test creating config from empty dictionary uses defaults."""
        config = Config.from_dict({})
        assert config.terminal.mode == TerminalMode.TAB
        assert config.cleanup.kill_processes is True

    def test_config_from_partial_dict(self):
        """Test creating config from partial dictionary."""
        data = {
            "terminal": {"mode": "window", "always_new": True},
            "cleanup": {"kill_processes": False},
        }
        config = Config.from_dict(data)

        assert config.terminal.mode == TerminalMode.WINDOW
        assert config.terminal.always_new is True
        assert config.terminal.program is None  # default
        assert config.cleanup.kill_processes is False
        assert config.cleanup.kill_process_timeout == 10  # default

    def test_config_from_complete_dict(self):
        """Test creating config from complete dictionary."""
        data = {
            "terminal": {"mode": "window", "always_new": True, "program": "iterm2"},
            "worktree": {
                "directory_pattern": "$HOME/worktrees/{repo_name}/{branch}",
                "max_worktrees": 20,
                "auto_fetch": False,
                "default_remote": "upstream",
                "branch_sanitization": {
                    "replace_chars": "/@#",
                    "max_length": 100,
                    "lowercase": True,
                },
            },
            "cleanup": {
                "kill_processes": False,
                "kill_process_timeout": 15,
                "default_mode": "merged",
            },
            "scripts": {
                "init": "npm install",
                "custom": {"test": "npm test", "build": "npm run build"},
            },
            "confirmations": {
                "cleanup_multiple": False,
                "kill_process": False,
                "force_operations": True,
            },
        }

        config = Config.from_dict(data)

        # Terminal config
        assert config.terminal.mode == TerminalMode.WINDOW
        assert config.terminal.always_new is True
        assert config.terminal.program == "iterm2"

        # Worktree config
        assert (
            config.worktree.directory_pattern == "$HOME/worktrees/{repo_name}/{branch}"
        )
        assert config.worktree.max_worktrees == 20
        assert config.worktree.auto_fetch is False
        assert config.worktree.default_remote == "upstream"
        assert config.worktree.branch_sanitization.replace_chars == "/@#"
        assert config.worktree.branch_sanitization.max_length == 100
        assert config.worktree.branch_sanitization.lowercase is True

        # Cleanup config
        assert config.cleanup.kill_processes is False
        assert config.cleanup.kill_process_timeout == 15
        assert config.cleanup.default_mode == CleanupMode.MERGED

        # Scripts config
        assert config.scripts.init == "npm install"
        assert config.scripts.custom == {"test": "npm test", "build": "npm run build"}

        # Confirmations config
        assert config.confirmations.cleanup_multiple is False
        assert config.confirmations.kill_process is False
        assert config.confirmations.force_operations is True

    def test_config_invalid_enum_values(self):
        """Test that invalid enum values raise appropriate errors."""
        with pytest.raises(ValueError):
            Config.from_dict({"terminal": {"mode": "invalid_mode"}})

        with pytest.raises(ValueError):
            Config.from_dict({"cleanup": {"default_mode": "invalid_mode"}})


class TestConfigToDict:
    """Tests for converting configuration to dictionaries."""

    def test_config_to_dict_defaults(self):
        """Test converting default config to dictionary."""
        config = Config()
        data = config.to_dict()

        expected = {
            "terminal": {"mode": "tab", "always_new": False, "program": None},
            "worktree": {
                "directory_pattern": "../{repo_name}-worktrees/{branch}",
                "max_worktrees": None,
                "auto_fetch": True,
                "default_remote": "origin",
                "branch_sanitization": {
                    "replace_chars": "/:#@^~",
                    "max_length": 255,
                    "lowercase": False,
                },
            },
            "cleanup": {
                "kill_processes": True,
                "kill_process_timeout": 10,
                "default_mode": "interactive",
            },
            "scripts": {"init": None, "custom": {}},
            "confirmations": {
                "cleanup_multiple": True,
                "kill_process": True,
                "force_operations": True,
            },
        }

        assert data == expected

    def test_config_roundtrip(self):
        """Test that config can be converted to dict and back without loss."""
        original_config = Config.from_dict(
            {
                "terminal": {"mode": "window", "always_new": True},
                "cleanup": {"kill_processes": False},
                "scripts": {"init": "npm install", "custom": {"test": "npm test"}},
            }
        )

        data = original_config.to_dict()
        restored_config = Config.from_dict(data)

        assert original_config.terminal.mode == restored_config.terminal.mode
        assert (
            original_config.terminal.always_new == restored_config.terminal.always_new
        )
        assert (
            original_config.cleanup.kill_processes
            == restored_config.cleanup.kill_processes
        )
        assert original_config.scripts.init == restored_config.scripts.init
        assert original_config.scripts.custom == restored_config.scripts.custom


class TestConfigLoader:
    """Tests for ConfigLoader class."""

    def test_config_loader_init_with_custom_dir(self):
        """Test ConfigLoader initialization with custom directory."""
        with tempfile.TemporaryDirectory() as temp_dir:
            custom_dir = Path(temp_dir) / "custom" / "dir"
            loader = ConfigLoader(app_dir=custom_dir)
            assert loader.app_dir == custom_dir
            assert loader.global_config_file == custom_dir / "config.toml"
            assert custom_dir.exists()  # Should be created

    def test_config_loader_default_app_dir_macos(self):
        """Test default app directory on macOS."""
        with patch("platform.system", return_value="Darwin"):
            loader = ConfigLoader()
            expected = Path.home() / "Library" / "Application Support" / "autowt"
            assert loader.app_dir == expected

    def test_config_loader_default_app_dir_linux(self):
        """Test default app directory on Linux."""
        with patch("platform.system", return_value="Linux"):
            with patch.dict(os.environ, {}, clear=True):
                loader = ConfigLoader()
                expected = Path.home() / ".config" / "autowt"
                assert loader.app_dir == expected

    def test_config_loader_default_app_dir_linux_xdg(self):
        """Test default app directory on Linux with XDG_CONFIG_HOME."""
        with tempfile.TemporaryDirectory() as temp_dir:
            with patch("platform.system", return_value="Linux"):
                with patch.dict(os.environ, {"XDG_CONFIG_HOME": temp_dir}):
                    loader = ConfigLoader()
                    expected = Path(temp_dir) / "autowt"
                    assert loader.app_dir == expected

    def test_config_loader_default_app_dir_windows(self):
        """Test default app directory on Windows."""
        with patch("platform.system", return_value="Windows"):
            loader = ConfigLoader()
            expected = Path.home() / ".autowt"
            assert loader.app_dir == expected

    def test_load_config_no_files(self):
        """Test loading config when no config files exist."""
        with tempfile.TemporaryDirectory() as temp_dir:
            app_dir = Path(temp_dir)
            loader = ConfigLoader(app_dir=app_dir)
            config = loader.load_config()

            # Should return defaults
            assert config.terminal.mode == TerminalMode.TAB
            assert config.cleanup.kill_processes is True

    def test_load_global_config(self):
        """Test loading global configuration file."""
        with tempfile.TemporaryDirectory() as temp_dir:
            app_dir = Path(temp_dir)

            # Create global config
            global_config = {
                "terminal": {"mode": "window", "always_new": True},
                "cleanup": {"kill_processes": False},
            }
            with open(app_dir / "config.toml", "w") as f:
                toml.dump(global_config, f)

            loader = ConfigLoader(app_dir=app_dir)
            config = loader.load_config()

            assert config.terminal.mode == TerminalMode.WINDOW
            assert config.terminal.always_new is True
            assert config.cleanup.kill_processes is False

    def test_load_project_config(self):
        """Test loading project configuration file."""
        with tempfile.TemporaryDirectory() as temp_dir:
            app_dir = Path(temp_dir)
            project_dir = Path(temp_dir) / "project"
            project_dir.mkdir()

            # Create project config
            project_config = {
                "scripts": {"init": "npm install"},
                "terminal": {"mode": "inplace"},
            }
            with open(project_dir / "autowt.toml", "w") as f:
                toml.dump(project_config, f)

            loader = ConfigLoader(app_dir=app_dir)
            config = loader.load_config(project_dir=project_dir)

            assert config.scripts.init == "npm install"
            assert config.terminal.mode == TerminalMode.INPLACE

    def test_load_project_config_hidden_file(self):
        """Test loading project config from .autowt.toml."""
        with tempfile.TemporaryDirectory() as temp_dir:
            app_dir = Path(temp_dir)
            project_dir = Path(temp_dir) / "project"
            project_dir.mkdir()

            # Create hidden project config
            project_config = {"scripts": {"init": "python setup.py"}}
            with open(project_dir / ".autowt.toml", "w") as f:
                toml.dump(project_config, f)

            loader = ConfigLoader(app_dir=app_dir)
            config = loader.load_config(project_dir=project_dir)

            assert config.scripts.init == "python setup.py"

    def test_environment_variables(self):
        """Test loading configuration from environment variables."""
        with tempfile.TemporaryDirectory() as temp_dir:
            app_dir = Path(temp_dir)

            # Set environment variables
            env_vars = {
                "AUTOWT_TERMINAL_MODE": "window",
                "AUTOWT_TERMINAL_ALWAYS_NEW": "true",
                "AUTOWT_CLEANUP_KILL_PROCESSES": "false",
                "AUTOWT_WORKTREE_AUTO_FETCH": "false",
                "AUTOWT_WORKTREE_BRANCH_SANITIZATION_MAX_LENGTH": "100",
                "AUTOWT_SCRIPTS_INIT": "make setup",
            }

            with patch.dict(os.environ, env_vars):
                loader = ConfigLoader(app_dir=app_dir)
                config = loader.load_config()

                assert config.terminal.mode == TerminalMode.WINDOW
                assert config.terminal.always_new is True
                assert config.cleanup.kill_processes is False
                assert config.worktree.auto_fetch is False
                assert config.worktree.branch_sanitization.max_length == 100
                assert config.scripts.init == "make setup"

    def test_cli_overrides(self):
        """Test CLI overrides."""
        with tempfile.TemporaryDirectory() as temp_dir:
            app_dir = Path(temp_dir)

            cli_overrides = {
                "terminal": {"mode": "echo"},
                "cleanup": {"kill_processes": True},
            }

            loader = ConfigLoader(app_dir=app_dir)
            config = loader.load_config(cli_overrides=cli_overrides)

            assert config.terminal.mode == TerminalMode.ECHO
            assert config.cleanup.kill_processes is True

    def test_precedence_order(self):
        """Test configuration precedence order."""
        with tempfile.TemporaryDirectory() as temp_dir:
            app_dir = Path(temp_dir)
            project_dir = Path(temp_dir) / "project"
            project_dir.mkdir()

            # Global config
            global_config = {
                "terminal": {"mode": "tab", "always_new": False},
                "cleanup": {"kill_processes": True},
                "scripts": {"init": "global init"},
            }
            with open(app_dir / "config.toml", "w") as f:
                toml.dump(global_config, f)

            # Project config
            project_config = {
                "terminal": {"mode": "window"},  # Override terminal mode
                "scripts": {"init": "project init"},  # Override init script
            }
            with open(project_dir / "autowt.toml", "w") as f:
                toml.dump(project_config, f)

            # Environment variables
            env_vars = {
                "AUTOWT_CLEANUP_KILL_PROCESSES": "false",  # Override cleanup setting
                "AUTOWT_TERMINAL_ALWAYS_NEW": "true",  # Override always_new
            }

            # CLI overrides
            cli_overrides = {
                "scripts": {"init": "cli init"}  # Override init script again
            }

            with patch.dict(os.environ, env_vars):
                loader = ConfigLoader(app_dir=app_dir)
                config = loader.load_config(
                    project_dir=project_dir, cli_overrides=cli_overrides
                )

                # Check precedence: CLI > env > project > global > defaults
                assert config.terminal.mode == TerminalMode.WINDOW  # From project
                assert config.terminal.always_new is True  # From environment
                assert config.cleanup.kill_processes is False  # From environment
                assert config.scripts.init == "cli init"  # From CLI override

    def test_invalid_global_config_file(self):
        """Test handling of invalid global config file."""
        with tempfile.TemporaryDirectory() as temp_dir:
            app_dir = Path(temp_dir)

            # Create invalid TOML file
            with open(app_dir / "config.toml", "w") as f:
                f.write("invalid toml content [[[")

            loader = ConfigLoader(app_dir=app_dir)
            config = loader.load_config()

            # Should fall back to defaults
            assert config.terminal.mode == TerminalMode.TAB

    def test_invalid_project_config_file(self):
        """Test handling of invalid project config file."""
        with tempfile.TemporaryDirectory() as temp_dir:
            app_dir = Path(temp_dir)
            project_dir = Path(temp_dir) / "project"
            project_dir.mkdir()

            # Create invalid TOML file
            with open(project_dir / "autowt.toml", "w") as f:
                f.write("invalid toml content [[[")

            loader = ConfigLoader(app_dir=app_dir)
            config = loader.load_config(project_dir=project_dir)

            # Should fall back to defaults
            assert config.terminal.mode == TerminalMode.TAB

    def test_unknown_environment_variable(self):
        """Test handling of unknown environment variables."""
        with tempfile.TemporaryDirectory() as temp_dir:
            app_dir = Path(temp_dir)

            with patch.dict(os.environ, {"AUTOWT_UNKNOWN_SETTING": "value"}):
                loader = ConfigLoader(app_dir=app_dir)
                # Should not raise an exception, just log a warning
                config = loader.load_config()
                assert config.terminal.mode == TerminalMode.TAB

    def test_environment_variable_type_conversion(self):
        """Test environment variable type conversion."""
        with tempfile.TemporaryDirectory() as temp_dir:
            app_dir = Path(temp_dir)

            env_vars = {
                "AUTOWT_TERMINAL_ALWAYS_NEW": "yes",  # Boolean true
                "AUTOWT_CLEANUP_KILL_PROCESSES": "no",  # Boolean false
                "AUTOWT_WORKTREE_BRANCH_SANITIZATION_MAX_LENGTH": "150",  # Integer
                "AUTOWT_SCRIPTS_INIT": "echo hello",  # String
            }

            with patch.dict(os.environ, env_vars):
                loader = ConfigLoader(app_dir=app_dir)
                config = loader.load_config()

                assert config.terminal.always_new is True
                assert config.cleanup.kill_processes is False
                assert config.worktree.branch_sanitization.max_length == 150
                assert config.scripts.init == "echo hello"

    def test_save_config(self):
        """Test saving configuration to file."""
        with tempfile.TemporaryDirectory() as temp_dir:
            app_dir = Path(temp_dir)

            config = Config.from_dict(
                {
                    "terminal": {"mode": "window", "always_new": True},
                    "cleanup": {"kill_processes": False},
                }
            )

            loader = ConfigLoader(app_dir=app_dir)
            loader.save_config(config)

            # Verify file was created and contains expected data
            assert (app_dir / "config.toml").exists()

            # Load it back and verify
            loaded_config = loader.load_config()
            assert loaded_config.terminal.mode == TerminalMode.WINDOW
            assert loaded_config.terminal.always_new is True
            assert loaded_config.cleanup.kill_processes is False


class TestGlobalConfigManagement:
    """Tests for global configuration management functions."""

    def test_load_and_get_config(self):
        """Test loading and getting global configuration."""
        # Reset global config
        autowt.config._config = None
        autowt.config._config_loader = None

        with tempfile.TemporaryDirectory() as temp_dir:
            app_dir = Path(temp_dir)

            # Create test config
            global_config = {"terminal": {"mode": "window"}}
            with open(app_dir / "config.toml", "w") as f:
                toml.dump(global_config, f)

            # Mock the config loader to use our temp directory
            with patch("autowt.config.ConfigLoader") as mock_loader_class:
                mock_loader = mock_loader_class.return_value
                mock_loader.load_config.return_value = Config.from_dict(global_config)

                config = load_config()
                assert config.terminal.mode == TerminalMode.WINDOW

                # Should be able to get it globally
                global_config_instance = get_config()
                assert global_config_instance.terminal.mode == TerminalMode.WINDOW

    def test_get_config_before_load_raises_error(self):
        """Test that getting config before loading raises an error."""
        # Reset global config
        autowt.config._config = None

        with pytest.raises(RuntimeError, match="Configuration not initialized"):
            get_config()

    def test_set_config(self):
        """Test setting configuration manually."""
        test_config = Config.from_dict({"terminal": {"mode": "inplace"}})
        set_config(test_config)

        global_config = get_config()
        assert global_config.terminal.mode == TerminalMode.INPLACE

    def test_save_config_function(self):
        """Test save_config function."""
        with tempfile.TemporaryDirectory():
            test_config = Config.from_dict({"terminal": {"mode": "window"}})
            set_config(test_config)

            # Mock the config loader
            with patch("autowt.config.get_config_loader") as mock_get_loader:
                mock_loader = mock_get_loader.return_value

                save_config()

                # Verify save was called with the config
                mock_loader.save_config.assert_called_once_with(test_config)

    def test_save_config_without_config_raises_error(self):
        """Test that saving without config raises an error."""
        # Reset global config
        autowt.config._config = None

        with pytest.raises(RuntimeError, match="No configuration to save"):
            save_config()


class TestConfigIntegration:
    """Integration tests for the complete configuration system."""

    def test_real_world_config_loading(self):
        """Test loading a realistic configuration setup."""
        with tempfile.TemporaryDirectory() as temp_dir:
            app_dir = Path(temp_dir)
            project_dir = Path(temp_dir) / "project"
            project_dir.mkdir()

            # Global config - user preferences
            global_config = {
                "terminal": {"mode": "tab", "program": "iterm2"},
                "cleanup": {"kill_processes": True, "kill_process_timeout": 15},
                "confirmations": {"cleanup_multiple": False},
            }
            with open(app_dir / "config.toml", "w") as f:
                toml.dump(global_config, f)

            # Project config - project-specific settings
            project_config = {
                "scripts": {
                    "init": "npm install && npm run setup",
                    "custom": {
                        "test": "npm test",
                        "build": "npm run build:prod",
                        "deploy": "npm run deploy",
                    },
                },
                "worktree": {
                    "directory_pattern": "$HOME/work-trees/{repo_name}/{branch}",
                    "auto_fetch": False,
                },
            }
            with open(project_dir / "autowt.toml", "w") as f:
                toml.dump(project_config, f)

            # Environment overrides - CI/deployment settings
            env_vars = {
                "AUTOWT_TERMINAL_MODE": "echo",  # For CI/scripts
                "AUTOWT_CLEANUP_KILL_PROCESSES": "false",  # Be careful in CI
            }

            # CLI overrides - one-time overrides
            cli_overrides = {"terminal": {"always_new": True}}

            with patch.dict(os.environ, env_vars):
                loader = ConfigLoader(app_dir=app_dir)
                config = loader.load_config(
                    project_dir=project_dir, cli_overrides=cli_overrides
                )

                # Verify final configuration respects precedence
                assert config.terminal.mode == TerminalMode.ECHO  # From env
                assert config.terminal.always_new is True  # From CLI
                assert config.terminal.program == "iterm2"  # From global

                assert config.cleanup.kill_processes is False  # From env
                assert config.cleanup.kill_process_timeout == 15  # From global

                assert (
                    config.scripts.init == "npm install && npm run setup"
                )  # From project
                assert len(config.scripts.custom) == 3  # From project

                assert (
                    config.worktree.directory_pattern
                    == "$HOME/work-trees/{repo_name}/{branch}"
                )  # From project
                assert config.worktree.auto_fetch is False  # From project

                assert config.confirmations.cleanup_multiple is False  # From global

    def test_minimal_config_setup(self):
        """Test that the system works with minimal configuration."""
        with tempfile.TemporaryDirectory() as temp_dir:
            app_dir = Path(temp_dir)

            loader = ConfigLoader(app_dir=app_dir)
            config = loader.load_config()

            # Should work with all defaults
            assert config.terminal.mode == TerminalMode.TAB
            assert config.cleanup.kill_processes is True
            assert config.scripts.init is None
            assert config.scripts.custom == {}

            # Should be able to save defaults
            loader.save_config(config)
            assert (app_dir / "config.toml").exists()



---
File: /tests/unit/test_console.py
---

"""Tests for console styling functionality."""

import unittest
from unittest.mock import MagicMock, patch

from autowt.console import (
    AUTOWT_THEME,
    console,
    print_command,
    print_error,
    print_info,
    print_output,
    print_plain,
    print_prompt,
    print_section,
    print_success,
)
from autowt.console import console as console2
from autowt.global_config import options


class TestConsoleTheme(unittest.TestCase):
    """Test console theme configuration."""

    def test_theme_has_expected_styles(self):
        """Test that the theme contains all expected autowt styles."""
        expected_autowt_styles = {
            "command",
            "output",
            "prompt",
            "section",
            "success",
            "warning",
            "error",
            "info",
        }

        theme_styles = set(AUTOWT_THEME.styles.keys())
        # Check that all our custom styles are present
        self.assertTrue(expected_autowt_styles.issubset(theme_styles))

    def test_command_and_output_use_same_style(self):
        """Test that command and output styles are both gray."""
        command_style = AUTOWT_THEME.styles["command"]
        output_style = AUTOWT_THEME.styles["output"]
        self.assertEqual(command_style, output_style)
        self.assertEqual(str(command_style), "dim grey50")


class TestConsoleFunctions(unittest.TestCase):
    """Test console wrapper functions."""

    def setUp(self):
        """Set up test mocks."""
        self.mock_console = MagicMock()

    @patch("autowt.console.console")
    def test_print_command_formats_with_prefix(self, mock_console):
        """Test that print_command adds > prefix and uses command style."""
        print_command("git status")
        mock_console.print.assert_called_once_with("> git status", style="command")

    @patch("autowt.console.console")
    def test_print_section_uses_section_style(self, mock_console):
        """Test that print_section uses section style."""
        print_section("Test Section")
        mock_console.print.assert_called_once_with("Test Section", style="section")

    @patch("autowt.console.console")
    def test_print_prompt_uses_prompt_style(self, mock_console):
        """Test that print_prompt uses prompt style."""
        print_prompt("Continue? [y/N]")
        mock_console.print.assert_called_once_with("Continue? [y/N]", style="prompt")

    @patch("autowt.console.console")
    def test_print_success_uses_success_style(self, mock_console):
        """Test that print_success uses success style."""
        print_success("✓ Operation completed")
        mock_console.print.assert_called_once_with(
            "✓ Operation completed", style="success"
        )

    @patch("autowt.console.console")
    def test_print_error_uses_error_style(self, mock_console):
        """Test that print_error uses error style."""
        print_error("✗ Operation failed")
        mock_console.print.assert_called_once_with("✗ Operation failed", style="error")

    @patch("autowt.console.console")
    def test_print_output_uses_output_style(self, mock_console):
        """Test that print_output uses output style."""
        print_output("  Sending SIGINT to process (PID 1234)")
        mock_console.print.assert_called_once_with(
            "  Sending SIGINT to process (PID 1234)", style="output"
        )

    @patch("autowt.console.console")
    def test_print_plain_no_style(self, mock_console):
        """Test that print_plain uses no style."""
        print_plain("Plain text")
        mock_console.print.assert_called_once_with("Plain text")

    @patch("autowt.console.console")
    def test_output_suppression_when_enabled(self, mock_console):
        """Test that rich output can be suppressed via global option."""
        # Test normal output first
        print_info("Test info message")
        mock_console.print.assert_called_with("Test info message", style="info")
        mock_console.reset_mock()

        # Test suppressed output
        original_suppress = options.suppress_rich_output
        options.suppress_rich_output = True
        try:
            print_info("Suppressed info")
            print_success("Suppressed success")
            print_error("Suppressed error")
            # Should have no console.print calls when suppressed
            mock_console.print.assert_not_called()
        finally:
            options.suppress_rich_output = original_suppress


class TestConsoleIntegration(unittest.TestCase):
    """Test console integration with rich."""

    def test_console_is_singleton(self):
        """Test that console is a singleton instance."""
        self.assertIs(console, console2)


if __name__ == "__main__":
    unittest.main()



---
File: /tests/unit/test_models.py
---

"""Tests for data models."""

from pathlib import Path

from autowt.models import (
    BranchStatus,
    CleanupMode,
    ProcessInfo,
    TerminalMode,
    WorktreeInfo,
)


class TestWorktreeInfo:
    """Tests for WorktreeInfo model."""

    def test_worktree_info_creation(self):
        """Test creating WorktreeInfo instance."""
        path = Path("/test/path")
        worktree = WorktreeInfo(branch="test-branch", path=path, is_current=True)

        assert worktree.branch == "test-branch"
        assert worktree.path == path
        assert worktree.is_current is True

    def test_worktree_info_defaults(self):
        """Test WorktreeInfo default values."""
        worktree = WorktreeInfo(branch="test", path=Path("/test"))

        assert worktree.is_current is False


class TestBranchStatus:
    """Tests for BranchStatus model."""

    def test_branch_status_creation(self):
        """Test creating BranchStatus instance."""
        path = Path("/test/path")
        status = BranchStatus(
            branch="test-branch",
            has_remote=True,
            is_merged=False,
            is_identical=False,
            path=path,
        )

        assert status.branch == "test-branch"
        assert status.has_remote is True
        assert status.is_merged is False
        assert status.is_identical is False
        assert status.path == path


class TestProcessInfo:
    """Tests for ProcessInfo model."""

    def test_process_info_creation(self):
        """Test creating ProcessInfo instance."""
        working_dir = Path("/test/dir")
        process = ProcessInfo(
            pid=1234, command="python server.py", working_dir=working_dir
        )

        assert process.pid == 1234
        assert process.command == "python server.py"
        assert process.working_dir == working_dir


class TestEnums:
    """Tests for enum values."""

    def test_terminal_mode_values(self):
        """Test TerminalMode enum values."""
        assert TerminalMode.TAB.value == "tab"
        assert TerminalMode.WINDOW.value == "window"
        assert TerminalMode.INPLACE.value == "inplace"

    def test_cleanup_mode_values(self):
        """Test CleanupMode enum values."""
        assert CleanupMode.ALL.value == "all"
        assert CleanupMode.REMOTELESS.value == "remoteless"
        assert CleanupMode.MERGED.value == "merged"
        assert CleanupMode.INTERACTIVE.value == "interactive"



---
File: /tests/unit/test_state_logic.py
---

"""Tests for state management business logic."""

import tempfile
from pathlib import Path
from unittest.mock import patch

from autowt.config import Config, TerminalConfig
from autowt.models import TerminalMode
from autowt.services.state import StateService


class TestStateServiceLogic:
    """Tests for StateService business logic (not file I/O)."""

    def test_config_round_trip_conversion(self):
        """Test converting config to dict and back preserves data."""
        # Create original config
        original_config = Config(
            terminal=TerminalConfig(mode=TerminalMode.WINDOW, always_new=True)
        )

        # Convert to dict and back
        config_dict = original_config.to_dict()
        restored_config = Config.from_dict(config_dict)

        # Verify data preservation
        assert restored_config.terminal.mode == original_config.terminal.mode
        assert (
            restored_config.terminal.always_new == original_config.terminal.always_new
        )

    def test_config_partial_data_handling(self):
        """Test config creation with partial data uses defaults."""
        # Test with minimal data
        config = Config.from_dict({})
        assert config.terminal.mode == TerminalMode.TAB  # default
        assert config.terminal.always_new is False  # default

        # Test with partial data
        config = Config.from_dict({"terminal": {"mode": "tab"}})
        assert config.terminal.mode == TerminalMode.TAB
        assert config.terminal.always_new is False  # default


class TestStateServicePlatformLogic:
    """Tests for platform-specific state service logic."""

    @patch("platform.system")
    def test_get_default_app_dir_macos(self, mock_system):
        """Test default app directory on macOS."""
        mock_system.return_value = "Darwin"

        with tempfile.TemporaryDirectory() as temp_dir:
            temp_home = Path(temp_dir)

            with patch("pathlib.Path.home", return_value=temp_home):
                service = StateService()
                expected = temp_home / "Library" / "Application Support" / "autowt"
                assert service.app_dir == expected

    @patch("platform.system")
    @patch.dict("os.environ", {"XDG_DATA_HOME": "/custom/xdg"})
    def test_get_default_app_dir_linux_xdg(self, mock_system, tmp_path):
        """Test default app directory on Linux with XDG_DATA_HOME."""
        mock_system.return_value = "Linux"

        # Use a temporary directory for the test
        with patch.dict("os.environ", {"XDG_DATA_HOME": str(tmp_path)}):
            service = StateService()
            expected = tmp_path / "autowt"
            assert service.app_dir == expected

    @patch("platform.system")
    @patch.dict("os.environ", {}, clear=True)
    def test_get_default_app_dir_linux_default(self, mock_system):
        """Test default app directory on Linux without XDG_DATA_HOME."""
        mock_system.return_value = "Linux"

        with tempfile.TemporaryDirectory() as temp_dir:
            temp_home = Path(temp_dir)

            with patch("pathlib.Path.home", return_value=temp_home):
                service = StateService()
                expected = temp_home / ".local" / "share" / "autowt"
                assert service.app_dir == expected

    @patch("platform.system")
    def test_get_default_app_dir_windows(self, mock_system):
        """Test default app directory on Windows."""
        mock_system.return_value = "Windows"

        with tempfile.TemporaryDirectory() as temp_dir:
            temp_home = Path(temp_dir)

            with patch("pathlib.Path.home", return_value=temp_home):
                service = StateService()
                expected = temp_home / ".autowt"
                assert service.app_dir == expected


class TestSessionIdLogic:
    """Tests for session ID management logic."""

    def test_session_id_updates(self):
        """Test session ID dictionary updates with composite keys."""
        repo_path = "/test/repo"
        session_ids = {
            f"{repo_path}:branch1": "session1",
            f"{repo_path}:branch2": "session2",
        }

        # Add new session
        session_ids[f"{repo_path}:branch3"] = "session3"
        assert f"{repo_path}:branch3" in session_ids
        assert session_ids[f"{repo_path}:branch3"] == "session3"

        # Update existing session
        session_ids[f"{repo_path}:branch1"] = "new-session1"
        assert session_ids[f"{repo_path}:branch1"] == "new-session1"

        # Remove session
        removed = session_ids.pop(f"{repo_path}:branch2", None)
        assert removed == "session2"
        assert f"{repo_path}:branch2" not in session_ids

    def test_session_id_cleanup_after_worktree_removal(self):
        """Test cleaning up session IDs when worktrees are removed."""
        repo_path = "/test/repo"
        session_ids = {
            f"{repo_path}:feature1": "session1",
            f"{repo_path}:feature2": "session2",
            f"{repo_path}:bugfix": "session3",
        }
        removed_branches = {"feature2", "bugfix"}

        # Remove session IDs for removed branches
        for branch in removed_branches:
            session_ids.pop(f"{repo_path}:{branch}", None)

        # Verify cleanup
        assert f"{repo_path}:feature1" in session_ids
        assert f"{repo_path}:feature2" not in session_ids
        assert f"{repo_path}:bugfix" not in session_ids
        assert len(session_ids) == 1

    def test_session_id_repo_disambiguation(self):
        """Test that session IDs are isolated per repository."""
        repo1_path = "/path/to/repo1"
        repo2_path = "/path/to/repo2"

        # Both repos have the same branch name "main"
        session_ids = {
            f"{repo1_path}:main": "session-repo1-main",
            f"{repo2_path}:main": "session-repo2-main",
            f"{repo1_path}:feature": "session-repo1-feature",
            f"{repo2_path}:feature": "session-repo2-feature",
        }

        # Verify sessions are isolated
        assert session_ids[f"{repo1_path}:main"] == "session-repo1-main"
        assert session_ids[f"{repo2_path}:main"] == "session-repo2-main"
        assert session_ids[f"{repo1_path}:feature"] == "session-repo1-feature"
        assert session_ids[f"{repo2_path}:feature"] == "session-repo2-feature"

        # Removing a branch from one repo doesn't affect the other
        session_ids.pop(f"{repo1_path}:main", None)
        assert f"{repo1_path}:main" not in session_ids
        assert f"{repo2_path}:main" in session_ids
        assert session_ids[f"{repo2_path}:main"] == "session-repo2-main"

        # Verify total count
        assert len(session_ids) == 3



---
File: /tests/unit/test_terminal_init_scripts.py
---

"""Tests for terminal service init script functionality."""

from pathlib import Path
from unittest.mock import Mock, patch

from autowt.models import TerminalMode
from autowt.services.terminal import TerminalService
from tests.mocks.services import MockStateService


class TestTerminalServiceInitScripts:
    """Tests for init script handling in terminal service."""

    def setup_method(self):
        """Set up test fixtures."""
        self.mock_state_service = MockStateService()
        self.terminal_service = TerminalService(self.mock_state_service)
        self.test_path = Path("/test/worktree")
        self.init_script = "setup.sh"

    def test_echo_commands_without_init_script(self, capsys):
        """Test echo mode without init script."""
        success = self.terminal_service._echo_commands(self.test_path)

        captured = capsys.readouterr()
        assert success
        assert captured.out.strip() == "cd /test/worktree"

    def test_echo_commands_with_init_script(self, capsys):
        """Test echo mode with init script."""
        success = self.terminal_service._echo_commands(self.test_path, self.init_script)

        captured = capsys.readouterr()
        assert success
        assert captured.out.strip() == "cd /test/worktree; setup.sh"

    def test_echo_commands_with_complex_script(self, capsys):
        """Test echo mode with complex init script."""
        complex_script = "mise install && uv sync --extra=dev"
        success = self.terminal_service._echo_commands(self.test_path, complex_script)

        captured = capsys.readouterr()
        assert success
        assert (
            captured.out.strip()
            == "cd /test/worktree; mise install && uv sync --extra=dev"
        )

    def test_change_directory_inplace_with_mock_terminal(self):
        """Test new inplace mode with mocked terminal execution."""
        # Mock terminal with execute_in_current_session method
        mock_terminal = Mock()
        mock_terminal.execute_in_current_session.return_value = True
        self.terminal_service.terminal = mock_terminal

        success = self.terminal_service._change_directory_inplace(
            self.test_path, self.init_script
        )

        assert success
        mock_terminal.execute_in_current_session.assert_called_once_with(
            "cd /test/worktree; setup.sh"
        )

    def test_change_directory_inplace_fallback_to_echo(self, capsys):
        """Test inplace mode falls back to echo when terminal doesn't support it."""
        # Mock terminal without execute_in_current_session method
        mock_terminal = Mock()
        # Explicitly set the method to not exist by using spec
        mock_terminal = Mock(spec=[])  # Empty spec means no methods/attributes
        self.terminal_service.terminal = mock_terminal

        success = self.terminal_service._change_directory_inplace(
            self.test_path, self.init_script
        )

        captured = capsys.readouterr()
        assert success
        assert captured.out.strip() == "cd /test/worktree; setup.sh"

    def test_terminal_implementation_delegation(self):
        """Test that TerminalService properly delegates to terminal implementations."""
        # Mock the terminal implementation
        mock_terminal = Mock()
        mock_terminal.open_new_tab.return_value = True
        mock_terminal.open_new_window.return_value = True
        mock_terminal.switch_to_session.return_value = True
        mock_terminal.supports_session_management.return_value = True

        # Replace the terminal with our mock
        self.terminal_service.terminal = mock_terminal

        # Test tab creation delegation
        success = self.terminal_service._switch_to_existing_or_new_tab(
            self.test_path, None, self.init_script, None, False
        )

        assert success
        mock_terminal.open_new_tab.assert_called_once_with(
            self.test_path, self.init_script
        )

        # Test window creation delegation
        mock_terminal.reset_mock()
        success = self.terminal_service._switch_to_existing_or_new_window(
            self.test_path, None, self.init_script, None, None, False
        )

        assert success
        mock_terminal.open_new_window.assert_called_once_with(
            self.test_path, self.init_script
        )

    def test_switch_to_worktree_delegates_correctly(self):
        """Test that switch_to_worktree passes init_script to appropriate methods."""
        with patch.object(
            self.terminal_service, "_change_directory_inplace"
        ) as mock_inplace:
            mock_inplace.return_value = True

            success = self.terminal_service.switch_to_worktree(
                self.test_path, TerminalMode.INPLACE, None, self.init_script
            )

            assert success
            mock_inplace.assert_called_once_with(self.test_path, self.init_script, None)

        # Test ECHO mode delegation
        with patch.object(self.terminal_service, "_echo_commands") as mock_echo:
            mock_echo.return_value = True

            success = self.terminal_service.switch_to_worktree(
                self.test_path, TerminalMode.ECHO, None, self.init_script
            )

            assert success
            mock_echo.assert_called_once_with(self.test_path, self.init_script, None)

        # Mock the terminal implementation to test delegation
        mock_terminal = Mock()
        mock_terminal.open_new_tab.return_value = True
        mock_terminal.open_new_window.return_value = True
        mock_terminal.supports_session_management.return_value = False
        self.terminal_service.terminal = mock_terminal

        # Test TAB mode delegation
        success = self.terminal_service.switch_to_worktree(
            self.test_path, TerminalMode.TAB, None, self.init_script
        )

        assert success
        mock_terminal.open_new_tab.assert_called_once_with(
            self.test_path, self.init_script
        )

        # Test WINDOW mode delegation
        mock_terminal.reset_mock()
        success = self.terminal_service.switch_to_worktree(
            self.test_path, TerminalMode.WINDOW, None, self.init_script
        )

        assert success
        mock_terminal.open_new_window.assert_called_once_with(
            self.test_path, self.init_script
        )

    def test_switch_to_existing_or_new_tab_with_init_script(self):
        """Test switch_to_existing_or_new_tab handles init scripts."""
        # Mock the terminal implementation
        mock_terminal = Mock()
        mock_terminal.switch_to_session.return_value = (
            False  # Simulate session switch failure
        )
        mock_terminal.open_new_tab.return_value = True
        mock_terminal.supports_session_management.return_value = True
        self.terminal_service.terminal = mock_terminal

        with patch.object(
            self.terminal_service, "_should_switch_to_existing"
        ) as mock_should_switch:
            mock_should_switch.return_value = True  # User wants to switch

            success = self.terminal_service._switch_to_existing_or_new_tab(
                self.test_path,
                "session-id",
                self.init_script,
                None,
                "test-branch",
                False,
            )

            assert success
            # Should try to switch to session first (no init script), then fall back to new tab
            mock_should_switch.assert_called_once_with("test-branch")
            mock_terminal.switch_to_session.assert_called_once_with(
                "session-id",
                None,  # No init script when switching to existing session
            )
            mock_terminal.open_new_tab.assert_called_once_with(
                self.test_path, self.init_script
            )


class TestInitScriptEdgeCases:
    """Test edge cases and error handling for init scripts."""

    def setup_method(self):
        """Set up test fixtures."""
        self.mock_state_service = MockStateService()
        self.terminal_service = TerminalService(self.mock_state_service)
        self.test_path = Path("/test/worktree")

    def test_empty_init_script_treated_as_none(self, capsys):
        """Test that empty string init script is handled gracefully in echo mode."""
        success = self.terminal_service._echo_commands(self.test_path, "")

        captured = capsys.readouterr()
        assert success
        assert captured.out.strip() == "cd /test/worktree"

    def test_whitespace_only_init_script(self, capsys):
        """Test init script with only whitespace in echo mode."""
        success = self.terminal_service._echo_commands(self.test_path, "   ")

        captured = capsys.readouterr()
        assert success
        # The whitespace gets trimmed and filtered out, leaving only the cd command
        assert captured.out.strip() == "cd /test/worktree"

    def test_init_script_with_special_characters(self, capsys):
        """Test init script with special shell characters in echo mode."""
        special_script = "echo 'test'; ls | grep '*.py' && echo $HOME"
        success = self.terminal_service._echo_commands(self.test_path, special_script)

        captured = capsys.readouterr()
        assert success
        expected = f"cd /test/worktree; {special_script}"
        assert captured.out.strip() == expected

    def test_multiline_init_script(self, capsys):
        """Test multi-line init script gets normalized to single line in echo mode."""
        multiline_script = "echo 'line1'\necho 'line2'\necho 'line3'"
        success = self.terminal_service._echo_commands(self.test_path, multiline_script)

        captured = capsys.readouterr()
        assert success
        expected = "cd /test/worktree; echo 'line1'; echo 'line2'; echo 'line3'"
        assert captured.out.strip() == expected

    def test_terminal_implementation_applescript_failure(
        self, mock_terminal_operations
    ):
        """Test handling of AppleScript execution failure with init script."""
        mock_terminal_operations["applescript"].return_value = False

        # Mock the terminal implementation
        mock_terminal = Mock()
        mock_terminal.open_new_tab.return_value = False  # Simulate failure
        mock_terminal.supports_session_management.return_value = False
        self.terminal_service.terminal = mock_terminal

        success = self.terminal_service._switch_to_existing_or_new_tab(
            self.test_path, None, "setup.sh", None, False
        )

        assert not success
        mock_terminal.open_new_tab.assert_called_once_with(self.test_path, "setup.sh")

    def test_path_with_spaces_and_init_script(self, capsys):
        """Test handling paths with spaces combined with init scripts in echo mode."""
        path_with_spaces = Path("/test/my worktree/branch")
        success = self.terminal_service._echo_commands(path_with_spaces, "setup.sh")

        captured = capsys.readouterr()
        assert success
        # Path should be properly quoted
        assert "'/test/my worktree/branch'" in captured.out
        assert "setup.sh" in captured.out



---
File: /tests/unit/test_terminal_modes.py
---

"""Tests for new terminal mode functionality (ECHO and INPLACE)."""

from pathlib import Path
from unittest.mock import Mock, patch

from autowt.models import TerminalMode
from autowt.services.terminal import (
    ITerm2Terminal,
    TerminalAppTerminal,
    TerminalService,
)
from tests.mocks.services import MockStateService


class TestTerminalModes:
    """Tests for ECHO and INPLACE terminal modes."""

    def setup_method(self):
        """Set up test fixtures."""
        self.mock_state_service = MockStateService()
        self.terminal_service = TerminalService(self.mock_state_service)
        self.test_path = Path("/test/worktree")
        self.init_script = "setup.sh"

    def test_switch_to_worktree_echo_mode(self):
        """Test switch_to_worktree with ECHO mode."""
        with patch.object(self.terminal_service, "_echo_commands") as mock_echo:
            mock_echo.return_value = True

            success = self.terminal_service.switch_to_worktree(
                self.test_path, TerminalMode.ECHO, None, self.init_script
            )

            assert success
            mock_echo.assert_called_once_with(self.test_path, self.init_script, None)

    def test_switch_to_worktree_inplace_mode(self):
        """Test switch_to_worktree with INPLACE mode."""
        with patch.object(
            self.terminal_service, "_change_directory_inplace"
        ) as mock_inplace:
            mock_inplace.return_value = True

            success = self.terminal_service.switch_to_worktree(
                self.test_path, TerminalMode.INPLACE, None, self.init_script
            )

            assert success
            mock_inplace.assert_called_once_with(self.test_path, self.init_script, None)

    def test_switch_to_worktree_unknown_mode(self):
        """Test switch_to_worktree with unknown mode."""
        # Mock an unknown mode
        unknown_mode = "unknown"

        success = self.terminal_service.switch_to_worktree(
            self.test_path, unknown_mode, None, self.init_script
        )

        assert not success


class TestITerm2Terminal:
    """Tests for iTerm2 terminal execute_in_current_session method."""

    def setup_method(self):
        """Set up test fixtures."""
        self.terminal = ITerm2Terminal()

    def test_execute_in_current_session_success(self):
        """Test successful command execution in iTerm2."""
        command = "cd /test/worktree; setup.sh"

        with patch.object(self.terminal, "_run_applescript") as mock_applescript:
            mock_applescript.return_value = True

            success = self.terminal.execute_in_current_session(command)

            assert success
            mock_applescript.assert_called_once()

            # Check that the applescript contains the expected command
            call_args = mock_applescript.call_args[0][0]
            assert "write text" in call_args
            assert "cd /test/worktree; setup.sh" in call_args

    def test_execute_in_current_session_failure(self):
        """Test failed command execution in iTerm2."""
        command = "cd /test/worktree"

        with patch.object(self.terminal, "_run_applescript") as mock_applescript:
            mock_applescript.return_value = False

            success = self.terminal.execute_in_current_session(command)

            assert not success
            mock_applescript.assert_called_once()

    def test_execute_in_current_session_escapes_command(self):
        """Test that special characters in command are properly escaped."""
        command = 'cd "/test/path with spaces"; echo "hello world"'

        with patch.object(self.terminal, "_run_applescript") as mock_applescript:
            mock_applescript.return_value = True

            self.terminal.execute_in_current_session(command)

            # Check that the command was escaped
            call_args = mock_applescript.call_args[0][0]
            assert '\\"' in call_args  # Quotes should be escaped


class TestTerminalAppTerminal:
    """Tests for Terminal.app execute_in_current_session method."""

    def setup_method(self):
        """Set up test fixtures."""
        self.terminal = TerminalAppTerminal()

    def test_execute_in_current_session_success(self):
        """Test successful command execution in Terminal.app."""
        command = "cd /test/worktree; setup.sh"

        with patch.object(self.terminal, "_run_applescript") as mock_applescript:
            mock_applescript.return_value = True

            success = self.terminal.execute_in_current_session(command)

            assert success
            mock_applescript.assert_called_once()

            # Check that the applescript contains the expected command
            call_args = mock_applescript.call_args[0][0]
            assert "do script" in call_args
            assert "selected tab of front window" in call_args
            assert "cd /test/worktree; setup.sh" in call_args

    def test_execute_in_current_session_failure(self):
        """Test failed command execution in Terminal.app."""
        command = "cd /test/worktree"

        with patch.object(self.terminal, "_run_applescript") as mock_applescript:
            mock_applescript.return_value = False

            success = self.terminal.execute_in_current_session(command)

            assert not success
            mock_applescript.assert_called_once()


class TestTerminalModeIntegration:
    """Integration tests for terminal modes with different terminals."""

    def setup_method(self):
        """Set up test fixtures."""
        self.mock_state_service = MockStateService()
        self.terminal_service = TerminalService(self.mock_state_service)
        self.test_path = Path("/test/worktree")

    def test_inplace_mode_with_iterm2_terminal(self):
        """Test inplace mode with iTerm2 terminal."""
        # Mock iTerm2 terminal
        mock_terminal = Mock(spec=ITerm2Terminal)
        mock_terminal.execute_in_current_session.return_value = True
        self.terminal_service.terminal = mock_terminal

        success = self.terminal_service._change_directory_inplace(
            self.test_path, "setup.sh"
        )

        assert success
        mock_terminal.execute_in_current_session.assert_called_once_with(
            "cd /test/worktree; setup.sh"
        )

    def test_inplace_mode_with_terminal_app(self):
        """Test inplace mode with Terminal.app."""
        # Mock Terminal.app terminal
        mock_terminal = Mock(spec=TerminalAppTerminal)
        mock_terminal.execute_in_current_session.return_value = True
        self.terminal_service.terminal = mock_terminal

        success = self.terminal_service._change_directory_inplace(
            self.test_path, "setup.sh"
        )

        assert success
        mock_terminal.execute_in_current_session.assert_called_once_with(
            "cd /test/worktree; setup.sh"
        )

    def test_inplace_mode_fallback_for_unsupported_terminal(self, capsys):
        """Test inplace mode falls back to echo for unsupported terminals."""
        # Mock a terminal without execute_in_current_session
        mock_terminal = Mock(spec=[])  # Empty spec means no methods/attributes
        self.terminal_service.terminal = mock_terminal

        success = self.terminal_service._change_directory_inplace(
            self.test_path, "setup.sh"
        )

        captured = capsys.readouterr()
        assert success
        assert captured.out.strip() == "cd /test/worktree; setup.sh"



---
File: /tests/unit/test_utils.py
---

"""Tests for utility functions."""

from autowt.utils import sanitize_branch_name


class TestSanitizeBranchName:
    """Tests for branch name sanitization."""

    def test_simple_branch_name(self):
        """Test that simple branch names pass through unchanged."""
        assert sanitize_branch_name("feature") == "feature"
        assert sanitize_branch_name("main") == "main"
        assert sanitize_branch_name("develop") == "develop"

    def test_slash_replacement(self):
        """Test that slashes are replaced with hyphens."""
        assert sanitize_branch_name("steve/bugfix") == "steve-bugfix"
        assert sanitize_branch_name("feature/user-auth") == "feature-user-auth"
        assert sanitize_branch_name("fix/multiple/slashes") == "fix-multiple-slashes"

    def test_space_replacement(self):
        """Test that spaces are replaced with hyphens."""
        assert sanitize_branch_name("fix bug") == "fix-bug"
        assert sanitize_branch_name("new feature") == "new-feature"

    def test_backslash_replacement(self):
        """Test that backslashes are replaced with hyphens."""
        assert sanitize_branch_name("windows\\path") == "windows-path"

    def test_special_characters_removal(self):
        """Test that problematic characters are removed."""
        # These characters can cause filesystem issues
        assert sanitize_branch_name("branch@name") == "branchname"
        assert sanitize_branch_name("branch#hash") == "branchhash"
        assert sanitize_branch_name("branch:colon") == "branchcolon"

    def test_dots_and_hyphens_trimming(self):
        """Test that leading/trailing dots and hyphens are removed."""
        assert sanitize_branch_name(".hidden-branch") == "hidden-branch"
        assert sanitize_branch_name("branch-name.") == "branch-name"
        assert sanitize_branch_name("-leading-hyphen") == "leading-hyphen"
        assert sanitize_branch_name("trailing-hyphen-") == "trailing-hyphen"

    def test_allowed_characters_preserved(self):
        """Test that allowed characters are preserved."""
        assert sanitize_branch_name("feature_123") == "feature_123"
        assert sanitize_branch_name("v1.2.3") == "v1.2.3"
        assert sanitize_branch_name("branch-name") == "branch-name"

    def test_empty_or_invalid_names(self):
        """Test handling of empty or completely invalid names."""
        assert sanitize_branch_name("") == "branch"
        assert sanitize_branch_name("...") == "branch"
        assert sanitize_branch_name("---") == "branch"
        assert sanitize_branch_name("@#$%") == "branch"

    def test_complex_branch_names(self):
        """Test complex real-world branch names."""
        assert (
            sanitize_branch_name("feature/user-auth/oauth2.0")
            == "feature-user-auth-oauth2.0"
        )
        assert (
            sanitize_branch_name("bugfix/issue-123_critical")
            == "bugfix-issue-123_critical"
        )
        assert sanitize_branch_name("release/v2.1.0-rc1") == "release-v2.1.0-rc1"



---
File: /tests/__init__.py
---




---
File: /tests/conftest.py
---

"""Pytest configuration and shared fixtures."""

from unittest.mock import Mock, patch

import pytest

from autowt.config import Config
from autowt.models import (
    BranchStatus,
    ProcessInfo,
    WorktreeInfo,
)
from tests.mocks.services import MockTerminalService


@pytest.fixture
def temp_repo_path(tmp_path):
    """Create a temporary repository path."""
    repo_path = tmp_path / "test-repo"
    repo_path.mkdir()
    return repo_path


@pytest.fixture
def sample_config():
    """Sample configuration for testing."""
    return Config()


@pytest.fixture
def sample_worktrees(temp_repo_path):
    """Sample worktree data for testing."""
    return [
        WorktreeInfo(
            branch="feature1",
            path=temp_repo_path.parent / "test-repo-worktrees" / "feature1",
            is_current=False,
        ),
        WorktreeInfo(
            branch="feature2",
            path=temp_repo_path.parent / "test-repo-worktrees" / "feature2",
            is_current=True,
        ),
        WorktreeInfo(
            branch="bugfix",
            path=temp_repo_path.parent / "test-repo-worktrees" / "bugfix",
            is_current=False,
        ),
    ]


@pytest.fixture
def sample_branch_statuses(sample_worktrees):
    """Sample branch status data for testing."""
    return [
        BranchStatus(
            branch="feature1",
            has_remote=False,  # Make it remoteless so it gets cleaned up
            is_merged=False,
            is_identical=False,
            path=sample_worktrees[0].path,
        ),
        BranchStatus(
            branch="feature2",
            has_remote=False,
            is_merged=False,
            is_identical=True,  # This branch is identical to main
            path=sample_worktrees[1].path,
        ),
        BranchStatus(
            branch="bugfix",
            has_remote=True,
            is_merged=True,
            is_identical=False,
            path=sample_worktrees[2].path,
        ),
    ]


@pytest.fixture
def sample_processes(sample_worktrees):
    """Sample process data for testing."""
    return [
        ProcessInfo(
            pid=1234, command="python server.py", working_dir=sample_worktrees[0].path
        ),
        ProcessInfo(
            pid=5678, command="npm run dev", working_dir=sample_worktrees[1].path
        ),
    ]


@pytest.fixture(autouse=True)
def mock_terminal_operations():
    """Automatically mock potentially harmful terminal operations in all tests."""
    with (
        patch(
            "autowt.services.terminal.Terminal._run_applescript",
            return_value=True,
        ) as mock_applescript,
        patch(
            "autowt.services.terminal.run_command", return_value=Mock(returncode=0)
        ) as mock_run_command,
        patch("platform.system", return_value="Darwin") as mock_platform,
    ):
        yield {
            "applescript": mock_applescript,
            "run_command": mock_run_command,
            "platform": mock_platform,
        }


@pytest.fixture
def mock_terminal_service():
    """Provide a fully mocked terminal service."""
    return MockTerminalService()



---
File: /CLAUDE.md
---

# Project conventions

- Python 3.10+ project using uv for dependency management
- Setup: `mise install && uv sync`
- Format: `mise run format` (ruff)
- Lint: `mise run lint` (ruff)
- Test: `mise run test` (pytest)
- Install pre-commit: `uv run pre-commit install`

## Environment setup

- Create `.env` file with `GITHUB_TOKEN=your_token` for cimonitor
- mise automatically loads .env file (already configured)
- Use `uv run cimonitor status --pr <number>` to check CI status

## Code organization

- `src/autowt/cli.py` - Main CLI entry point with command definitions
- `src/autowt/commands/` - Command implementations (checkout, cleanup, etc.)
- `src/autowt/services/` - Core services (git, state, process management)
- `src/autowt/models/` - Data models and types

## How to get up to speed

- Read README.md

## The scratchpad directory

ENCOURAGED: Use scratch/ directory for all temporary files or non-documentation Markdown files.
FORBIDDEN: Using /tmp
FORBIDDEN: deleting the entire scratch/ directory



---
File: /requirements-docs.txt
---

mkdocs>=1.5.3
mkdocs-material>=9.4.6
mkdocstrings[python]>=0.23.0
pymdown-extensions>=10.3.1
mkdocs-mermaid2-plugin>=1.1.1
mkdocs-github-admonitions-plugin
